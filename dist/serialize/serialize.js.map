{"version":3,"file":"serialize.js","sourceRoot":"","sources":["../../src/serialize/serialize.ts"],"names":[],"mappings":"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","sourcesContent":["// import {target} from \"../target/target\";\n// import {note} from \"../note/note\";\n// import TreeModel = require(\"tree-model\");\n// import {trainer} from \"../train/trainer\";\n// import {file} from \"../io/file\";\n// import {algorithm} from \"../train/algorithm\";\n//\n// export namespace serialize {\n//\n//     export let serialize_note = (note: TreeModel.Node<note.Note>) => {\n//         return JSON.stringify(note.model);\n//     };\n//\n//     export let deserialize_note = (note_serialized) => {\n//         if (note_serialized === null) {\n//             return null\n//         }\n//         let tree = new TreeModel();\n//         return tree.parse(JSON.parse(note_serialized));\n//     };\n//\n//     export let serialize_sequence_note = (notes) => {\n//         if (!notes) {\n//             return null\n//         }\n//         let notes_serialized = [];\n//         for (let note of notes) {\n//             notes_serialized.push(serialize_note(note))\n//         }\n//         return notes_serialized\n//     };\n//\n//     import Subtarget = target.Subtarget;\n//\n//     export let serialize_subtarget = (subtarget: Subtarget) => {\n//         let subtarget_serialized: any;\n//         // TODO: fix\n//         // let subtarget_serialized = subtarget;\n//         subtarget_serialized = subtarget;\n//         subtarget_serialized.note = serialize_note(subtarget.note);\n//         return subtarget_serialized;\n//     };\n//\n//     export let deserialize_subtarget = (subtarget_serialized) => {\n//         let subtarget_deserialized = subtarget_serialized;\n//         subtarget_deserialized.note = deserialize_note(subtarget_serialized.note);\n//         return subtarget_deserialized;\n//     };\n//\n//     // import SequenceTarget = history.SequenceTarget;\n//\n//     export let serialize_target_sequence = (sequence_target) => {\n//         let sequence_target_serialized = sequence_target;\n//         for (let i_target in sequence_target) {\n//             let subtargets = sequence_target[Number(i_target)].iterator_subtarget.subtargets;\n//             for (let i_subtarget in subtargets) {\n//                 let subtarget = subtargets[Number(i_subtarget)];\n//                 sequence_target_serialized[Number(i_target)][Number(i_subtarget)] = serialize_subtarget(subtarget)\n//             }\n//         }\n//         return sequence_target_serialized;\n//     };\n//\n//     // TODO: deserialize\n//     export let deserialize_target_sequence = (sequence_target_serialized) => {\n//         let sequence_target_deserialized = sequence_target_serialized;\n//\n//         for (let i_target in sequence_target_serialized) {\n//             let subtargets = sequence_target_serialized[Number(i_target)].get_subtargets();\n//             for (let i_subtarget in subtargets) {\n//                 let subtarget = subtargets[Number(i_subtarget)];\n//                 sequence_target_deserialized[Number(i_target)][Number(i_subtarget)] = deserialize_subtarget(subtarget)\n//             }\n//         }\n//         return sequence_target_deserialized;\n//     };\n// }\n//\n// export namespace freeze {\n//     import Trainer = trainer.Trainer;\n//     import serialize_target_sequence = serialize.serialize_target_sequence;\n//     import to_json = file.to_json;\n//     import DETECT = algorithm.DETECT;\n//     import PREDICT = algorithm.PREDICT;\n//     import PARSE = algorithm.PARSE;\n//     import DERIVE = algorithm.DERIVE;\n//     import serialize_sequence_note = serialize.serialize_sequence_note;\n//\n//     export class TrainFreezer {\n//\n//         env: string;\n//\n//         constructor(env: string) {\n//             this.env = env;\n//         }\n//\n//         public freeze(trainer: Trainer, filepath: string) {\n//             let data_serializable = trainer.history_user_input.matrix_data as any;\n//\n//             switch (trainer.algorithm.get_name()) {\n//                 case DETECT: {\n//                     for (let i_row in trainer.history_user_input.matrix_data) {\n//                         for (let i_col in trainer.history_user_input.matrix_data[Number(i_row)]) {\n//                             data_serializable[Number(i_row)][Number(i_col)] = serialize_target_sequence(\n//                                 trainer.history_user_input.matrix_data[Number(i_row)][Number(i_col)]\n//                             )\n//                         }\n//                     }\n//                     break;\n//                 }\n//                 case PREDICT: {\n//                     // TODO\n//                     break;\n//                 }\n//                 case PARSE: {\n//                     for (let i_row in trainer.history_user_input.matrix_data) {\n//                         for (let i_col in trainer.history_user_input.matrix_data[Number(i_row)]) {\n//                             data_serializable[Number(i_row)][Number(i_col)] = serialize_sequence_note(\n//                                 trainer.history_user_input.matrix_data[Number(i_row)][Number(i_col)]\n//                             )\n//                         }\n//                     }\n//                     break;\n//                 }\n//                 case DERIVE: {\n//                     // TODO\n//                     break;\n//                 }\n//             }\n//\n//             to_json(data_serializable, filepath, this.env)\n//         }\n//     }\n// }\n//\n// export namespace thaw {\n//     import Trainer = trainer.Trainer;\n//     import deserialize_target_sequence = serialize.deserialize_target_sequence;\n//     import from_json = file.from_json;\n//     import Note = note.Note;\n//     import PREDICT = algorithm.PREDICT;\n//     import PARSE = algorithm.PARSE;\n//     import serialize_target_sequence = serialize.serialize_target_sequence;\n//     import serialize_sequence_note = serialize.serialize_sequence_note;\n//     import DERIVE = algorithm.DERIVE;\n//     import DETECT = algorithm.DETECT;\n//     import deserialize_note = serialize.deserialize_note;\n//\n//     export class TrainThawer {\n//         env: string;\n//\n//         constructor(env: string) {\n//             this.env = env;\n//         }\n//\n//         public thaw(filepath: string, config): Trainer {\n//\n//             let trainer;\n//\n//             let matrix_deserialized = from_json(filepath, config['env']);\n//\n//             trainer =  new Trainer(\n//                 config['window'],\n//                 config['user_input_handler'],\n//                 config['algorithm'],\n//                 config['clip_user_input'],\n//                 config['clip_user_input_synchronous'],\n//                 config['track_target'],\n//                 config['song'],\n//                 config['segments'],\n//                 config['messenger']\n//             );\n//\n//             trainer.init(\n//                 true\n//             );\n//\n//             switch (config['algorithm'].get_name()) {\n//                 case DETECT: {\n//                     let notes = [];\n//                     // TODO: this is only valid for forward iteration\n//                     for (let row of matrix_deserialized) {\n//                         for (let col of row) {\n//                             if (col === null) {\n//                                 continue;\n//                             }\n//                             for (let sequence_target of col) {\n//                                 for (let note of sequence_target.iterator_subtarget.subtargets) {\n//                                     notes.push(note)\n//                                 }\n//                             }\n//                         }\n//                     }\n//                     let notes_parsed = notes.map((obj)=>{return JSON.parse(obj.note)});\n//\n//                     let tree: TreeModel = new TreeModel();\n//\n//                     for (let note_parsed of notes_parsed) {\n//                         let note_recovered = tree.parse(\n//                             {\n//                                 id: -1, // TODO: hashing scheme for clip id and beat start\n//                                 note: new Note(\n//                                     note_parsed.note.pitch,\n//                                     note_parsed.note.beat_start,\n//                                     note_parsed.note.beats_duration,\n//                                     note_parsed.note.velocity,\n//                                     note_parsed.note.muted\n//                                 ),\n//                                 children: [\n//\n//                                 ]\n//                             }\n//                         );\n//                         trainer.accept_input(\n//                             [note_recovered]\n//                         );\n//                     }\n//\n//                     trainer.pause();\n//\n//                     break;\n//                 }\n//                 case PREDICT: {\n//                     break;\n//                 }\n//                 case PARSE: {\n//                     let input_left = true;\n//\n//                     while (input_left) {\n//                         let coord_current = trainer.iterator_matrix_train.get_coord_current();\n//                         trainer.accept_input(\n//                             matrix_deserialized[coord_current[0]][coord_current[1]].map((note_serialized) => {\n//                                 return deserialize_note(note_serialized)\n//                             })\n//                         );\n//\n//                         if (trainer.iterator_matrix_train.done) {\n//                             input_left = false;\n//                         }\n//                     }\n//\n//                     trainer.pause();\n//\n//                     break;\n//                 }\n//                 case DERIVE: {\n//                     break;\n//                 }\n//             }\n//\n//\n//             return trainer;\n//         }\n//     }\n// }"]}