{"version":3,"file":"train.js","sourceRoot":"","sources":["../../src/scripts/train.ts"],"names":[],"mappings":"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","sourcesContent":["// import {message as m, message} from \"../message/messenger\";\n// import Messenger = message.Messenger;\n// import {map} from \"../control/map\";\n// import FretMapper = map.FretMapper;\n// import {trainer as tr} from \"../train/trainer\";\n// import Trainer = tr.Trainer;\n// import {freeze, thaw} from \"../serialize/serialize\";\n// import TrainThawer = thaw.TrainThawer;\n// import {algorithm} from \"../train/algorithm\";\n// import Detect = algorithm.Detect;\n// import {live as li, live} from \"../live/live\";\n// import LiveClipVirtual = live.LiveClipVirtual;\n// import {segment as module_segment} from \"../segment/segment\";\n// import Segment = module_segment.Segment;\n// import {modes_control, modes_texture} from \"../constants/constants\";\n// import INSTRUMENTAL = modes_control.INSTRUMENTAL;\n// import {clip as c, clip} from \"../clip/clip\";\n// import Clip = clip.Clip;\n// import {user_input} from \"../control/user_input\";\n// import UserInputHandler = user_input.UserInputHandler;\n// import POLYPHONY = modes_texture.POLYPHONY;\n// import TrainFreezer = freeze.TrainFreezer;\n// import {window as w} from \"../render/window\";\n// import MatrixWindow = w.MatrixWindow;\n// import LiveApiJs = live.LiveApiJs;\n// import {log} from \"../log/logger\";\n// import Logger = log.Logger;\n// import MONOPHONY = modes_texture.MONOPHONY;\n// import VOCAL = modes_control.VOCAL;\n// import {utils} from \"../utils/utils\";\n// import path_clip_from_list_path_device = utils.path_clip_from_list_path_device;\n// import DETECT = algorithm.DETECT;\n// import PREDICT = algorithm.PREDICT;\n// import PARSE = algorithm.PARSE;\n// import DERIVE = algorithm.DERIVE;\n// import Predict = algorithm.Predict;\n// import Derive = algorithm.Derive;\n// import Parse = algorithm.Parse;\n// import FREESTYLE = algorithm.FREESTYLE;\n// import {song as sng} from \"../song/song\";\n// import Song = sng.Song;\n// import SongDao = sng.SongDao;\n// import {note as n} from \"../note/note\";\n// import TreeModel = require(\"tree-model\");\n// import {scene} from \"../scene/scene\";\n// import SceneDao = scene.SceneDao;\n// import Scene = scene.Scene;\n// import ClipDao = clip.ClipDao;\n// import {get_notes_segments} from \"./segmenter\";\n// // const _ = require('underscore');\n//\n// declare let autowatch: any;\n// declare let inlets: any;\n// declare let outlets: any;\n// declare function outlet(n: number, o: any): void;\n// declare function post(message?: any): void;\n//\n// export {}\n//\n// declare let Global: any;\n//\n// let env: string = 'max';\n//\n// if (env === 'max') {\n//     post('recompile successful');\n//     autowatch = 1;\n// }\n//\n// let logger = new Logger(env);\n// let messenger_render = new Messenger(env, 0, 'render');\n// let messenger_monitor_target = new Messenger(env, 0, 'index_track_target');\n// let messenger_num_segments = new Messenger(env, 0, 'num_segments');\n// let mode_texture, mode_control, clip_user_input, clip_user_input_synchronous, song, algorithm_train, user_input_handler, window, segments_train, trainer;\n// let index_track_target;\n//\n// let set_mode_texture = (option) => {\n//     switch (option) {\n//         case POLYPHONY: {\n//             mode_texture = option;\n//             break;\n//         }\n//         case MONOPHONY: {\n//             mode_texture = option;\n//             break;\n//         }\n//         default: {\n//             post('error setting texture')\n//         }\n//     }\n// };\n//\n// let set_mode_control = (option) => {\n//     switch (option) {\n//         case VOCAL: {\n//             mode_control = option;\n//             break;\n//         }\n//         case INSTRUMENTAL: {\n//             mode_control = option;\n//             break;\n//         }\n//         default: {\n//             post('error setting control')\n//         }\n//     }\n// };\n//\n// let set_algorithm_train = (option) => {\n//\n//     user_input_handler = new UserInputHandler(\n//         mode_texture,\n//         mode_control\n//     );\n//\n//     switch (option) {\n//         case FREESTYLE: {\n//             // algorithm_train = new Freestyle(\n//             //     user_input_handler\n//             // );\n//             break;\n//         }\n//         case DETECT: {\n//             algorithm_train = new Detect(\n//                 user_input_handler\n//             );\n//             break;\n//         }\n//         case PREDICT: {\n//             algorithm_train = new Predict(\n//                 user_input_handler\n//             );\n//             break;\n//         }\n//         case PARSE: {\n//             algorithm_train = new Parse(\n//                 user_input_handler\n//             );\n//             break;\n//         }\n//         case DERIVE: {\n//             algorithm_train = new Derive(\n//                 user_input_handler\n//             );\n//             break;\n//         }\n//         default: {\n//             post('error setting algorithm')\n//         }\n//     }\n//\n//     window = new MatrixWindow(\n//         384,\n//         384,\n//         messenger_render,\n//         algorithm_train\n//     );\n// };\n//\n// let set_depth_tree = (depth) => {\n//     algorithm_train.set_depth(\n//         depth\n//     );\n// };\n//\n// let set_clip_user_input = () => {\n//     let live_api = new li.LiveApiJs(\n//         'live_set view highlighted_clip_slot clip'\n//     );\n//\n//     clip_user_input_synchronous = new c.Clip(\n//         new c.ClipDao(\n//             live_api,\n//             new m.Messenger(env, 0),\n//             false\n//         )\n//     );\n//\n//     clip_user_input = new c.Clip(\n//         new c.ClipDao(\n//             live_api,\n//             new m.Messenger(env, 0),\n//             true,\n//             'clip_user_input'\n//         )\n//     );\n//\n//     clip_user_input.set_path_deferlow(\n//         'set_path_clip_user_input'\n//     )\n// };\n//\n// // update_clips(clip_user_input_current: Clip, clip_user_input_synchronous_current: Clip): Clip[] {\n// //\n// //     let list_path_current_s = clip_user_input_synchronous_current.get_path().split(' ');\n// //     let index_clipslot_current_s = list_path_current_s[list_path_current_s.length - 2];\n// //     let list_path_next_s = list_path_current_s;\n// //\n// //     let list_path_current = clip_user_input_current.get_path().split(' ');\n// //     let index_clipslot_current = list_path_current[list_path_current.length - 2];\n// //     let list_path_next = list_path_current;\n// //\n// //     list_path_next_s[list_path_next_s.length - 2] = index_clipslot_current_s + 1;\n// //\n// //     let clip_user_input_synchronous_next = new Clip(\n// //         new ClipDao(\n// //             new LiveApiJs(\n// //                 list_path_next_s.join(' ')\n// //             ),\n// //             new Messenger('max', 0)\n// //         )\n// //     );\n// //\n// //     list_path_next[list_path_next.length - 2] = index_clipslot_current + 1;\n// //\n// //     let clip_user_input_next = new Clip(\n// //         new ClipDao(\n// //             new LiveApiJs(\n// //                 list_path_next.join(' ')\n// //             ),\n// //             new Messenger('max', 0),\n// //             true,\n// //             'clip_user_input'\n// //         )\n// //     );\n// //\n// //     clip_user_input_next.set_path_deferlow('set_path_clip_user_input');\n// //\n// //     return [clip_user_input_next, clip_user_input_synchronous_next]\n// // }\n//\n// let set_segments = () => {\n//\n//     // TODO: this assumes the trainer device is on the same track as the segmenter\n//     let notes_segments = get_notes_segments();\n//\n//     let this_device = new li.LiveApiJs('this_device');\n//\n//     // let path_this_track = this_device.get_path().split(' ').slice(0, 3).join(' ');\n//\n//     let segments = [];\n//\n//     for (let i_note in notes_segments) {\n//         let note = notes_segments[Number(i_note)];\n//         let path_scene = ['live_set', 'scenes', Number(i_note)].join(' ');\n//         let segment = new Segment(\n//             note\n//         );\n//\n//         segment.set_scene(\n//             new Scene(\n//                 new SceneDao(\n//                     new li.LiveApiJs(\n//                         path_scene\n//                     )\n//                 )\n//             )\n//         );\n//\n//         segment.set_clip_user_input_sync(\n//             new Clip(\n//                 new ClipDao(\n//                     new LiveApiJs(\n//                         this_device.get_path().split(' ').concat(['clip_slots', i_note, 'clip']).join(' ')\n//                     ),\n//                     new Messenger(env, 0)\n//                 )\n//             )\n//         );\n//\n//         segment.set_clip_user_input_async(\n//             new Clip(\n//                 new ClipDao(\n//                     new LiveApiJs(\n//                         this_device.get_path().split(' ').concat(['clip_slots', i_note, 'clip']).join(' ')\n//                     ),\n//                     new Messenger(env, 0),\n//                     true,\n//                     'clip_user_input'\n//                 )\n//             )\n//         );\n//\n//         segments.push(\n//             segment\n//         )\n//\n//     }\n//\n//     messenger_num_segments.message([segments.length]);\n//\n//     segments_train = segments\n// };\n//\n// let test = () => {\n//\n// };\n//\n// // const _ = require('underscore');\n//\n// // TODO: send this via bus based on options in radio\n// let set_target_notes = () => {\n//     // @ts-ignore\n//     let list_path_device_target = Array.prototype.slice.call(arguments);\n//\n//     // track_target = new li.LiveApiJs(list_path_device_target.slice(0, 3).join(' '));\n//\n//     // let logger = new Logger(env);\n//     //\n//     // logger.log(JSON.stringify(list_path_device_target.slice(0, 3).join(' ')));\n//\n//     let track_target = new li.LiveApiJs(list_path_device_target.slice(0, 3).join(' '));\n//     index_track_target = list_path_device_target[2];\n//\n//     // notes_target = get_notes(list_path_device_target.join(' '));\n//\n//     // let index_track_target = Number(list_path_device_target[2]);\n//\n//     switch(algorithm_train.get_name()) {\n//         case PARSE: {\n//             // let this_device = new li.LiveApiJs('this_device');\n//             //\n//             // let path_this_device = this_device.get_path();\n//             //\n//             // let list_this_device = path_this_device.split(' ');\n//             //\n//             // let this_track = new li.LiveApiJs(list_this_device.slice(0, 3).join(' '));\n//             //\n//             // let num_clipslots = this_track.get(\"clip_slots\").length/2;\n//             //\n//             // let logger = new Logger(env);\n//             //\n//             // for (let i of _.range(0, num_clipslots)) {\n//             // // for (let i of _.range(1, 2)) {\n//             //\n//             //     let path_clip_user = [list_this_device.slice(0, 3).join(' '), 'clip_slots', Number(i), 'clip'].join(' ');\n//             //\n//             //     // let messenger = new Messenger(env, 0);\n//             //     logger.log(path_clip_user);\n//             //\n//             //     let clip_user = new Clip(\n//             //         new ClipDao(\n//             //             new li.LiveApiJs(\n//             //                 path_clip_user\n//             //             ),\n//             //             new Messenger(env, 0),\n//             //             true,\n//             //             'clip_user'\n//             //         )\n//             //     );\n//             //\n//             //     clip_user.set_path_deferlow('set_path_clip_user');\n//             //\n//             //     let path_clip_target = ['live_set', 'tracks', index_track_target, 'clip_slots', Number(i), 'clip'].join(' ');\n//             //\n//             //     logger.log(path_clip_target);\n//             //\n//             //     let clip_target = new Clip(\n//             //         new ClipDao(\n//             //             new LiveApiJs(\n//             //                 path_clip_target\n//             //             ),\n//             //             new Messenger(env, 0)\n//             //         )\n//             //     );\n//             //\n//             //     clip_user.remove_notes(\n//             //         clip_target.get_loop_bracket_lower(),\n//             //         0,\n//             //         clip_target.get_loop_bracket_upper(),\n//             //         128\n//             //     );\n//             //\n//             //     clip_user.set_notes(\n//             //         notes_target.filter(\n//             //             node => node.model.note.beat_start >= clip_target.get_loop_bracket_lower() && node.model.note.get_beat_end() <= clip_target.get_loop_bracket_upper()\n//             //         )\n//             //     )\n//             // }\n//\n//             track_target.set(\"solo\", 0);\n//             break;\n//         }\n//         case DERIVE: {\n//             track_target.set(\"solo\", 0);\n//             break\n//         }\n//         default: {\n//\n//         }\n//     }\n//\n//     messenger_monitor_target.message([list_path_device_target[2]]);\n// };\n//\n// let begin = () => {\n//     // song = new Song(\n//     //     new SongDao(\n//     //         new li.LiveApiJs(\n//     //             'live_set',\n//     //         ),\n//     //         new Messenger(env, 0),\n//     //         false\n//     //     )\n//     // );\n//\n//     let messenger_song = new Messenger(env, 0);\n//\n//     messenger_song.message(['set_path_song', 'live_set']);\n//\n//     let song = {\n//         set_overdub: (int) => {messenger_song.message(['song', 'set', 'overdub', String(int)])},\n//         set_session_record: (int) => {messenger_song.message(['song', 'set', 'session_record', String(int)])},\n//         stop: () => {messenger_song.message(['song', 'set', 'is_playing', String(0)])}\n//     };\n//\n//     trainer = new Trainer(\n//         window,\n//         user_input_handler,\n//         algorithm_train,\n//         clip_user_input,\n//         clip_user_input_synchronous,\n//         index_track_target,\n//         song,\n//         segments_train,\n//         new Messenger(env, 0)\n//     );\n//\n//     trainer.init();\n//\n//     trainer.render_window();\n// };\n//\n// let pause = () => {\n//     trainer.pause()\n// };\n//\n// let resume = () => {\n//     trainer.resume()\n// };\n//\n// let user_input_command = (command: string) => {\n//     let logger = new Logger(env);\n//\n//     // logger.log('user input command....');\n//     // TODO: there is literally one character difference between the two algorithms - please abstract\n//     switch(algorithm_train.get_name()) {\n//         case PARSE: {\n//             switch(command) {\n//                 case 'confirm': {\n//                     let notes = trainer.clip_user_input_synchronous.get_notes(\n//                         trainer.segment_current.beat_start,\n//                         0,\n//                         trainer.segment_current.beat_end - trainer.segment_current.beat_start,\n//                         128\n//                     );\n//\n//                     trainer.accept_input(notes);\n//\n//                     break;\n//                 }\n//                 case 'reset': {\n//                     let coords_current = trainer.iterator_matrix_train.get_coord_current();\n//\n//                     trainer.clip_user_input.set_notes(\n//                         trainer.history_user_input.get(\n//                             [coords_current[0] + 1, coords_current[1]]\n//                         )\n//                     );\n//\n//                     break;\n//                 }\n//                 case 'erase': {\n//                     trainer.clip_user_input.remove_notes(\n//                         trainer.segment_current.beat_start,\n//                         0,\n//                         trainer.segment_current.beat_end - trainer.segment_current.beat_start,\n//                         128\n//                     );\n//                     break;\n//                 }\n//                 default: {\n//                     logger.log('command not recognized')\n//                 }\n//             }\n//             break;\n//         }\n//         case DERIVE: {\n//             switch(command) {\n//                 case 'confirm': {\n//                     let notes = trainer.clip_user_input_synchronous.get_notes(\n//                         trainer.segment_current.beat_start,\n//                         0,\n//                         trainer.segment_current.beat_end - trainer.segment_current.beat_start,\n//                         128\n//                     );\n//\n//                     trainer.accept_input(notes);\n//\n//                     break;\n//                 }\n//                 case 'reset': {\n//                     let coords_current = trainer.iterator_matrix_train.get_coord_current();\n//\n//                     let notes = trainer.history_user_input.get(\n//                         [coords_current[0] - 1, coords_current[1]]\n//                     );\n//\n//                     trainer.clip_user_input.set_notes(\n//                         notes\n//                     );\n//\n//                     break;\n//                 }\n//                 case 'erase': {\n//                     let logger = new Logger(env);\n//\n//                     logger.log(\n//                         JSON.stringify(\n//                             trainer.segment_current\n//                         )\n//                     );\n//\n//                     trainer.clip_user_input.remove_notes(\n//                         trainer.segment_current.beat_start,\n//                         0,\n//                         trainer.segment_current.beat_end - trainer.segment_current.beat_start,\n//                         128\n//                     );\n//                     break;\n//                 }\n//                 default: {\n//                     logger.log('command not recognized')\n//                 }\n//             }\n//             break;\n//         }\n//         default: {\n//             logger.log('command not supported for this type of algorithm')\n//         }\n//     }\n// };\n//\n// let user_input_midi = (pitch: number, velocity: number) => {\n//     switch(algorithm_train.get_name()) {\n//         case DETECT: {\n//             let tree: TreeModel = new TreeModel();\n//             let note = tree.parse(\n//                 {\n//                     id: -1,\n//                     note: new n.Note(\n//                         pitch,\n//                         -Infinity,\n//                         Infinity,\n//                         velocity,\n//                         0\n//                     ),\n//                     children: [\n//\n//                     ]\n//                 }\n//             );\n//             trainer.accept_input(\n//                 [note]\n//             );\n//             break;\n//         }\n//         case PREDICT: {\n//             let tree: TreeModel = new TreeModel();\n//             let note = tree.parse(\n//                 {\n//                     id: -1,\n//                     note: new n.Note(\n//                         pitch,\n//                         -Infinity,\n//                         Infinity,\n//                         velocity,\n//                         0\n//                     ),\n//                     children: [\n//\n//                     ]\n//                 }\n//             );\n//             trainer.accept_input(\n//                 [note]\n//             );\n//             break;\n//         }\n//         default: {\n//             logger.log('command not supported for this type of algorithm')\n//         }\n//     }\n// };\n//\n// let load = () => {\n//\n//     // TODO: logic to determine, from project folder, name of file\n//\n//     let freezer = new TrainFreezer(\n//         env\n//     );\n//\n//     freezer.freeze(\n//         trainer,\n//         '/Users/elliottevers/Documents/DocumentsSymlinked/git-repos.nosync/tk_music_ts/cache/train_detect.json'\n//     );\n// };\n//\n// let save = () => {\n//\n//     // TODO: logic to determine, from project folder, name of file\n//\n//     let config = {\n//         'window': window,\n//         'user_input_handler': user_input_handler,\n//         'algorithm': algorithm_train,\n//         'clip_user_input': trainer.clip_user_input,\n//         'clip_user_input_synchronous': trainer.clip_user_input_synchronous,\n//         'index_track_target': index_track_target,\n//         'song': song,\n//         'segments': segments_train,\n//         'messenger': messenger_render,\n//         'env': env\n//     };\n//\n//     let thawer = new TrainThawer(\n//         env\n//     );\n//\n//     let train_thawed = thawer.thaw(\n//         '/Users/elliottevers/Documents/DocumentsSymlinked/git-repos.nosync/tk_music_ts/cache/train_detect.json',\n//         config\n//     );\n//\n//     train_thawed.render_window(\n//\n//     );\n// };\n//\n// if (typeof Global !== \"undefined\") {\n//     Global.train = {};\n//     Global.train.load = load;\n//     Global.train.save = save;\n//     Global.train.begin = begin;\n//     Global.train.pause = pause;\n//     Global.train.resume = resume;\n//     Global.train.user_input_command = user_input_command;\n//     Global.train.user_input_midi = user_input_midi;\n//     Global.train.set_segments = set_segments;\n//     Global.train.set_clip_user_input = set_clip_user_input;\n//     Global.train.set_target_notes = set_target_notes;\n//     Global.train.set_depth_tree = set_depth_tree;\n//     Global.train.set_algorithm_train = set_algorithm_train;\n//     Global.train.set_mode_control = set_mode_control;\n//     Global.train.set_mode_texture = set_mode_texture;\n// }\n"]}