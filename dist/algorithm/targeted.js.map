{"version":3,"file":"targeted.js","sourceRoot":"","sources":["../../src/algorithm/targeted.ts"],"names":[],"mappings":"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","sourcesContent":["import {note as n, note} from \"../note/note\";\nimport {history} from \"../history/history\";\nimport {iterate} from \"../train/iterate\";\nimport {segment} from \"../segment/segment\";\nimport {track} from \"../track/track\";\nimport {target} from \"../target/target\";\nimport {utils} from \"../utils/utils\";\nimport {message} from \"../message/messenger\";\nimport {window} from \"../render/window\";\nimport {user_input} from \"../control/user_input\";\nimport {trainer} from \"../train/trainer\";\nimport {scene} from \"../scene/scene\";\nimport {song} from \"../song/song\";\nimport {trainable} from \"./trainable\";\nimport TreeModel = require(\"tree-model\");\nimport {log} from \"../log/logger\";\n\nexport namespace targeted {\n\n    // logic common to detect and predict\n    import Targetable = trainable.Targetable;\n    import Trainable = trainable.Trainable;\n    import UserInputHandler = user_input.UserInputHandler;\n    import StructTrain = trainer.StructTrain;\n    import Song = song.Song;\n    import TargetIterator = target.TargetIterator;\n    import FactoryMatrixObjectives = iterate.FactoryMatrixObjectives;\n    import StructTargets = trainer.StructTargets;\n    import Note = note.Note;\n    import Subtarget = target.Subtarget;\n    import HistoryUserInput = history.HistoryUserInput;\n    import Scene = scene.Scene;\n    import TypeSequenceTarget = history.TypeSequenceTarget;\n    import Segment = segment.Segment;\n    import MatrixWindow = window.MatrixWindow;\n    import Logger = log.Logger;\n\n    export abstract class Targeted implements Targetable {\n\n        update_history_user_input(\n            input_postprocessed: TreeModel.Node<note.Note>[],\n            history_user_input: history.HistoryUserInput,\n            iterator_matrix_train: iterate.MatrixIterator,\n            trainable: Trainable\n        ): history.HistoryUserInput {\n            history_user_input.concat(\n                input_postprocessed,\n                trainable.coord_to_index_history_user_input(\n                    iterator_matrix_train.get_coord_current()\n                )\n            );\n            return history_user_input\n        }\n\n        public b_parsed: boolean = false;\n        public b_targeted: boolean = true;\n        public depth: number;\n\n        public abstract get_name()\n\n        public abstract initialize_tracks(\n            segments: segment.Segment[],\n            track_target: track.Track,\n            track_user_input: track.Track,\n            struct_train: StructTrain\n        )\n\n        public abstract determine_targets(user_input_handler: UserInputHandler, notes_segment_next: TreeModel.Node<n.Note>[]): TypeSequenceTarget\n\n        public get_num_layers_input(): number {\n            return 1\n        }\n\n        public determine_region_present(notes_target_next: TreeModel.Node<Note>[], segment_current: Segment): number[] {\n            return [\n                notes_target_next[0].model.note.beat_start,\n                notes_target_next[0].model.note.get_beat_end()\n            ]\n        }\n\n        get_notes_in_region(target: target.Target, segment: segment.Segment) {\n            return target.iterator_subtarget.subtargets.map((subtarget) => {\n                return subtarget.note\n            })\n        }\n\n        public abstract initialize_render(\n            window: MatrixWindow,\n            segments: Segment[],\n            notes_target_track: TreeModel.Node<Note>[],\n            struct_train: StructTrain\n        ): MatrixWindow\n\n        unpause(song: Song, scene_current: Scene) {\n            // not forcing legato so that it starts immediately\n            scene_current.fire(false);\n            song.set_session_record(1);\n            song.set_overdub(1);\n        }\n\n        postprocess_user_input(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current: target.Subtarget): TreeModel.Node<note.Note>[] {\n            return [subtarget_current.note];\n        }\n\n        public abstract postprocess_subtarget(subtarget: Subtarget)\n\n        // TODO: verify that we don't need to do anything\n        terminate(struct_train: StructTrain, segments: Segment[]) {\n            return\n        }\n\n        pause(song: Song, scene_current: Scene) {\n            song.stop()\n        }\n\n        warrants_advance(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current): boolean {\n            return utils.remainder(notes_user_input[0].model.note.pitch, 12) === utils.remainder(subtarget_current.note.model.note.pitch, 12)\n        }\n\n        preprocess_struct_train(struct_train: StructTrain, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]): StructTrain {\n            return this.preprocess_struct_targets(struct_train as StructTargets, segments, notes_target_track) as StructTrain\n        }\n\n        preprocess_struct_targets(struct_targets: StructTargets, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]): StructTargets {\n            return struct_targets\n        }\n\n        public create_matrix_targets(user_input_handler: UserInputHandler, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]): TargetIterator[][] {\n\n            let matrix_targets = FactoryMatrixObjectives.create_matrix_targets(\n                this,\n                segments\n            );\n\n            // let logger = new Logger('max');\n            //\n            // logger.log(JSON.stringify(notes_target_track));\n\n            for (let i_segment in segments) {\n                let segment = segments[Number(i_segment)];\n\n                let notes_in_segment = notes_target_track.filter(\n                    node => node.model.note.beat_start >= segment.get_endpoints_loop()[0] && node.model.note.get_beat_end() <= segment.get_endpoints_loop()[1]\n                );\n\n                let sequence_targets = this.determine_targets(\n                    user_input_handler,\n                    notes_in_segment\n                );\n\n                matrix_targets[0][Number(i_segment)] = TargetIterator.from_sequence_target(sequence_targets);\n            }\n\n            return matrix_targets\n        }\n\n        private static stream_subtarget_bounds(messenger: message.Messenger, subtarget_current: Subtarget, segment_current: Segment, segments: Segment[]) {\n            let duration_training_data = segments[segments.length - 1].beat_end;\n            messenger.message(['duration_training_data', duration_training_data], true);\n\n            messenger.message(\n                [\n                    'bounds',\n                    subtarget_current.note.model.note.beat_start/duration_training_data,\n                    subtarget_current.note.model.note.get_beat_end()/duration_training_data\n                ],\n                true\n            )\n        }\n\n        stream_bounds(\n            messenger: message.Messenger,\n            subtarget_current: Subtarget,\n            segment_current: Segment,\n            segments: Segment[]\n        ): void {\n            Targeted.stream_subtarget_bounds(messenger, subtarget_current, segment_current, segments)\n        }\n\n        update_struct(notes_input_user: TreeModel.Node<note.Note>[], struct_train: StructTrain, trainable: Trainable, iterator_matrix_train: iterate.MatrixIterator): StructTrain {\n            return struct_train;\n        }\n\n        create_struct_train(window: window.MatrixWindow, segments: segment.Segment[], track_target: track.Track, user_input_handler: user_input.UserInputHandler, struct_train: trainer.StructTrain): trainer.StructTrain {\n            let notes_target_track = track_target.get_notes();\n            return this.create_matrix_targets(user_input_handler, segments, notes_target_track);\n        }\n\n        set_depth(): void {\n\n        }\n\n        advance_scene(scene_current: scene.Scene, song: song.Song) {\n            scene_current.fire(true);\n        }\n\n        preprocess_history_user_input(history_user_input: history.HistoryUserInput, segments: segment.Segment[]): HistoryUserInput {\n            return history_user_input\n        }\n\n        get_num_layers_clips_to_render(): number {\n            return 1;\n        }\n\n        coord_to_index_clip_render(coord: number[]): number {\n            return 0;\n        }\n\n        coord_to_index_history_user_input(coord: number[]): number[] {\n            return coord;\n        }\n\n        coord_to_index_struct_train(coord: number[]): number[] {\n            return coord;\n        }\n    }\n\n}"]}