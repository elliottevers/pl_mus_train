{"version":3,"file":"parsed.js","sourceRoot":"","sources":["../../src/algorithm/parsed.ts"],"names":[],"mappings":"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","sourcesContent":["import {segment} from \"../segment/segment\";\nimport {track} from \"../track/track\";\nimport {parse} from \"../parse/parse\";\nimport {target} from \"../target/target\";\nimport {note} from \"../note/note\";\nimport {message} from \"../message/messenger\";\nimport {window} from \"../render/window\";\nimport {user_input} from \"../control/user_input\";\nimport {trainer} from \"../train/trainer\";\nimport {scene} from \"../scene/scene\";\nimport {song} from \"../song/song\";\nimport {history} from \"../history/history\";\nimport {trainable} from \"./trainable\";\nimport {iterate} from \"../train/iterate\";\nimport TreeModel = require(\"tree-model\");\n\nexport namespace parsed {\n\n    // logic common to parse and derive\n    import Parsable = trainable.Parsable;\n    import Scene = scene.Scene;\n    import Segment = segment.Segment;\n    import Song = song.Song;\n    import StructTrain = trainer.StructTrain;\n    import FactoryMatrixObjectives = iterate.FactoryMatrixObjectives;\n    import MatrixIterator = iterate.MatrixIterator;\n    import Note = note.Note;\n    import HistoryUserInput = history.HistoryUserInput;\n    import Trainable = trainable.Trainable;\n    import StructParse = parse.StructParse;\n    import MatrixWindow = window.MatrixWindow;\n    import Messenger = message.Messenger;\n\n    export abstract class Parsed implements Parsable {\n\n        public b_parsed: boolean = true;\n\n        public b_targeted: boolean = false;\n\n        public abstract get_name();\n\n        depth: number;\n\n        update_struct(notes_input_user: TreeModel.Node<Note>[], struct_train: StructTrain, trainable: Trainable, iterator_matrix_train: MatrixIterator): StructTrain {\n\n            let struct_parse = struct_train as StructParse;\n\n            struct_parse.add(\n                notes_input_user,\n                // iterator_matrix_train.get_coord_current(),\n                trainable.coord_to_index_struct_train(\n                    iterator_matrix_train.get_coord_current()\n                ),\n                trainable as Parsable\n            );\n\n            return struct_parse\n        }\n\n        public abstract initialize_render(\n            window: MatrixWindow,\n            segments: Segment[],\n            notes_track_target: TreeModel.Node<Note>[],\n            struct_train: StructTrain\n        ): MatrixWindow\n\n        public abstract initialize_tracks(\n            segments: segment.Segment[],\n            track_target: track.Track,\n            track_user_input: track.Track,\n            struct_train: StructTrain\n        )\n\n        public update_history_user_input(\n            input_postprocessed: TreeModel.Node<Note>[],\n            history_user_input: HistoryUserInput,\n            iterator_matrix_train: MatrixIterator,\n            trainable: Trainable\n        ): HistoryUserInput {\n\n            history_user_input.concat(\n                input_postprocessed,\n                trainable.coord_to_index_history_user_input(\n                    iterator_matrix_train.get_coord_current()\n                )\n            );\n\n            return history_user_input\n        }\n\n        public abstract get_num_layers_input(): number\n\n        set_depth(depth: number) {\n            this.depth = depth;\n        }\n\n        coord_to_index_clip_render(coord: number[]): number {\n            if (coord[0] === -1) {\n                return 0\n            } else {\n                return coord[0] + 1\n            }\n        }\n\n        create_struct_parse(segments: Segment[]): StructParse {\n            return new StructParse(\n                FactoryMatrixObjectives.create_matrix_parse(\n                    this,\n                    segments\n                )\n            )\n        }\n\n        determine_region_present(notes_target_next: TreeModel.Node<Note>[], segment_current: Segment): number[] {\n            return [\n                segment_current.beat_start,\n                segment_current.beat_end\n            ]\n        }\n\n        finish_parse(struct_parse: parse.StructParse, segments: segment.Segment[]): void {\n        }\n\n        public abstract get_coords_notes_to_grow(coords_note_input_current): number[][]\n\n        get_notes_in_region(target: target.Target, segment: segment.Segment) {\n            return [segment.get_note()]\n        }\n\n        public abstract grow_layer(notes_user_input_renderable, notes_to_grow)\n\n\n        preprocess_struct_train(struct_train: StructTrain, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]): StructTrain {\n            return this.preprocess_struct_parse(struct_train as StructParse, segments, notes_target_track)\n        }\n\n        public abstract preprocess_struct_parse(struct_parse, segments, track_target)\n\n        pause(song: Song, scene_current: Scene) {\n\n            song.set_overdub(0);\n\n            song.set_session_record(0);\n\n            song.stop()\n        }\n\n        postprocess_user_input(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current: target.Subtarget): TreeModel.Node<note.Note>[] {\n            return notes_user_input;\n        }\n\n        stream_bounds(\n            messenger: message.Messenger,\n            subtarget_current: target.Subtarget,\n            segment_current: segment.Segment,\n            segments: Segment[]\n        ): void {\n            Parsed.stream_segment_bounds(messenger, subtarget_current, segment_current, segments)\n        }\n\n        private static stream_segment_bounds(\n            messenger: message.Messenger,\n            subtarget_current: target.Subtarget,\n            segment_current: segment.Segment,\n            segments: Segment[]\n        ) {\n            messenger.message(['duration_training_data', segments[segments.length - 1].beat_end], true);\n            messenger.message(['bounds', 0, 1], true)\n        }\n\n        terminate(struct_train: StructTrain, segments: Segment[]) {\n            this.finish_parse(struct_train as StructParse, segments)\n        }\n\n        unpause(song: Song, scene_current: Scene) {\n            scene_current.fire(false);\n\n            song.set_overdub(1);\n\n            song.set_session_record(1);\n        }\n\n        public abstract update_roots(coords_roots_previous: number[][], coords_notes_to_grow: number[][], coord_notes_current: number[])\n\n        warrants_advance(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current: target.Subtarget): boolean {\n            return true;\n        }\n\n        create_struct_train(window: window.MatrixWindow, segments: segment.Segment[], track_target: track.Track, user_input_handler: user_input.UserInputHandler, struct_train: trainer.StructTrain): trainer.StructTrain {\n            return this.create_struct_parse(segments);\n        }\n\n        advance_scene(scene_current: scene.Scene, song: song.Song) {\n            scene_current.fire(true);\n\n            song.set_overdub(1);\n\n            song.set_session_record(1);\n        }\n\n        preprocess_history_user_input(history_user_input: history.HistoryUserInput, segments: segment.Segment[]): HistoryUserInput {\n            return history_user_input\n        }\n\n        public abstract get_num_layers_clips_to_render(): number\n\n        // we skip over the segments layer\n        coord_to_index_history_user_input(coord: number[]): number[] {\n            return [coord[0] - 1, coord[1]];\n        }\n\n        // the root is not included in iteration\n        coord_to_index_struct_train(coord: number[]): number[] {\n            // return [coord[0] - 1, coord[1]];\n            return coord\n        }\n    }\n\n}"]}