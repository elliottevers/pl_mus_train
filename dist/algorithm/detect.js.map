{"version":3,"file":"detect.js","sourceRoot":"","sources":["../../src/algorithm/detect.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAIA,uCAAoC;AAGpC,4CAAyC;AACzC,oDAAqD;AAGrD,yCAAsC;AAGtC,IAAiB,MAAM,CAgFtB;AAhFD,WAAiB,MAAM;IAEnB,IAAO,QAAQ,GAAG,mBAAQ,CAAC,QAAQ,CAAC;IAGpC,IAAO,OAAO,GAAG,iBAAO,CAAC,OAAO,CAAC;IACjC,IAAO,SAAS,GAAG,yBAAa,CAAC,SAAS,CAAC;IAG3C,IAAO,SAAS,GAAG,yBAAa,CAAC,SAAS,CAAC;IAC3C,IAAO,MAAM,GAAG,qBAAS,CAAC,MAAM,CAAC;IAGjC;QAA4B,0BAAQ;QAEhC;mBACI,iBAAO;QACX,CAAC;QAED,kCAAiB,GAAjB,UAAkB,kBAAoC,EAAE,kBAA4C;YAChG,IAAI,kBAAkB,CAAC,YAAY,KAAK,SAAS,EAAE;gBAE/C,IAAI,cAAc,GAA+B,OAAO,CAAC,KAAK,CAC1D,kBAAkB,CACrB,CAAC;gBAEF,IAAI,oBAAoB,GAAuB,EAAE,CAAC;gBAElD,KAAuB,UAAc,EAAd,iCAAc,EAAd,4BAAc,EAAd,IAAc,EAAE;oBAAlC,IAAI,UAAU,uBAAA;oBACf,oBAAoB,CAAC,IAAI,CACrB,OAAO,CAAC,WAAW,CACf,UAAU,CACb,CACJ,CAAC;iBACL;gBAED,OAAO,oBAAoB,CAAA;aAE9B;iBAAM,IAAI,kBAAkB,CAAC,YAAY,KAAK,SAAS,EAAE;gBAEtD,IAAI,qBAAqB,GAAuB,EAAE,CAAC;gBAEnD,KAAiB,UAAkB,EAAlB,yCAAkB,EAAlB,gCAAkB,EAAlB,IAAkB,EAAE;oBAAhC,IAAI,MAAI,2BAAA;oBACT,qBAAqB,CAAC,IAAI,CAAC,CAAC,MAAI,CAAC,CAAC,CAAA;iBACrC;gBACD,OAAO,qBAAqB,CAAA;aAE/B;iBAAM;gBACH,MAAM,CAAC,cAAc,EAAE,kBAAkB,CAAC,YAAY,EAAE,eAAe,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;aACrF;QACL,CAAC;QAEM,yBAAQ,GAAf;YACI,OAAO,MAAM,CAAA;QACjB,CAAC;QAED,sCAAqB,GAArB,UAAsB,cAAc;YAChC,OAAO,cAAc,CAAA;QACzB,CAAC;QAED,sDAAsD;QACtD,kCAAiB,GAAjB,UACI,MAA2B,EAC3B,QAA2B,EAC3B,kBAA+C,EAC/C,YAAyB;YAEzB,OAAO,MAAM,CAAA;QACjB,CAAC;QAED,kCAAiB,GAAjB,UACI,QAA2B,EAC3B,YAAyB,EACzB,gBAA6B,EAC7B,YAAyB;YAEzB,OAAM;QACV,CAAC;QACL,aAAC;IAAD,CAAC,AAjED,CAA4B,QAAQ,GAiEnC;IAjEY,aAAM,SAiElB,CAAA;AAEL,CAAC,EAhFgB,MAAM,GAAN,cAAM,KAAN,cAAM,QAgFtB","sourcesContent":["import {note, note as n} from \"../note/note\";\nimport {window} from \"../render/window\";\nimport {segment} from \"../segment/segment\";\nimport {track} from \"../track/track\";\nimport {targeted} from \"./targeted\";\nimport {user_input} from \"../control/user_input\";\nimport {trainer} from \"../train/trainer\";\nimport {harmony} from \"../music/harmony\";\nimport {modes_texture} from \"../constants/constants\";\nimport {history} from \"../history/history\";\nimport TreeModel = require(\"tree-model\");\nimport {trainable} from \"./trainable\";\nimport {message} from \"../message/messenger\";\n\nexport namespace detect {\n\n    import Targeted = targeted.Targeted;\n    import UserInputHandler = user_input.UserInputHandler;\n    import StructTrain = trainer.StructTrain;\n    import Harmony = harmony.Harmony;\n    import POLYPHONY = modes_texture.POLYPHONY;\n    import TypeSequenceTarget = history.TypeSequenceTarget;\n    import MatrixWindow = window.MatrixWindow;\n    import MONOPHONY = modes_texture.MONOPHONY;\n    import DETECT = trainable.DETECT;\n    import Messenger = message.Messenger;\n\n    export class Detect extends Targeted {\n\n        constructor() {\n            super();\n        }\n\n        determine_targets(user_input_handler: UserInputHandler, notes_segment_next: TreeModel.Node<n.Note>[]): TypeSequenceTarget {\n            if (user_input_handler.mode_texture === POLYPHONY) {\n\n                let chords_grouped: TreeModel.Node<n.Note>[][] = Harmony.group(\n                    notes_segment_next\n                );\n\n                let chords_monophonified: TypeSequenceTarget = [];\n\n                for (let note_group of chords_grouped) {\n                    chords_monophonified.push(\n                        Harmony.monophonify(\n                            note_group\n                        )\n                    );\n                }\n\n                return chords_monophonified\n\n            } else if (user_input_handler.mode_texture === MONOPHONY) {\n\n                let notes_grouped_trivial: TypeSequenceTarget = [];\n\n                for (let note of notes_segment_next) {\n                    notes_grouped_trivial.push([note])\n                }\n                return notes_grouped_trivial\n\n            } else {\n                throw ['texture mode', user_input_handler.mode_texture, 'not supported'].join(' ')\n            }\n        }\n\n        public get_name(): string {\n            return DETECT\n        }\n\n        postprocess_subtarget(note_subtarget) {\n            return note_subtarget\n        }\n\n        // TODO: verify that we don't have to do anything here\n        initialize_render(\n            window: window.MatrixWindow,\n            segments: segment.Segment[],\n            notes_target_track: TreeModel.Node<note.Note>[],\n            struct_train: StructTrain\n        ): MatrixWindow {\n            return window\n        }\n\n        initialize_tracks(\n            segments: segment.Segment[],\n            track_target: track.Track,\n            track_user_input: track.Track,\n            struct_train: StructTrain\n        ) {\n            return\n        }\n    }\n\n}"]}