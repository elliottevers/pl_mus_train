{"version":3,"file":"trainable.js","sourceRoot":"","sources":["../../src/algorithm/trainable.ts"],"names":[],"mappings":";;AAeA,IAAiB,SAAS,CAsJzB;AAtJD,WAAiB,WAAS;IAgBX,kBAAM,GAAG,QAAQ,CAAC;IAClB,mBAAO,GAAG,SAAS,CAAC;IACpB,iBAAK,GAAG,OAAO,CAAC;IAChB,kBAAM,GAAG,QAAQ,CAAC;IAClB,qBAAS,GAAG,WAAW,CAAC;AAkIvC,CAAC,EAtJgB,SAAS,GAAT,iBAAS,KAAT,iBAAS,QAsJzB","sourcesContent":["import {message} from \"../message/messenger\";\nimport {segment} from \"../segment/segment\";\nimport {track} from \"../track/track\";\nimport {note} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {target} from \"../target/target\";\nimport {window} from \"../render/window\";\nimport {trainer} from \"../train/trainer\";\nimport {user_input} from \"../control/user_input\";\nimport {song} from \"../song/song\";\nimport {iterate} from \"../train/iterate\";\nimport {history} from \"../history/history\";\nimport {scene} from \"../scene/scene\";\nimport {parse} from \"../parse/parse\";\n\nexport namespace trainable {\n    import Note = note.Note;\n    import Segment = segment.Segment;\n    import Subtarget = target.Subtarget;\n    import MatrixWindow = window.MatrixWindow;\n    import StructTrain = trainer.StructTrain;\n    import UserInputHandler = user_input.UserInputHandler;\n    import Target = target.Target;\n    import Song = song.Song;\n    import MatrixIterator = iterate.MatrixIterator;\n    import HistoryUserInput = history.HistoryUserInput;\n    import Scene = scene.Scene;\n    import Track = track.Track;\n    import StructParse = parse.StructParse;\n    import Messenger = message.Messenger;\n\n    export let DETECT = 'detect';\n    export let PREDICT = 'predict';\n    export let PARSE = 'parse';\n    export let DERIVE = 'derive';\n    export let FREESTYLE = 'freestyle';\n\n    interface Temporal {\n        determine_region_present(\n            notes_next: TreeModel.Node<Note>[],\n            segment_current: Segment\n        )\n\n        stream_bounds(\n            messenger: message.Messenger,\n            subtarget_current: Subtarget,\n            segment_current: Segment,\n            segments: Segment[]\n        ): void\n    }\n\n    interface Renderable {\n        initialize_render(\n            window: MatrixWindow,\n            segments: Segment[],\n            notes_track_target: TreeModel.Node<Note>[],\n            struct_train: StructTrain\n        ): MatrixWindow\n\n        get_notes_in_region(\n            target: Target,\n            segment: Segment\n        ): TreeModel.Node<Note>[]\n    }\n\n    // interface that the trainer uses\n    export interface Trainable extends Temporal, Renderable {\n        depth: number;\n        b_parsed: boolean;\n        b_targeted: boolean;\n\n        get_name(): string\n        get_num_layers_input(): number\n        get_num_layers_clips_to_render(): number\n        set_depth(depth: number): void\n        coord_to_index_clip_render(coord: number[]): number\n        coord_to_index_history_user_input(coord: number[]): number[]\n        coord_to_index_struct_train(coord: number[]): number[]\n\n        preprocess_history_user_input(\n            history_user_input: HistoryUserInput,\n            segments: Segment[]\n        ): HistoryUserInput\n\n        create_struct_train(\n            window: MatrixWindow,\n            segments: Segment[],\n            track_target: Track,\n            user_input_handler: UserInputHandler,\n            struct_train: StructTrain\n        ): StructTrain\n\n        terminate(\n            struct_train: StructTrain,\n            segments: Segment[]\n        )\n\n        advance_scene(\n            scene_current: Scene,\n            song: Song\n        )\n\n        unpause(\n            song: Song,\n            scene_current: Scene\n        )\n\n        pause(\n            song: Song,\n            scene_current: Scene\n        )\n\n        preprocess_struct_train(\n            struct_train: StructTrain,\n            segments: Segment[],\n            notes_target_track: TreeModel.Node<Note>[]\n        ): StructTrain\n\n        update_struct(\n            notes_input_user: TreeModel.Node<Note>[],\n            struct_train: StructTrain,\n            trainable: Trainable,\n            iterator_matrix_train: MatrixIterator\n        ): StructTrain\n\n        initialize_tracks(\n            segments: segment.Segment[],\n            track_target: track.Track,\n            track_user_input: track.Track,\n            // matrix_target: TargetIterator[][]\n            struct_train: StructTrain\n        )\n\n        update_history_user_input(\n            input_postprocessed: TreeModel.Node<Note>[],\n            history_user_input: HistoryUserInput,\n            iterator_matrix_train: MatrixIterator,\n            trainable: Trainable\n        ): HistoryUserInput\n\n        warrants_advance(\n            notes_user_input: TreeModel.Node<Note>[],\n            subtarget_current: Subtarget\n        ): boolean\n\n        postprocess_user_input(\n            notes_user_input: TreeModel.Node<Note>[],\n            subtarget_current: Subtarget\n        ): TreeModel.Node<Note>[]\n    }\n\n    // interface common to both parse and derive, but have different implementations\n    export interface Parsable extends Trainable {\n        preprocess_struct_parse(struct_parse, segments, track_target)\n        finish_parse(struct_parse: StructParse, segments: Segment[]): void;\n        update_roots(coords_roots_previous: number[][], coords_notes_to_grow: number[][], coord_notes_current: number[])\n        get_coords_notes_to_grow(coords_note_input_current): number[][]\n        grow_layer(notes_user_input_renderable, notes_to_grow)\n    }\n\n    // interface common to both detect and predict, but have different implementations\n    export interface Targetable extends Trainable {\n        determine_targets(user_input_handler: UserInputHandler, notes_in_segment: TreeModel.Node<Note>[])\n        postprocess_subtarget(subtarget: Subtarget)\n    }\n}"]}