{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../src/algorithm/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {segment} from \"../segment/segment\";\nimport {track} from \"../track/track\";\nimport {parsed} from \"./parsed\";\nimport {trainer} from \"../train/trainer\";\nimport {iterate} from \"../train/iterate\";\nimport {note} from \"../note/note\";\nimport {window as module_window} from \"../render/window\";\nimport TreeModel = require(\"tree-model\");\nimport {trainable} from \"./trainable\";\nimport {parse as module_parse} from \"../parse/parse\";\nimport ParseTree = module_parse.ParseTree;\nimport StructParse = module_parse.StructParse;\nimport {message} from \"../message/messenger\";\n\nexport namespace parse {\n    import Parsed = parsed.Parsed;\n    import StructTrain = trainer.StructTrain;\n    import MatrixIterator = iterate.MatrixIterator;\n    import Note = note.Note;\n    import MatrixWindow = module_window.MatrixWindow;\n    import Segment = segment.Segment;\n    import PARSE = trainable.PARSE;\n    import Messenger = message.Messenger;\n\n    export class Parse extends Parsed {\n\n        constructor() {\n            super();\n        }\n\n        public get_name(): string {\n            return PARSE\n        }\n\n        grow_layer(notes_user_input_renderable, notes_to_grow) {\n            ParseTree.add_layer(\n                notes_user_input_renderable,\n                notes_to_grow,\n                -1\n            )\n        }\n\n        // TODO: we don't need the target track - we should 1) transfer all notes over to user input track and 2) mute the track\n        initialize_tracks(\n            segments: segment.Segment[],\n            track_target: track.Track,\n            track_user_input: track.Track,\n            struct_train: StructTrain\n        ) {\n            // transfer notes from target track to user input track\n            for (let i_segment in segments) {\n\n                let clip_target = track_target.get_clip_at_index(Number(i_segment));\n\n                let clip_user_input = track_user_input.get_clip_at_index(Number(i_segment));\n\n                let notes = clip_target.get_notes(\n                    clip_target.get_loop_bracket_lower(),\n                    0,\n                    clip_target.get_loop_bracket_upper(),\n                    128\n                );\n\n                clip_user_input.remove_notes(\n                    clip_target.get_loop_bracket_lower(),\n                    0,\n                    clip_target.get_loop_bracket_upper(),\n                    128\n                );\n\n                clip_user_input.set_notes(\n                    notes\n                )\n            }\n\n            // mute target track\n            track_target.mute()\n        }\n\n        // add the root up to which we're going to parse\n        // add the segments as the layer below\n        // add the leaf notes\n        initialize_render(\n            window: MatrixWindow,\n            segments: Segment[],\n            notes_target_track: TreeModel.Node<Note>[],\n            struct_train: StructTrain\n        ): MatrixWindow {\n            // first layer\n            window.add_note_to_clip_root(\n                StructParse.create_root_from_segments(\n                    segments\n                )\n            );\n\n            // @ts-ignore\n            let struct_parse = struct_train as StructParse;\n\n            struct_parse.regions_renderable.push(\n                [-1]\n            );\n\n            for (let i_segment in segments) {\n\n                let segment = segments[Number(i_segment)];\n\n                let note_segment = segment.get_note();\n\n                let coord_current_virtual_second_layer = [0, Number(i_segment)];\n\n                let notes_leaves = notes_target_track.filter(\n                    node => node.model.note.beat_start >= segment.get_endpoints_loop()[0] && node.model.note.get_beat_end() <= segment.get_endpoints_loop()[1]\n                );\n\n                let coord_current_virtual_leaves = [this.depth - 1, Number(i_segment)];\n\n                // second layer\n                window.add_notes_to_clip(\n                    [note_segment],\n                    this.coord_to_index_clip_render(\n                        coord_current_virtual_second_layer\n                    )\n                );\n\n                struct_parse.regions_renderable.push(\n                    this.coord_to_index_struct_train(\n                        coord_current_virtual_second_layer\n                    )\n                );\n\n                // leaves\n                window.add_notes_to_clip(\n                    notes_leaves,\n                    this.coord_to_index_clip_render(\n                        coord_current_virtual_leaves\n                    )\n                )\n            }\n\n            return window\n        }\n\n        update_roots(coords_roots_previous: number[][], coords_notes_previous: number[][], coord_notes_current: number[]): number[][] {\n            let coords_roots_new = [];\n\n            // remove references to old leaves\n            for (let coord_notes_previous of coords_notes_previous) {\n                coords_roots_new = coords_roots_new.concat(\n                    coords_roots_previous.filter((x) => {\n                        return !(x[0] === coord_notes_previous[0] && x[1] === coord_notes_previous[1])\n                    })\n                );\n            }\n\n            // add references to new leaves\n            coords_roots_new.push(\n                coord_notes_current\n            );\n\n            return coords_roots_new\n        }\n\n        get_coords_notes_to_grow(coord_notes_input_current) {\n            return MatrixIterator.get_coords_below([coord_notes_input_current[0], coord_notes_input_current[1]]);\n        }\n\n        // adding the leaf notes to the actual parse tree\n        // DO NOT set the root or the segments as nodes immediately below that - do that at the end\n        // set the leaf notes as the notes in the target track\n        preprocess_struct_parse(struct_parse: StructParse, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]) {\n            // this is to set the leaves as the notes of the target clip\n\n            for (let i_segment in segments) {\n                let segment = segments[Number(i_segment)];\n\n                let notes = notes_target_track.filter(\n                    node => node.model.note.beat_start >= segment.get_endpoints_loop()[0] && node.model.note.get_beat_end() <= segment.get_endpoints_loop()[1]\n                );\n\n                let coord_parse_current_virtual_leaf = [this.depth - 1, Number(i_segment)];\n\n                struct_parse.add(\n                    notes,\n                    coord_parse_current_virtual_leaf,\n                    this,\n                    true\n                );\n            }\n\n            return struct_parse\n        }\n\n        finish_parse(struct_parse: StructParse, segments: Segment[]): void {\n\n            let coords_to_grow = [];\n\n            // make connections with segments\n            for (let i_segment in segments) {\n                coords_to_grow.push([0, Number(i_segment)]);\n                let segment = segments[Number(i_segment)];\n                struct_parse.add(\n                    [segment.get_note()],\n                    [0, Number(i_segment)],\n                    this\n                );\n            }\n\n            struct_parse.set_root(\n                StructParse.create_root_from_segments(\n                    segments\n                )\n            );\n\n            for (let coord_to_grow of coords_to_grow) {\n\n                let notes_to_grow = struct_parse.get_notes_at_coord(coord_to_grow);\n\n                this.grow_layer(\n                    [struct_parse.get_root()],\n                    notes_to_grow\n                );\n            }\n\n            struct_parse.coords_roots = this.update_roots(\n                struct_parse.coords_roots,\n                coords_to_grow,\n                [-1]\n            );\n        }\n\n        // segments layer and leaves layer don't count\n        get_num_layers_input(): number {\n            return this.depth - 2;\n        }\n\n        get_num_layers_clips_to_render(): number {\n            return this.depth + 1;\n        }\n    }\n}"]}