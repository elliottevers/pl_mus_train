{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../src/parse/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {segment} from \"../segment/segment\";\nimport {note as n, note} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {log} from \"../log/logger\";\nimport {utils} from \"../utils/utils\";\nimport {live} from \"../live/live\";\nimport {clip as c} from \"../clip/clip\";\nimport {algorithm} from \"../train/algorithm\";\nimport {trainer} from \"../train/trainer\";\nimport {iterate} from \"../train/iterate\";\n\nconst _ = require(\"underscore\");\n\n\nexport namespace parse {\n    import LiveClipVirtual = live.LiveClipVirtual;\n    import DETECT = algorithm.DETECT;\n    import PARSE = algorithm.PARSE;\n    import DERIVE = algorithm.DERIVE;\n    import MatrixIterator = iterate.MatrixIterator;\n    // import MatrixIterator = trainer.MatrixIterator;\n\n    export interface Parsable {\n        choose(): boolean;\n\n        // TODO: annotation\n        get_best_candidate(list_candidate_note);\n    }\n\n    abstract class ParseTree {\n        root: TreeModel.Node<n.NoteRenderable>;\n\n        constructor() {\n\n        }\n\n        public get_root(): TreeModel.Node<n.NoteRenderable> {\n            return this.root\n        }\n    }\n\n    export class StructParse extends ParseTree {\n\n        root: TreeModel.Node<n.NoteRenderable>;\n\n        matrix_leaves: TreeModel.Node<n.NoteRenderable>[][][];\n\n        coords_roots: number[][]; // list of coordinates\n\n        constructor(matrix) {\n            super();\n            this.matrix_leaves = matrix;\n        }\n\n        public get_roots_at_coord(coord: number[]) {\n            return this.matrix_leaves[coord[0]][coord[1]]\n        }\n\n        private static get_diff_index_start(notes_new: TreeModel.Node<n.Note>[], notes_old: TreeModel.Node<n.Note>[]): number {\n            let same_start, same_duration, index_start_diff;\n            for (let i=0; i < notes_old.length; i++) {\n                same_start = (notes_old[i].model.note.beat_start === notes_new[i].model.note.beat_start);\n                same_duration = (notes_old[i].model.note.beats_duration === notes_new[i].model.note.beats_duration);\n                if (!(same_start && same_duration)) {\n                    index_start_diff = i;\n                    break;\n                }\n            }\n\n            return index_start_diff;\n        }\n\n        private static get_diff_index_end(notes_new: TreeModel.Node<n.Note>[], notes_old: TreeModel.Node<n.Note>[]): number {\n            let same_start, same_duration, index_end_diff;\n            for (let i=-1; i > -1 * (notes_new.length + 1); i--) {\n                same_start = (notes_new.slice(i)[0].model.note.beat_start === notes_old.slice(i)[0].model.note.beat_start);\n                same_duration = (notes_new.slice(i)[0].model.note.beats_duration === notes_old.slice(i)[0].model.note.beats_duration);\n                if (!(same_start && same_duration)) {\n                    index_end_diff = i;\n                    break;\n                }\n            }\n\n            // NB: add one in order to use with array slice, unless of course the index is -1, then you'll access the front of the array\n            return index_end_diff;\n        }\n\n        // TODO: complete return method signature\n        get_diff_index_notes(notes_parent: TreeModel.Node<n.Note>[], notes_child: TreeModel.Node<n.Note>[]): number[] {\n            return [\n                StructParse.get_diff_index_start(notes_child, notes_parent),\n                StructParse.get_diff_index_end(notes_child, notes_parent)\n            ];\n        };\n\n        public finish() {\n            for (let col of this.matrix_leaves[0]) {\n                for (let notes of col) {\n                    // @ts-ignore\n                    for (let note of notes) {\n                        this.add_layer(\n                            [this.root],\n                            note,\n                            -1\n                        )\n                    }\n                }\n            }\n        }\n\n        public add(notes_user_input, coord_notes_current, algorithm): void {\n\n            let coord_notes_previous;\n            this.matrix_leaves[coord_notes_current[0]][coord_notes_current[1]] = notes_user_input;\n\n            switch (algorithm.get_name()) {\n                case PARSE: {\n                    coord_notes_previous = MatrixIterator.get_coord_above([coord_notes_current[0], coord_notes_current[1]]);\n                    let notes_below = this.matrix_leaves[coord_notes_previous[0]][coord_notes_previous[1]];\n                    let notes_children = notes_below;\n                    this.add_layer(\n                        notes_user_input,\n                        notes_children,\n                        -1\n                    );\n                    break;\n                }\n                case DERIVE: {\n                    coord_notes_previous = MatrixIterator.get_coord_below([coord_notes_current[0], coord_notes_current[1]]);\n                    let notes_above = this.matrix_leaves[coord_notes_previous[0]][coord_notes_previous[1]];\n                    let notes_parent = notes_above;\n                    this.add_layer(\n                        notes_parent,\n                        notes_user_input,\n                        -1\n                    );\n                    break;\n                }\n                default: {\n                    throw 'adding notes to parse tree failed'\n                }\n            }\n\n            // remove references to old leaves\n            this.coords_roots = this.coords_roots.filter((x) => {\n                return !(x[0] === coord_notes_previous[0] && x[1] === coord_notes_previous[1])\n            });\n\n            // add references to new leaves\n            this.coords_roots.push(\n                coord_notes_current\n            )\n        }\n\n        private add_layer(notes_parent: TreeModel.Node<n.Note>[], notes_child: TreeModel.Node<n.Note>[], index_new_layer: number): void {\n\n            var note_parent_best, b_successful;\n\n            for (let node of notes_child) {\n                note_parent_best = node.model.note.get_best_candidate(notes_parent);\n                b_successful = node.model.note.choose();\n                if (b_successful) {\n                    node.model.id = index_new_layer;\n                    note_parent_best.addChild(node);\n                }\n            }\n        };\n        //\n        // private update_leaves(leaves: TreeModel.Node<n.Note>[]) {\n        //     // find leaves in parse/derive beat interval\n        //\n        //     // splice them with their children\n        //     let leaves_spliced = this.leaves;\n        //     let children_to_insert, i_leaf_to_splice;\n        //     for (let leaf of leaves) {\n        //         // find index of leaf to \"splice\"\n        //         // always splice only one leaf\n        //         // find corresponding leaf in leaves_spliced\n        //         children_to_insert = [];\n        //         if (leaf.hasChildren()) {\n        //             i_leaf_to_splice = _.findIndex(leaves_spliced, (leaf_to_splice)=>{\n        //                 // assuming monophony, i.e., no overlap\n        //                 return leaf_to_splice.model.note.beat_start === leaf.model.note.beat_start\n        //             });\n        //\n        //             let beat_end_children_greatest = -Infinity, beat_start_children_least = Infinity;\n        //\n        //             for (let child of leaf.children) {\n        //                 if (child.model.note.get_beat_end() > beat_end_children_greatest) {\n        //                     beat_end_children_greatest = child.model.note.get_beat_end();\n        //                 }\n        //                 if (child.model.note.beat_start < beat_start_children_least) {\n        //                     beat_start_children_least = child.model.note.beat_start;\n        //                 }\n        //                 children_to_insert.push(child);\n        //             }\n        //\n        //             if (false) {\n        //                 // if (leaf.model.note.get_beat_end() > beat_end_children_greatest || leaf.model.note.beat_start < beat_start_children_least) {\n        //                 leaves_spliced.splice(\n        //                     i_leaf_to_splice,\n        //                     0,\n        //                     ...children_to_insert\n        //                 )\n        //             } else {\n        //                 leaves_spliced.splice(\n        //                     i_leaf_to_splice,\n        //                     1,\n        //                     ...children_to_insert\n        //                 )\n        //             }\n        //             // leaves_spliced.splice(\n        //             //     i_leaf_to_splice,\n        //             //     1,\n        //             //     ...children_to_insert\n        //             // )\n        //         }\n        //     }\n        //\n        //     this.leaves = leaves_spliced;\n        // }\n        //\n        // public insert(notes: TreeModel.Node<n.Note>[]) {\n        //     if (this.iterator_tree.get_index_current() == 1) {\n        //         this.set_root(notes[0])\n        //     } else {\n        //         this.grow(\n        //             notes,\n        //             this.iterator_tree.get_breadth_current();\n        //         this.iterator_tree.get_depth_current();\n        //     )\n        //     }\n        // }\n        //\n        // get_notes_leaves(): TreeModel.Node<n.Note>[] {\n        //     return this.leaves;\n        // }\n        //\n        // set_root(note_root: TreeModel.Node<n.Note>) {\n        //     let clip_dao_virtual = new LiveClipVirtual([note_root]);\n        //\n        //     let clip_virtual = new c.Clip(clip_dao_virtual);\n        //\n        //     clip_virtual.clip_dao.beat_start = note_root.model.note.beat_start;\n        //\n        //     clip_virtual.clip_dao.beat_end = note_root.model.note.get_beat_end();\n        //\n        //     this.add_clip(clip_virtual);\n        //\n        //     note_root.model.id = 0;  // index of first clip\n        //\n        //     this.root_parse_tree = note_root;\n        //\n        //     this.leaves = [note_root];\n        // }\n        //\n        // // struct\n        // elaborate(elaboration: TreeModel.Node<n.Note>[], beat_start: number, beat_end: number, index_layer: number): void {\n        //\n        //     if (index_layer + 1 > this.clips.length) {\n        //         let clip_dao_virtual = new LiveClipVirtual(elaboration);\n        //\n        //         clip_dao_virtual.beat_start = elaboration[0].model.note.beat_start;\n        //         clip_dao_virtual.beat_end = elaboration[elaboration.length - 1].model.note.get_beat_end();\n        //\n        //         let clip_virtual = new c.Clip(clip_dao_virtual);\n        //         this.add_clip(clip_virtual);\n        //     } else {\n        //         let clip_last = this.clips[this.clips.length - 1];\n        //         clip_last.clip_dao.beat_end = elaboration[elaboration.length - 1].model.note.get_beat_end();\n        //         clip_last.set_notes(elaboration);\n        //     }\n        //\n        //     let leaves_within_interval = this.get_leaves_within_interval(beat_start, beat_end);\n        //\n        //     if (index_layer == 1) {\n        //         this.add_first_layer(elaboration, this.clips.length - 1)\n        //     } else {\n        //         this.add_layer(leaves_within_interval, elaboration, this.clips.length - 1);\n        //     }\n        //\n        //     this.update_leaves(leaves_within_interval);\n        // }\n        //\n        // // struct\n        // splice_notes(notes_subset: TreeModel.Node<n.Note>[], clip: c.Clip, interval_beats: number[]): TreeModel.Node<n.Note>[] {\n        //     let notes_clip = _.cloneDeep(clip.get_notes_within_loop_brackets());\n        //     let num_notes_to_replace = this.get_order_of_note_at_beat_end(notes_clip, interval_beats[1]) - this.get_order_of_note_at_beat_start(notes_clip, interval_beats[0]) + 1;\n        //     let index_start = this.get_note_index_at_beat(interval_beats[0], notes_clip);\n        //     notes_clip.splice(index_start, num_notes_to_replace, ...notes_subset);\n        //     return notes_clip\n        // }\n        //\n        // // struct\n        // get_note_index_at_beat(beat: number, notes: TreeModel.Node<n.Note>[]): number {\n        //     let val =  _.findIndex(notes, (node)=>{\n        //         return node.model.note.beat_start === beat\n        //     });\n        //     return val;\n        // }\n        //\n        // // struct\n        // get_leaves_within_interval(beat_start: number, beat_end: number): TreeModel.Node<n.Note>[] {\n        //     let val =  this.leaves.filter((node) =>{\n        //         // return node.model.note.beat_start >= beat_start && node.model.note.get_beat_end() <= beat_end\n        //         return (node.model.note.beat_start >= beat_start && node.model.note.beat_start <= beat_end) ||\n        //             (node.model.note.get_beat_end() <= beat_end && node.model.note.get_beat_end() >= beat_start) ||\n        //             (node.model.note.get_beat_end() >= beat_end && node.model.note.beat_start <= beat_start)\n        //\n        //     });\n        //     // this.logger.log(CircularJSON.stringify(this.leaves));\n        //     return val;\n        // }\n\n    }\n}"]}