{"version":3,"file":"window.js","sourceRoot":"","sources":["../../src/render/window.ts"],"names":[],"mappings":"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","sourcesContent":["// import TreeModel = require(\"tree-model\");\n// import {message, message as m} from \"../message/messenger\"\n// import {clip, clip as c} from \"../clip/clip\";\n// import {note, note as n} from \"../note/note\";\n// import {live} from \"../live/live\";\n// import * as _ from \"lodash\";\n// import {segment} from \"../segment/segment\";\n// import {algorithm} from \"../train/algorithm\";\n// import {iterate} from \"../train/iterate\";\n// import {parse} from \"../parse/parse\";\n// import {log} from \"../log/logger\";\n// import {target} from \"../target/target\";\n// import {trainer} from \"../train/trainer\";\n//\n// export namespace window {\n//\n//     import LiveClipVirtual = live.LiveClipVirtual;\n//     import Messenger = message.Messenger;\n//     import Segment = segment.Segment;\n//     import Clip = clip.Clip;\n//     import Algorithm = algorithm.Algorithm;\n//     import MatrixIterator = iterate.MatrixIterator;\n//     import StructParse = parse.StructParse;\n//     import Logger = log.Logger;\n//     import Note = note.Note;\n//     import NoteRenderable = note.NoteRenderable;\n//     import Target = target.Target;\n//     import Trainer = trainer.Trainer;\n//\n//     const red = [255, 0, 0];\n//     const white = [255, 255, 255];\n//     const black = [0, 0, 0];\n//     const region_yellow = [254, 254, 10];\n//     const region_green = [33, 354, 6];\n//     const region_red = [251, 1, 6];\n//     const blue = [10, 10, 251];\n//\n//     interface Temporal {\n//         get_message_render_region_past(interval_current);\n//         get_message_render_region_present(interval_current);\n//         get_message_render_region_future(interval_current);\n//     }\n//\n//     export abstract class Window {\n//         list_clips: Clip[];\n//         height: number;\n//         width: number;\n//         messenger: Messenger;\n//         length_beats: number;\n//         // trainer: Trainer;\n//\n//         protected constructor(height, width, messenger) {\n//             this.height = height;\n//             this.width = width;\n//             this.messenger = messenger;\n//             // this.trainer = trainer;\n//         }\n//\n//         public clear() {\n//             let msg_clear = [\"clear\"];\n//             this.messenger.message(msg_clear);\n//         }\n//\n//         // TODO: put this logic in Algorithm\n//         // public coord_to_index_clip(coord): number {\n//         //     if (this.algorithm.b_targeted()) {\n//         //         return 0\n//         //     } else {\n//         //         if (coord[0] === -1) {\n//         //             return 0\n//         //         } else {\n//         //             return coord[0] + 1\n//         //         }\n//         //     }\n//         // }\n//\n//         public initialize_clips(algorithm: Algorithm, segments: Segment[]) {\n//             let list_clips = [];\n//             let beat_start_song = segments[0].beat_start;\n//             let beat_end_song = segments[segments.length - 1].beat_end;\n//\n//             for (let i in _.range(0, algorithm.get_depth() + 1)) {\n//                 let clip_dao_virtual = new LiveClipVirtual([]);\n//                 clip_dao_virtual.beat_start = beat_start_song;\n//                 clip_dao_virtual.beat_end = beat_end_song;\n//                 let clip_virtual = new c.Clip(clip_dao_virtual);\n//                 list_clips.push(clip_virtual)\n//             }\n//\n//             this.list_clips = list_clips;\n//         }\n//\n//         public set_length_beats(beats) {\n//             this.length_beats = beats;\n//         }\n//\n//         public add_notes_to_clip(notes_to_add_to_clip, coord_current, algorithm) {\n//             let index_clip = algorithm.coord_to_index_clip(coord_current);\n//             for (let note of notes_to_add_to_clip) {\n//                 this.list_clips[index_clip].append(note);\n//             }\n//         }\n//\n//         add_note_to_clip_root(note) {\n//             this.list_clips[0].set_notes(\n//                 [note]\n//             )\n//         }\n//\n//         get_messages_render_clip(index_clip: number) {\n//             let clip_virtual = this.list_clips[index_clip];\n//             let quadruplets = [];\n//             for (let node of clip_virtual.get_notes_within_loop_brackets()) {\n//                 quadruplets.push(this.get_position_quadruplet(node, index_clip));\n//             }\n//             return quadruplets.map(function (tuplet) {\n//                 let message = <any>[\"paintrect\"].concat(tuplet);\n//                 message = message.concat(black);\n//                 return message;\n//             })\n//         };\n//\n//         get_position_quadruplet(node: TreeModel.Node<n.Note>, index_clip: number) {\n//             var dist_from_left_beat_start, dist_from_top_note_top, dist_from_left_beat_end, dist_from_top_note_bottom;\n//\n//             dist_from_left_beat_start = this.get_dist_from_left(node.model.note.beat_start);\n//             dist_from_left_beat_end = this.get_dist_from_left(node.model.note.beat_start + node.model.note.beats_duration);\n//             dist_from_top_note_top = this.get_dist_from_top(node.model.note.pitch, index_clip);\n//             dist_from_top_note_bottom = this.get_dist_from_top(node.model.note.pitch - 1, index_clip);\n//\n//             return [dist_from_left_beat_start, dist_from_top_note_top, dist_from_left_beat_end, dist_from_top_note_bottom]\n//         };\n//\n//         get_dist_from_top(pitch: number, index_clip: number): number {\n//             var clip = this.list_clips[index_clip];\n//             let offset = index_clip;\n//             // TODO: make this configurable\n//             if (false) {\n//                 offset = this.list_clips.length - 1 - index_clip;\n//\n//             }\n//             var dist = (clip.get_pitch_max() - pitch) * this.get_height_note(index_clip);\n//             return dist + (this.get_height_clip() * offset);\n//         };\n//\n//         beat_to_pixel = function (beat: number): number {\n//             let num_pixels_width = this.width;\n//             return beat * (num_pixels_width / this.length_beats);\n//         };\n//\n//         get_dist_from_left(beat: number): number {\n//             return this.beat_to_pixel(beat);\n//         };\n//\n//         get_offset_pixel_leftmost(): number {\n//             return 0;\n//         }\n//\n//         get_offset_pixel_topmost(): number {\n//             return 0;\n//         }\n//\n//         get_offset_pixel_rightmost(): number {\n//             return this.width;\n//         }\n//\n//         get_offset_pixel_bottommost(): number {\n//             return this.height;\n//         }\n//\n//         get_height_clip(): number {\n//             return this.height / this.list_clips.length;\n//         };\n//\n//         get_height_note(index_clip: number): number {\n//             let clip = this.list_clips[index_clip];\n//             let ambitus = clip.get_ambitus();\n//             let dist_pitch = ambitus[1] - ambitus[0] + 1;\n//\n//             // TODO: fix this hack for getting a margin around the note\n//             if (dist_pitch === 1) {\n//                 dist_pitch = 3;\n//             }\n//             return this.get_height_clip() / dist_pitch;\n//         };\n//     }\n//\n//     export class MatrixWindow extends Window implements Temporal {\n//\n//         constructor(height, width, messenger) {\n//             super(height, width, messenger);\n//         }\n//\n//         public render(\n//             iterator_matrix_train: MatrixIterator,\n//             algorithm: Algorithm,\n//             target_current: Target, // only for detect/predict\n//             struct_parse: StructParse // only for parse/derive\n//         ) {\n//\n//             this.clear();\n//\n//             // TODO: compensate for this logic\n//             // if (this.algorithm.b_targeted()) {\n//             //     notes = this.target_current.iterator_subtarget.subtargets.map((subtarget) => {\n//             //         return subtarget.note\n//             //     })\n//             // }\n//             let notes_in_region = algorithm.get_notes_in_region(\n//                 target_current\n//             );\n//\n//             this.render_regions(\n//                 iterator_matrix_train,\n//                 algorithm,\n//                 target_current,\n//                 struct_parse\n//             );\n//\n//             this.render_clips(\n//                 iterator_matrix_train,\n//                 algorithm,\n//                 target_current,\n//                 struct_parse\n//             );\n//\n//             this.render_trees(\n//                 struct_parse\n//             );\n//         }\n//\n//         public render_trees(parse_matrix) {\n//             let messages_render_trees = this.get_messages_render_trees(parse_matrix);\n//             for (let message_tree of messages_render_trees) {\n//                 this.messenger.message(message_tree)\n//             }\n//         }\n//\n//         public get_messages_render_trees(struct_parse: StructParse) {\n//\n//             if (struct_parse === null) {\n//                 return []\n//             }\n//\n//             let color: number[];\n//             let messages: any[] = [];\n//             let message: any[];\n//\n//             for (let coord of struct_parse.coords_roots) {\n//                 let roots_parse_tree;\n//\n//                 // if (coord[0] === -1) {\n//                 //     roots_parse_tree = [struct_parse.get_root()]\n//                 // } else {\n//                 //     roots_parse_tree = struct_parse.get_notes_at_coord(coord);\n//                 // }\n//\n//                 roots_parse_tree = struct_parse.get_notes_at_coord(coord);\n//\n//                 for (let root of roots_parse_tree) {\n//                     root.walk((node)=>{\n//\n//                         if (node.hasChildren()) {\n//\n//                             for (let child of node.children) {\n//\n//                                 message = [\n//                                     \"linesegment\",\n//                                     this.get_centroid(child)[0],\n//                                     this.get_centroid(child)[1],\n//                                     this.get_centroid(node)[0],\n//                                     this.get_centroid(node)[1]\n//                                 ];\n//\n//                                 color = black;\n//\n//                                 messages.push(message.concat(color));\n//\n//                             }\n//                         }\n//\n//                         return true;\n//                     });\n//                 }\n//             }\n//\n//             return messages;\n//         }\n//\n//         get_centroid(node: TreeModel.Node<n.NoteRenderable>): number[] {\n//\n//             let dist_from_left_beat_start, dist_from_left_beat_end, dist_from_top_note_top, dist_from_top_note_bottom;\n//\n//             let coord_clip = node.model.note.get_coordinates_matrix();\n//\n//             let index_clip = this.algorithm.coord_to_index_clip(coord_clip);\n//\n//             // TODO: determine how to get the index of the clip from just depth of the node\n//\n//             dist_from_left_beat_start = this.get_dist_from_left(node.model.note.beat_start);\n//             dist_from_left_beat_end = this.get_dist_from_left(node.model.note.beat_start + node.model.note.beats_duration);\n//             dist_from_top_note_top = this.get_dist_from_top(node.model.note.pitch, index_clip);\n//             dist_from_top_note_bottom = this.get_dist_from_top(node.model.note.pitch - 1, index_clip);\n//\n//             return [\n//                 dist_from_left_beat_end - ((dist_from_left_beat_end - dist_from_left_beat_start) / 2),\n//                 dist_from_top_note_bottom - ((dist_from_top_note_bottom - dist_from_top_note_top) / 2)\n//             ]\n//         };\n//\n//         public render_clips(iterator_matrix_train: MatrixIterator, struct_parse: StructParse) {\n//             let messages_render_clips = this.get_messages_render_clips(iterator_matrix_train, struct_parse);\n//             for (let messages_notes of messages_render_clips) {\n//                 for (let message_note of messages_notes) {\n//                     this.messenger.message(message_note);\n//                 }\n//             }\n//         }\n//\n//         public get_messages_render_clips(iterator_matrix_train, parse_matrix: StructParse): any[][] {\n//             let messages = [];\n//\n//             let b_targeted = (parse_matrix === null);\n//\n//             // make abstraction that gets the renderable regions\n//\n//             algorithm.get_regions_renderable()\n//\n//             for (let coord of algorithm.get_regions_renderable()) {\n//                 messages.push(\n//                     this.get_messages_render_clip(\n//                         algorithm.coord_to_index_clip(\n//                             coord\n//                         )\n//                     )\n//                 )\n//             }\n//\n//             // if (b_targeted) {\n//             //\n//             //     let index_clip = 0;\n//             //\n//             //     messages.push(\n//             //         this.get_messages_render_clip(index_clip)\n//             //     )\n//             // } else {\n//             //     for (let coord of parse_matrix.get_regions_renderable()) {\n//             //         messages.push(\n//             //             this.get_messages_render_clip(\n//             //                 this.algorithm.coord_to_index_clip(\n//             //                     coord\n//             //                 )\n//             //             )\n//             //         )\n//             //     }\n//             // }\n//\n//             return messages\n//         }\n//\n//         public get_message_render_region_past(interval_current) {\n//             let offset_left_start, offset_top_start, offset_left_end, offset_top_end;\n//\n//             offset_left_start = this.get_dist_from_left(this.get_offset_pixel_leftmost());\n//             offset_left_end = this.get_dist_from_left(interval_current[0]);\n//             offset_top_start = this.get_offset_pixel_topmost();\n//             offset_top_end = this.get_offset_pixel_bottommost();\n//\n//             return [offset_left_start, offset_top_start, offset_left_end, offset_top_end]\n//         }\n//\n//         public get_message_render_region_present(interval_current) {\n//             let offset_left_start, offset_top_start, offset_left_end, offset_top_end;\n//\n//             offset_left_start = this.get_dist_from_left(interval_current[0]);\n//             offset_left_end = this.get_dist_from_left(interval_current[1]);\n//             offset_top_start = this.get_offset_pixel_topmost();\n//             offset_top_end = this.get_offset_pixel_bottommost();\n//\n//             return [offset_left_start, offset_top_start, offset_left_end, offset_top_end]\n//         }\n//\n//         public get_message_render_region_future(interval_current) {\n//             let offset_left_start, offset_top_start, offset_left_end, offset_top_end;\n//\n//             offset_left_start = this.get_dist_from_left(interval_current[1]);\n//             offset_left_end = this.get_dist_from_left(this.get_offset_pixel_rightmost());\n//             offset_top_start = this.get_offset_pixel_topmost();\n//             offset_top_end = this.get_offset_pixel_bottommost();\n//\n//             return [offset_left_start, offset_top_start, offset_left_end, offset_top_end]\n//         }\n//\n//         public render_regions(\n//             algorithm: Algorithm,\n//             iterator_matrix_train: MatrixIterator,\n//\n//         ) {\n//\n//             let notes, coord;\n//\n//             let interval_current;\n//\n//             let notes_region_current = algorithm// either segment of target note\n//\n//             interval_current = algorithm.determine_region_present(notes_region_current);\n//\n//             // prediction/detection need the current target, while parse/derive need the current segment\n//             if (algorithm.b_targeted()) {\n//                 interval_current = trainer.algorithm.determine_region_present(\n//                     notes_target_current\n//                 );\n//             } else {\n//                 if (trainer.iterator_matrix_train.done) {\n//                     interval_current = [\n//                         trainer.struct_parse.get_root().model.note.get_beat_end(),\n//                         trainer.struct_parse.get_root().model.note.get_beat_end()\n//                     ]\n//                 } else {\n//                     coord = trainer.iterator_matrix_train.get_coord_current();\n//\n//                     let coord_segment = [0, coord[1]];\n//\n//                     notes = trainer.struct_parse.get_notes_at_coord(coord_segment);\n//\n//                     interval_current = algorithm.determine_region_present(\n//                         notes\n//                     );\n//                 }\n//             }\n//\n//             let quadruplet_region_past = this.get_message_render_region_past(interval_current);\n//             let quadruplet_region_present = this.get_message_render_region_present(interval_current);\n//             let quadruplet_region_future = this.get_message_render_region_future(interval_current);\n//\n//             quadruplet_region_past.unshift('paintrect');\n//             quadruplet_region_past = quadruplet_region_past.concat(region_green);\n//\n//             quadruplet_region_present.unshift('paintrect');\n//             quadruplet_region_present = quadruplet_region_present.concat(region_red);\n//\n//             quadruplet_region_future.unshift('paintrect');\n//             quadruplet_region_future = quadruplet_region_future.concat(region_yellow);\n//\n//             for (let quadruplet of [quadruplet_region_past, quadruplet_region_present, quadruplet_region_future]) {\n//                 this.messenger.message(quadruplet);\n//             }\n//         }\n//     }\n// }"]}