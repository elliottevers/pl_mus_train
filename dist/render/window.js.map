{"version":3,"file":"window.js","sourceRoot":"","sources":["../../src/render/window.ts"],"names":[],"mappings":"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","sourcesContent":["import TreeModel = require(\"tree-model\");\nimport {message, message as m} from \"../message/messenger\"\nimport {clip, clip as c} from \"../clip/clip\";\nimport {note, note as n} from \"../note/note\";\nimport {live} from \"../live/live\";\nimport * as _ from \"lodash\";\nimport {segment as module_segment} from \"../segment/segment\";\nimport {algorithm} from \"../train/algorithm\";\nimport {iterate} from \"../train/iterate\";\nimport {parse} from \"../parse/parse\";\nimport {log} from \"../log/logger\";\nimport {target} from \"../target/target\";\nimport {trainer, trainer as module_trainer} from \"../train/trainer\";\n\nexport namespace window {\n\n    import LiveClipVirtual = live.LiveClipVirtual;\n    import Messenger = message.Messenger;\n    import Segment = module_segment.Segment;\n    import Clip = clip.Clip;\n    // import Algorithm = algorithm.Algorithm;\n    import MatrixIterator = iterate.MatrixIterator;\n    import StructParse = parse.StructParse;\n    import Logger = log.Logger;\n    import Note = note.Note;\n    import NoteRenderable = note.NoteRenderable;\n    import Target = target.Target;\n    import Trainer = module_trainer.Trainer;\n    import Trainable = algorithm.Trainable;\n    import StructTrain = trainer.StructTrain;\n    import StructTargets = trainer.StructTargets;\n\n    const red = [255, 0, 0];\n    const white = [255, 255, 255];\n    const black = [0, 0, 0];\n    const region_yellow = [254, 254, 10];\n    const region_green = [33, 354, 6];\n    const region_red = [251, 1, 6];\n    const blue = [10, 10, 251];\n\n    interface Temporal {\n        get_message_render_region_past(interval_current);\n        get_message_render_region_present(interval_current);\n        get_message_render_region_future(interval_current);\n    }\n\n    export abstract class Window {\n        list_clips: Clip[];\n        height: number;\n        width: number;\n        messenger: Messenger;\n        length_beats: number;\n        // trainer: Trainer;\n\n        protected constructor(height, width, messenger) {\n            this.height = height;\n            this.width = width;\n            this.messenger = messenger;\n            // this.trainer = trainer;\n        }\n\n        public clear() {\n            let msg_clear = [\"clear\"];\n            this.messenger.message(msg_clear);\n        }\n\n        // TODO: put this logic in Algorithm\n        // public coord_to_index_clip(coord): number {\n        //     if (this.algorithm.b_targeted()) {\n        //         return 0\n        //     } else {\n        //         if (coord[0] === -1) {\n        //             return 0\n        //         } else {\n        //             return coord[0] + 1\n        //         }\n        //     }\n        // }\n\n        public initialize_clips(trainable: Trainable, segments: Segment[]) {\n            let list_clips = [];\n            let beat_start_song = segments[0].beat_start;\n            let beat_end_song = segments[segments.length - 1].beat_end;\n\n            for (let i in _.range(0, trainable.get_depth())) {\n                let clip_dao_virtual = new LiveClipVirtual([]);\n                clip_dao_virtual.beat_start = beat_start_song;\n                clip_dao_virtual.beat_end = beat_end_song;\n                let clip_virtual = new c.Clip(clip_dao_virtual);\n                list_clips.push(clip_virtual)\n            }\n\n            this.list_clips = list_clips;\n        }\n\n        public set_length_beats(beats) {\n            this.length_beats = beats;\n        }\n\n        public add_notes_to_clip(notes_to_add_to_clip, coord_current, algorithm) {\n            let index_clip = algorithm.coord_to_index_clip(coord_current);\n            for (let note of notes_to_add_to_clip) {\n                this.list_clips[index_clip].append(note);\n            }\n        }\n\n        add_note_to_clip_root(note) {\n            this.list_clips[0].set_notes(\n                [note]\n            )\n        }\n\n        get_messages_render_clip(index_clip: number) {\n            let clip_virtual = this.list_clips[index_clip];\n            let quadruplets = [];\n            for (let node of clip_virtual.get_notes_within_loop_brackets()) {\n                quadruplets.push(this.get_position_quadruplet(node, index_clip));\n            }\n            return quadruplets.map(function (tuplet) {\n                let message = <any>[\"paintrect\"].concat(tuplet);\n                message = message.concat(black);\n                return message;\n            })\n        };\n\n        get_position_quadruplet(node: TreeModel.Node<n.Note>, index_clip: number) {\n            var dist_from_left_beat_start, dist_from_top_note_top, dist_from_left_beat_end, dist_from_top_note_bottom;\n\n            dist_from_left_beat_start = this.get_dist_from_left(node.model.note.beat_start);\n            dist_from_left_beat_end = this.get_dist_from_left(node.model.note.beat_start + node.model.note.beats_duration);\n            dist_from_top_note_top = this.get_dist_from_top(node.model.note.pitch, index_clip);\n            dist_from_top_note_bottom = this.get_dist_from_top(node.model.note.pitch - 1, index_clip);\n\n            return [dist_from_left_beat_start, dist_from_top_note_top, dist_from_left_beat_end, dist_from_top_note_bottom]\n        };\n\n        get_dist_from_top(pitch: number, index_clip: number): number {\n            var clip = this.list_clips[index_clip];\n            let offset = index_clip;\n            // TODO: make this configurable\n            if (false) {\n                offset = this.list_clips.length - 1 - index_clip;\n\n            }\n            var dist = (clip.get_pitch_max() - pitch) * this.get_height_note(index_clip);\n            return dist + (this.get_height_clip() * offset);\n        };\n\n        beat_to_pixel = function (beat: number): number {\n            let num_pixels_width = this.width;\n            return beat * (num_pixels_width / this.length_beats);\n        };\n\n        get_dist_from_left(beat: number): number {\n            return this.beat_to_pixel(beat);\n        };\n\n        get_offset_pixel_leftmost(): number {\n            return 0;\n        }\n\n        get_offset_pixel_topmost(): number {\n            return 0;\n        }\n\n        get_offset_pixel_rightmost(): number {\n            return this.width;\n        }\n\n        get_offset_pixel_bottommost(): number {\n            return this.height;\n        }\n\n        get_height_clip(): number {\n            return this.height / this.list_clips.length;\n        };\n\n        get_height_note(index_clip: number): number {\n            let clip = this.list_clips[index_clip];\n            let ambitus = clip.get_ambitus();\n            let dist_pitch = ambitus[1] - ambitus[0] + 1;\n\n            // TODO: fix this hack for getting a margin around the note\n            if (dist_pitch === 1) {\n                dist_pitch = 3;\n            }\n            return this.get_height_clip() / dist_pitch;\n        };\n    }\n\n    export class MatrixWindow extends Window implements Temporal {\n\n        constructor(height, width, messenger) {\n            super(height, width, messenger);\n        }\n\n        public render(\n            iterator_matrix_train: MatrixIterator,\n            trainable: Trainable,\n            struct_train: StructTrain,\n            // target_current: Target, // only for detect/predict\n            // struct_parse: StructParse, // only for parse/derive\n            segment_current: Segment\n        ) {\n\n            this.clear();\n\n            // TODO: compensate for this logic\n            // if (this.algorithm.b_targeted()) {\n            //     notes = this.target_current.iterator_subtarget.subtargets.map((subtarget) => {\n            //         return subtarget.note\n            //     })\n            // }\n            // let notes_in_region = trainable.get_notes_in_region(\n            //     target_current,\n            //     segment_current\n            // );\n\n            this.render_regions(\n                iterator_matrix_train,\n                trainable,\n                struct_train,\n                segment_current\n                // target_current,\n                // struct_parse\n            );\n\n            this.render_clips(\n                trainable,\n                struct_train\n                // struct_parse\n            );\n\n            this.render_trees(\n                // struct_parse,\n                struct_train,\n                trainable\n            );\n        }\n\n        public render_trees(struct_train: StructTrain, trainable: Trainable) {\n            let messages_render_trees = this.get_messages_render_trees(struct_train, trainable);\n            for (let message_tree of messages_render_trees) {\n                this.messenger.message(message_tree)\n            }\n        }\n\n        public get_messages_render_trees(struct_train: StructTrain, trainable: Trainable) {\n\n            if (trainable.b_targeted) {\n                return []\n            }\n\n            let struct_parse = struct_train as StructParse;\n\n            let color: number[];\n            let messages: any[] = [];\n            let message: any[];\n\n            for (let coord of struct_parse.coords_roots) {\n\n                let roots_parse_tree;\n\n                roots_parse_tree = struct_parse.get_notes_at_coord(coord);\n\n                for (let root of roots_parse_tree) {\n                    root.walk((node)=>{\n\n                        if (node.hasChildren()) {\n\n                            for (let child of node.children) {\n\n                                message = [\n                                    \"linesegment\",\n                                    this.get_centroid(child, trainable)[0],\n                                    this.get_centroid(child, trainable)[1],\n                                    this.get_centroid(node, trainable)[0],\n                                    this.get_centroid(node, trainable)[1]\n                                ];\n\n                                color = black;\n\n                                messages.push(message.concat(color));\n\n                            }\n                        }\n\n                        return true;\n                    });\n                }\n            }\n\n            return messages;\n        }\n\n        get_centroid(node: TreeModel.Node<n.NoteRenderable>, trainable: Trainable): number[] {\n\n            let dist_from_left_beat_start, dist_from_left_beat_end, dist_from_top_note_top, dist_from_top_note_bottom;\n\n            let coord_clip = node.model.note.get_coordinates_matrix();\n\n            let index_clip = trainable.coord_to_index_clip(coord_clip);\n\n            // TODO: determine how to get the index of the clip from just depth of the node\n\n            dist_from_left_beat_start = this.get_dist_from_left(node.model.note.beat_start);\n            dist_from_left_beat_end = this.get_dist_from_left(node.model.note.beat_start + node.model.note.beats_duration);\n            dist_from_top_note_top = this.get_dist_from_top(node.model.note.pitch, index_clip);\n            dist_from_top_note_bottom = this.get_dist_from_top(node.model.note.pitch - 1, index_clip);\n\n            return [\n                dist_from_left_beat_end - ((dist_from_left_beat_end - dist_from_left_beat_start) / 2),\n                dist_from_top_note_bottom - ((dist_from_top_note_bottom - dist_from_top_note_top) / 2)\n            ]\n        };\n\n        public render_clips(trainable: Trainable, struct_train: StructTrain) {\n            let messages_render_clips = this.get_messages_render_clips(trainable, struct_train);\n            for (let messages_notes of messages_render_clips) {\n                for (let message_note of messages_notes) {\n                    this.messenger.message(message_note);\n                }\n            }\n        }\n\n        public get_messages_render_clips(trainable: Trainable, struct_train: StructTrain): any[][] {\n            let messages = [];\n\n            // let b_targeted = (struct_parse === null);\n\n            // make abstraction that gets the renderable regions\n\n            // struct_parse.get_regions_renderable();\n            //\n            // for (let coord of struct_parse.get_regions_renderable()) {\n            //     messages.push(\n            //         this.get_messages_render_clip(\n            //             trainable.coord_to_index_clip(\n            //                 coord\n            //             )\n            //         )\n            //     )\n            // }\n\n            if (trainable.b_targeted) {\n\n                let index_clip = 0;\n\n                messages.push(\n                    this.get_messages_render_clip(index_clip)\n                )\n            } else {\n\n                let struct_parse = struct_train as StructParse;\n\n                for (let coord of struct_parse.get_regions_renderable()) {\n                    messages.push(\n                        this.get_messages_render_clip(\n                            trainable.coord_to_index_clip(\n                                coord\n                            )\n                        )\n                    )\n                }\n            }\n\n            return messages\n        }\n\n        public get_message_render_region_past(interval_current) {\n            let offset_left_start, offset_top_start, offset_left_end, offset_top_end;\n\n            offset_left_start = this.get_dist_from_left(this.get_offset_pixel_leftmost());\n            offset_left_end = this.get_dist_from_left(interval_current[0]);\n            offset_top_start = this.get_offset_pixel_topmost();\n            offset_top_end = this.get_offset_pixel_bottommost();\n\n            return [offset_left_start, offset_top_start, offset_left_end, offset_top_end]\n        }\n\n        public get_message_render_region_present(interval_current) {\n            let offset_left_start, offset_top_start, offset_left_end, offset_top_end;\n\n            offset_left_start = this.get_dist_from_left(interval_current[0]);\n            offset_left_end = this.get_dist_from_left(interval_current[1]);\n            offset_top_start = this.get_offset_pixel_topmost();\n            offset_top_end = this.get_offset_pixel_bottommost();\n\n            return [offset_left_start, offset_top_start, offset_left_end, offset_top_end]\n        }\n\n        public get_message_render_region_future(interval_current) {\n            let offset_left_start, offset_top_start, offset_left_end, offset_top_end;\n\n            offset_left_start = this.get_dist_from_left(interval_current[1]);\n            offset_left_end = this.get_dist_from_left(this.get_offset_pixel_rightmost());\n            offset_top_start = this.get_offset_pixel_topmost();\n            offset_top_end = this.get_offset_pixel_bottommost();\n\n            return [offset_left_start, offset_top_start, offset_left_end, offset_top_end]\n        }\n\n        public render_regions(\n            iterator_matrix_train: MatrixIterator,\n            trainable: Trainable,\n            // target_current: Target,\n            // struct_parse: StructParse\n            struct_train: StructTrain,\n            segment_current: Segment\n        ) {\n\n            // let notes;\n\n            let coord_current = iterator_matrix_train.get_coord_current();\n\n            let interval_current;\n\n            // prediction/detection need the current target, while parse/derive need the current segment\n            if (trainable.b_targeted) {\n\n                let struct_targets = struct_train as StructTargets;\n\n                let note = struct_targets[coord_current[0]][coord_current[1]].current().iterator_subtarget.current().note;\n\n                // iterator_subtarget.subtargets.\n\n                // let notes_target_current = target_current.get_notes();\n\n                interval_current = trainable.determine_region_present(\n                    [note],\n                    segment_current\n                );\n\n            } else {\n\n                let struct_parse = struct_train as StructParse;\n\n                if (iterator_matrix_train.done) {\n                    interval_current = [\n                        struct_parse.get_root().model.note.beat_start,\n                        struct_parse.get_root().model.note.get_beat_end()\n                    ]\n                } else {\n                    // coord = iterator_matrix_train.get_coord_current();\n\n                    let coord_segment = [0, coord_current[1]];\n\n                    // let notes = struct_parse.get_notes_at_coord(coord_segment);\n\n                    interval_current = trainable.determine_region_present(\n                        struct_parse.get_notes_at_coord(coord_segment),\n                        segment_current\n                    );\n                }\n\n            }\n\n            let quadruplet_region_past = this.get_message_render_region_past(interval_current);\n            let quadruplet_region_present = this.get_message_render_region_present(interval_current);\n            let quadruplet_region_future = this.get_message_render_region_future(interval_current);\n\n            quadruplet_region_past.unshift('paintrect');\n            quadruplet_region_past = quadruplet_region_past.concat(region_green);\n\n            quadruplet_region_present.unshift('paintrect');\n            quadruplet_region_present = quadruplet_region_present.concat(region_red);\n\n            quadruplet_region_future.unshift('paintrect');\n            quadruplet_region_future = quadruplet_region_future.concat(region_yellow);\n\n            for (let quadruplet of [quadruplet_region_past, quadruplet_region_present, quadruplet_region_future]) {\n                this.messenger.message(quadruplet);\n            }\n        }\n    }\n}"]}