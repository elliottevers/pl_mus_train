{"version":3,"file":"iterate.js","sourceRoot":"","sources":["../../src/train/iterate.ts"],"names":[],"mappings":"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","sourcesContent":["// import {algorithm, algorithm as algo} from \"./algorithm\";\n// import {utils} from \"../utils/utils\";\n// import {segment} from \"../segment/segment\";\n//\n// export namespace iterate {\n//     import division_int = utils.division_int;\n//     import remainder = utils.remainder;\n//     import Algorithm = algorithm.Algorithm;\n//     import Segment = segment.Segment;\n//\n//     export class MatrixIterator {\n//\n//         private num_rows: number;\n//         private num_columns: number;\n//\n//         private downward: boolean;\n//         private rightward: boolean;\n//\n//         private index_row_start: number;\n//         private index_row_stop: number;\n//\n//         private i;\n//         private index_start;\n//         private index_stop;\n//\n//         private history: number[];\n//         public done: boolean;\n//         public b_started: boolean;\n//\n//         constructor(num_rows: number, num_columns: number, downward?: boolean, rightward?: boolean, start_at_row?: number, stop_at_row?: number) {\n//             this.num_rows = num_rows;\n//             this.num_columns = num_columns;\n//\n//             this.downward = (downward == null) ? true : downward;\n//             this.rightward = (rightward == null) ? true : rightward;\n//\n//             this.index_row_start = start_at_row;\n//             this.index_row_stop = stop_at_row;\n//\n//             this.determine_index_start();\n//             this.determine_index_stop();\n//\n//             this.i = this.index_start ? this.index_start : -1;\n//             this.history = [];\n//             this.done = false;\n//             this.b_started = false;\n//         }\n//\n//         private determine_index_start() {\n//\n//             let i_start;\n//\n//             if (this.downward && this.rightward) {\n//                 i_start = -1 + (this.num_columns * this.index_row_start)\n//             } else if (!this.downward && this.rightward) {\n//                 i_start = (this.num_columns * (this.index_row_start + 2)) - 1 - this.num_columns\n//             } else if (this.downward && !this.rightward) {\n//                 throw 'not yet supported'\n//             }\n//             else if (!this.downward && !this.rightward) {\n//                 throw 'not yet supported'\n//             }\n//             else {\n//                 throw 'not yet supported'\n//             }\n//\n//             this.index_start = i_start;\n//         }\n//\n//         private determine_index_stop() {\n//\n//             let i_stop;\n//\n//             if (this.downward && this.rightward) {\n//                 i_stop = this.index_row_stop * this.num_columns\n//             } else if (!this.downward && this.rightward) {\n//                 i_stop = (this.index_row_stop - 1) * this.num_columns\n//             } else if (this.downward && !this.rightward) {\n//                 throw 'not yet supported'\n//             }\n//             else if (!this.downward && !this.rightward) {\n//                 throw 'not yet supported'\n//             }\n//             else {\n//                 throw 'not yet supported'\n//             }\n//\n//             this.index_stop = i_stop;\n//         }\n//\n//         private next_column() {\n//             if (this.downward && this.rightward) {\n//                 this.i++;\n//             } else if (!this.downward && this.rightward) {\n//                 if (remainder(this.i + 1, this.num_columns) === 0) {\n//                     this.i = this.i - (this.num_columns - 1) - this.num_columns\n//                 } else {\n//                     this.i++\n//                 }\n//             } else if (this.downward && !this.rightward) {\n//                 // if (remainder(this.i + 1, this.num_rows) === 0) {\n//                 //     this.i = this.i + (this.num_columns - 1) + this.num_columns\n//                 // } else {\n//                 //     this.i--\n//                 // }\n//                 throw 'not yet supported'\n//             } else if (!this.downward && !this.rightward) {\n//                 // this.i--;\n//                 throw 'not yet supported'\n//             } else {\n//                 throw 'not yet supported'\n//             }\n//         }\n//\n//         add_history(i): void {\n//             this.history.push(i)\n//         }\n//\n//         get_history(): number[] {\n//             return this.history\n//         }\n//\n//         public next() {\n//\n//             this.b_started = true;\n//\n//             let value: number[] = null;\n//\n//             this.next_column();\n//\n//             this.add_history(this.i);\n//\n//             if (this.i === this.index_stop) {\n//                 this.done = true;\n//                 return {\n//                     value: value,\n//                     done: this.done\n//                 }\n//             }\n//\n//             return {\n//                 value: this.get_coord_current(),\n//                 done: false\n//             };\n//         }\n//\n//         public get_coord_current(): number[] {\n//             return MatrixIterator.get_coord(this.get_state_current(), this.num_columns)\n//         }\n//\n//         public get_state_current(): number {\n//             return this.i;\n//         }\n//\n//         public static get_coord(i, num_columns): number[] {\n//             let pos_row = division_int(i, num_columns);\n//             let pos_column = remainder(i, num_columns);\n//             return [pos_row, pos_column]\n//         }\n//\n//         public static get_coords_above(coord): number[][] {\n//             if (coord[0] === 0) {\n//                 return [[-1]]\n//             } else {\n//                 return [[coord[0] - 1, coord[1]]]\n//             }\n//             // return [[coord[0] - 1, coord[1]]]\n//         }\n//\n//         public static get_coords_below(coord): number[][] {\n//             return [[coord[0] + 1, coord[1]]]\n//         }\n//     }\n//\n//     export class FactoryMatrixObjectives {\n//         public static create_matrix_objectives(algorithm: Algorithm, segments: Segment[]): any[][] {\n//\n//             let matrix_data = [];\n//\n//             switch(algorithm.get_name()) {\n//                 case algo.DETECT: {\n//                     for (let i=0; i < 1; i++) {\n//                         matrix_data[i] = new Array(segments.length);\n//                     }\n//                     break;\n//                 }\n//                 case algo.PREDICT: {\n//                     for (let i=0; i < 1; i++) {\n//                         matrix_data[i] = new Array(segments.length);\n//                     }\n//                     break;\n//                 }\n//                 case algo.PARSE: {\n//                     for (let i=0; i < algorithm.get_depth(); i++) {\n//                         matrix_data[i] = new Array(segments.length);\n//                     }\n//                     break;\n//                 }\n//                 case algo.DERIVE: {\n//                     for (let i=0; i < algorithm.get_depth(); i++) {\n//                         matrix_data[i] = new Array(segments.length);\n//                     }\n//                     break;\n//                 }\n//                 default: {\n//                     throw 'case not considered';\n//                 }\n//             }\n//             return matrix_data;\n//         }\n//     }\n//\n//     export class IteratorTrainFactory {\n//         public static get_iterator_train(algorithm: Algorithm, segments: Segment[]) {\n//\n//             let iterator: MatrixIterator;\n//\n//             let downward, rightward;\n//\n//             switch (algorithm.get_name()) {\n//                 case algo.DETECT: {\n//                     iterator = new MatrixIterator(\n//                         1,\n//                         segments.length,\n//                         true,\n//                         true,\n//                         0,\n//                         1\n//                     );\n//                     break;\n//                 }\n//                 case algo.PREDICT: {\n//                     iterator = new MatrixIterator(1, segments.length);\n//                     break;\n//                 }\n//                 case algo.PARSE: {\n//                     downward = false;\n//                     rightward = true;\n//                     let index_row_start = algorithm.get_depth() - 1;\n//                     let index_row_stop = 1;\n//                     iterator = new MatrixIterator(\n//                         algorithm.get_depth(),\n//                         segments.length,\n//                         downward,\n//                         rightward,\n//                         index_row_start,\n//                         index_row_stop\n//                     );\n//                     break;\n//                 }\n//                 case algo.DERIVE: {\n//                     downward = true;\n//                     rightward = true;\n//                     let index_row_start = 1;\n//                     let index_row_stop = algorithm.get_depth();\n//                     iterator = new MatrixIterator(\n//                         algorithm.get_depth(),\n//                         segments.length,\n//                         downward,\n//                         rightward,\n//                         index_row_start,\n//                         index_row_stop\n//                     );\n//                     break;\n//                 }\n//                 default: {\n//                     throw ['algorithm of name', algorithm.get_name(), 'not supported'].join(' ')\n//                 }\n//             }\n//             return iterator\n//         }\n//     }\n// }"]}