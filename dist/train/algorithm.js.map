{"version":3,"file":"algorithm.js","sourceRoot":"","sources":["../../src/train/algorithm.ts"],"names":[],"mappings":"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","sourcesContent":["// import {note, note as n} from \"../note/note\";\n// import TreeModel = require(\"tree-model\");\n// import {harmony} from \"../music/harmony\";\n// import {modes_texture} from \"../constants/constants\";\n// import {user_input} from \"../control/user_input\";\n// import {history} from \"../history/history\";\n// import {clip} from \"../clip/clip\";\n// import {parse} from \"../parse/parse\";\n// import {segment} from \"../segment/segment\";\n// import {track} from \"../track/track\";\n// import {window} from \"../render/window\";\n// import {iterate} from \"./iterate\";\n// import {message} from \"../message/messenger\";\n// import {target} from \"../target/target\";\n// import {live} from \"../live/live\";\n// import {scene} from \"../scene/scene\";\n// import {utils} from \"../utils/utils\";\n// import {song} from \"../song/song\";\n//\n// export namespace algorithm {\n//     import Song = song.Song;\n//     export let DETECT = 'detect';\n//     export let PREDICT = 'predict';\n//     export let PARSE = 'parse';\n//     export let DERIVE = 'derive';\n//     export let FREESTYLE = 'freestyle';\n//     import Harmony = harmony.Harmony;\n//     import POLYPHONY = modes_texture.POLYPHONY;\n//     import MONOPHONY = modes_texture.MONOPHONY;\n//     import TypeSequenceTarget = history.TypeSequenceTarget;\n//     import Note = note.Note;\n//     import ParseTree = parse.ParseTree;\n//     import StructParse = parse.StructParse;\n//     import Segment = segment.Segment;\n//     import get_notes_on_track = track.get_notes_on_track;\n//     import Window = window.Window;\n//     import Track = track.Track;\n//     import MatrixIterator = iterate.MatrixIterator;\n//     import Messenger = message.Messenger;\n//     import Subtarget = target.Subtarget;\n//     import TargetIterator = target.TargetIterator;\n//     import ApiJs = live.ApiJs;\n//     import ClipDao = clip.ClipDao;\n//     import Target = target.Target;\n//     import FactoryMatrixObjectives = iterate.FactoryMatrixObjectives;\n//     import Scene = scene.Scene;\n//     import UserInputHandler = user_input.UserInputHandler;\n//     import Clip = clip.Clip;\n//\n//\n//     interface Temporal {\n//         determine_region_present(notes_next)\n//         stream_bounds(messenger: message.Messenger, subtarget_current: Subtarget, segment_current: Segment): void\n//     }\n//\n//     interface Renderable {\n//         initialize_render(window: Window, segments: Segment[], notes_track_target: TreeModel.Node<Note>[])\n//         get_notes_in_region(target: Target, segment: Segment): TreeModel.Node<Note>[]\n//     }\n//\n//     // interface that the trainer uses\n//     export interface Trainable extends Temporal, Renderable {\n//         depth: number;\n//         b_parsed: boolean;\n//         b_targeted: boolean;\n//\n//         get_name(): string\n//         get_depth(): number\n//         coord_to_index_clip(coord: number[]): number\n//         initialize(window: Window, segments: Segment[], notes_target_track: TreeModel.Node<Note>[], user_input_handler: UserInputHandler): void\n//         terminate(struct_parse: StructParse, segments: Segment[])\n//         unpause(song: Song, scene_current: Scene)\n//         pause(song: Song, scene_current: Scene)\n//         create_matrix_targets(user_input_handler: UserInputHandler, segments: Segment[], notes_target_track: TreeModel.Node<Note>[])\n//         create_struct_parse(segments: Segment[]): StructParse\n//         initialize_tracks(segments: segment.Segment[], track_target: track.Track, track_user_input: track.Track, matrix_target: TargetIterator[][])\n//\n//         warrants_advance(\n//             notes_user_input: TreeModel.Node<Note>[],\n//             subtarget_current: Subtarget\n//         ): boolean\n//\n//         postprocess_user_input(\n//             notes_user_input: TreeModel.Node<Note>[],\n//             subtarget_current: Subtarget\n//         ): TreeModel.Node<Note>[]\n//     }\n//\n//     // interface common to both parse and derive, but have different implementations\n//     export interface Parsable extends Trainable {\n//         initialize_parse(struct_parse, segments, track_target)\n//         finish_parse(struct_parse: StructParse, segments: Segment[]): void;\n//         update_roots(coords_roots_previous: number[][], coords_notes_to_grow: number[][], coord_notes_current: number[])\n//         get_coords_notes_to_grow(coords_note_input_current): number[][]\n//         grow_layer(notes_user_input_renderable, notes_to_grow)\n//     }\n//\n//     // interface common to both detect and predict, but have different implementations\n//     export interface Targetable extends Trainable {\n//         determine_targets(user_input_handler: UserInputHandler, notes_in_segment: TreeModel.Node<Note>[])\n//         postprocess_subtarget(subtarget: Subtarget)\n//     }\n//\n//     // logic common to detect and predict\n//     abstract class Targeted implements Targetable {\n//\n//         public b_parsed: boolean = false;\n//         public b_targeted: boolean = true;\n//         public depth: number;\n//         public abstract get_name()\n//\n//         determine_targets(user_input_handler: UserInputHandler, notes_segment_next: TreeModel.Node<n.Note>[]): TypeSequenceTarget {\n//             if (user_input_handler.mode_texture === POLYPHONY) {\n//\n//                 let chords_grouped: TreeModel.Node<n.Note>[][] = Harmony.group(\n//                     notes_segment_next\n//                 );\n//\n//                 let chords_monophonified: TypeSequenceTarget = [];\n//\n//                 for (let note_group of chords_grouped) {\n//                     chords_monophonified.push(\n//                         Harmony.monophonify(\n//                             note_group\n//                         )\n//                     );\n//                 }\n//\n//                 // return [chords_monophonified[Math.floor(Math.random() * chords_monophonified.length)]];\n//                 return [chords_monophonified[chords_monophonified.length/2]]\n//\n//             } else if (user_input_handler.mode_texture === MONOPHONY) {\n//\n//                 let notes_grouped_trivial: TypeSequenceTarget = [];\n//\n//                 for (let note of notes_segment_next) {\n//                     notes_grouped_trivial.push([note])\n//                 }\n//\n//                 // return notes_grouped_trivial\n//                 // TODO: let's put more weight towards the center of the measure\n//                 // return notes_grouped_trivial[Math.floor(Math.random() * notes_grouped_trivial.length)];\n//                 return [notes_grouped_trivial[notes_grouped_trivial.length/2]]\n//\n//             } else {\n//                 throw ['texture mode', user_input_handler.mode_texture, 'not supported'].join(' ')\n//             }\n//         }\n//\n//         public get_depth(): number {\n//             return 1\n//         }\n//\n//         coord_to_index_clip(coord: number[]): number {\n//             return 0;\n//         }\n//\n//         create_struct_parse(segments: Segment[]) {\n//             return null\n//         }\n//\n//         public determine_region_present(notes_target_next): number[] {\n//             return [\n//                 notes_target_next[0].model.note.beat_start,\n//                 notes_target_next[0].model.note.get_beat_end()\n//             ]\n//         }\n//\n//         get_notes_in_region(target: target.Target, segment: segment.Segment) {\n//             return target.iterator_subtarget.subtargets.map((subtarget) => {\n//                 return subtarget.note\n//             })\n//         }\n//\n//         public abstract initialize_render(window: Window, segments: Segment[], notes_target_track: TreeModel.Node<Note>[])\n//\n//         unpause(song: Song, scene_current: Scene) {\n//             // not forcing legato so that it starts immediately\n//             scene_current.fire(false)\n//         }\n//\n//         postprocess_user_input(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current: target.Subtarget): TreeModel.Node<note.Note>[] {\n//             return [subtarget_current.note];\n//         }\n//\n//         public abstract postprocess_subtarget(subtarget: Subtarget)\n//\n//         // TODO: verify that we don't need to do anything\n//         terminate() {\n//             return\n//         }\n//\n//         pause(song: Song, scene_current: Scene) {\n//             song.stop()\n//         }\n//\n//         warrants_advance(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current): boolean {\n//             return utils.remainder(notes_user_input[0].model.note.pitch, 12) === utils.remainder(subtarget_current.note.model.note.pitch, 12)\n//         }\n//\n//         public create_matrix_targets(user_input_handler: UserInputHandler, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]): TargetIterator[][] {\n//\n//             let matrix_targets = FactoryMatrixObjectives.create_matrix_objectives(\n//                 this,\n//                 segments\n//             );\n//\n//             // TODO: use 'filter' here\n//             // this.clip_target.load_notes_within_markers();\n//\n//             for (let i_segment in segments) {\n//                 let segment = segments[Number(i_segment)];\n//\n//                 let notes_in_segment = notes_target_track.filter(\n//                     node => node.model.note.beat_start >= segment.get_endpoints_loop()[0] && node.model.note.get_beat_end() <= segment.get_endpoints_loop()[1]\n//                 );\n//\n//                 let sequence_targets = this.determine_targets(\n//                     user_input_handler,\n//                     notes_in_segment\n//                 );\n//\n//                 // set the note as muted for predict\n//                 // TODO: put in \"initialize_track_user_input\n//                 // for (let target of sequence_targets) {\n//                 //     for (let subtarget of target) {\n//                 //\n//                 //         let subtarget_processed = this.postprocess_subtarget(\n//                 //             subtarget\n//                 //         );\n//                 //\n//                 //         clip_target_track.remove_notes(\n//                 //             subtarget_processed.model.note.beat_start,\n//                 //             0,\n//                 //             subtarget_processed.model.note.get_beat_end(),\n//                 //             128\n//                 //         );\n//                 //\n//                 //         clip_target_track.set_notes(\n//                 //             [subtarget_processed]\n//                 //         )\n//                 //     }\n//                 // }\n//\n//                 matrix_targets[0][Number(i_segment)] = TargetIterator.from_sequence_target(sequence_targets);\n//             }\n//\n//             return matrix_targets\n//         }\n//\n//         private static stream_subtarget_bounds(messenger: message.Messenger, subtarget_current: Subtarget, segment_current: Segment) {\n//             let ratio_bound_lower = (subtarget_current.note.model.note.beat_start - segment_current.get_endpoints_loop()[0])/(segment_current.get_endpoints_loop()[1] - segment_current.get_endpoints_loop()[0]);\n//             let ratio_bound_upper = (subtarget_current.note.model.note.get_beat_end() - segment_current.get_endpoints_loop()[0])/(segment_current.get_endpoints_loop()[1] - segment_current.get_endpoints_loop()[0]);\n//             messenger.message(['bounds', ratio_bound_lower, ratio_bound_upper])\n//         }\n//\n//         stream_bounds(messenger: message.Messenger, subtarget_current: Subtarget, segment_current: Segment): void {\n//             Targeted.stream_subtarget_bounds(messenger, subtarget_current, segment_current)\n//         }\n//\n//         initialize(window: Window, segments: Segment[], notes_target_track: TreeModel.Node<Note>[], user_input_handler: UserInputHandler) {\n//             this.create_matrix_targets(user_input_handler, segments, notes_target_track);\n//             this.initialize_render(window, segments, notes_target_track)\n//         }\n//     }\n//\n//     // logic common to parse and derive\n//     abstract class Parsed implements Parsable {\n//\n//         public b_parsed: boolean = true;\n//\n//         public b_targeted: boolean = false;\n//\n//         public abstract get_name();\n//\n//         depth: number;\n//\n//         public abstract initialize_render(window: Window, segments: Segment[], notes_track_target: TreeModel.Node<Note>[])\n//\n//         public get_depth(): number {\n//             return this.depth\n//         }\n//\n//         set_depth(depth: number) {\n//             this.depth = depth;\n//         }\n//\n//         coord_to_index_clip(coord: number[]): number {\n//             if (coord[0] === -1) {\n//                 return 0\n//             } else {\n//                 return coord[0] + 1\n//             }\n//         }\n//\n//         create_matrix_targets(user_input_handler: UserInputHandler, segments: segment.Segment[], notes_target_track: TreeModel.Node<note.Note>[]) {\n//             return []\n//         }\n//\n//         create_struct_parse(segments: Segment[]): StructParse {\n//             return new StructParse(\n//                 FactoryMatrixObjectives.create_matrix_objectives(\n//                     this,\n//                     segments\n//                 )\n//             )\n//         }\n//\n//         determine_region_present(notes_target_next): number[] {\n//             return [\n//                 notes_target_next[0].model.note.beat_start,\n//                 notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n//             ]\n//         }\n//\n//         finish_parse(struct_parse: parse.StructParse, segments: segment.Segment[]): void {\n//         }\n//\n//         public abstract get_coords_notes_to_grow(coords_note_input_current): number[][]\n//\n//         get_notes_in_region(target: target.Target, segment: segment.Segment) {\n//             return [segment.get_note()]\n//         }\n//\n//         public abstract grow_layer(notes_user_input_renderable, notes_to_grow)\n//\n//         initialize() {\n//             // TODO: add logic\n//         }\n//\n//         public abstract initialize_parse(struct_parse, segments, track_target)\n//\n//\n//         pause(song: Song, scene_current: Scene) {\n//             song.set_overdub(0);\n//\n//             song.set_session_record(0);\n//\n//             song.stop()\n//         }\n//\n//         postprocess_user_input(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current: target.Subtarget): TreeModel.Node<note.Note>[] {\n//             return notes_user_input;\n//         }\n//\n//         stream_bounds(messenger: message.Messenger, subtarget_current: target.Subtarget, segment_current: segment.Segment): void {\n//             Parsed.stream_segment_bounds(messenger)\n//         }\n//\n//         private static stream_segment_bounds(messenger: Messenger) {\n//             messenger.message(['bounds', 0, 1])\n//         }\n//\n//         terminate(struct_parse: StructParse, segments: Segment[]) {\n//             this.finish_parse(struct_parse, segments)\n//         }\n//\n//         unpause(song: Song, scene_current: Scene) {\n//             song.set_overdub(1);\n//\n//             song.set_session_record(1);\n//\n//             scene_current.fire(false);\n//         }\n//\n//         update_roots(coords_roots_previous: number[][], coords_notes_to_grow: number[][], coord_notes_current: number[]) {\n//\n//         }\n//\n//         warrants_advance(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current: target.Subtarget): boolean {\n//             return true;\n//         }\n//     }\n//\n//     export class Detect extends Targeted {\n//\n//         constructor() {\n//             super();\n//         }\n//\n//         public get_name(): string {\n//             return DETECT\n//         }\n//\n//         postprocess_subtarget(note_subtarget) {\n//             return note_subtarget\n//         }\n//\n//         // TODO: verify that we don't have to do anything here\n//         initialize_render(window: window.Window, segments: segment.Segment[], notes_target_track: TreeModel.Node<note.Note>[]) {\n//             return\n//         }\n//\n//         initialize_tracks(segments: segment.Segment[], track_target: track.Track, track_user_input: track.Track, matrix_target: TargetIterator[][]) {\n//             return\n//         }\n//     }\n//\n//     export class Predict extends Targeted {\n//\n//         public get_name(): string {\n//             return PREDICT\n//         }\n//\n//         postprocess_subtarget(note_subtarget) {\n//             note_subtarget.model.note.muted = 1;\n//             return note_subtarget;\n//         }\n//\n//         // TODO: verify that we don't have to do anythiing here\n//         initialize_render(window: window.Window, segments: segment.Segment[], notes_target_track: TreeModel.Node<note.Note>[]) {\n//             return\n//         }\n//\n//         initialize_tracks(segments: segment.Segment[], track_target: track.Track, track_user_input: track.Track, matrix_target: TargetIterator[][]) {\n//             // TODO: get the subtargets that are currently in each segment and mute them\n//         //     for (let target of sequence_targets) {\n//         //         for (let subtarget of target) {\n//         //\n//         //             let subtarget_processed = this.postprocess_subtarget(\n//         //                 subtarget\n//         //             );\n//         //\n//         //             clip_target_track.remove_notes(\n//         //                 subtarget_processed.model.note.beat_start,\n//         //                 0,\n//         //                 subtarget_processed.model.note.get_beat_end(),\n//         //                 128\n//         //             );\n//         //\n//         //             clip_target_track.set_notes(\n//         //                 [subtarget_processed]\n//         //             )\n//         //         }\n//         //     }\n//         //\n//         //     for (let i_segment in segments) {\n//         //\n//         //         let index_clip_slot_current = Number(i_segment);\n//         //\n//         //         let api_clip_target_synchronous = new ApiJs(\n//         //             track_target.track_dao.get_path().split(' ').concat(['clip_slots', index_clip_slot_current, 'clip']).join(' ')\n//         //         );\n//         //\n//         //         let api_clip_user_input_synchronous = new ApiJs(\n//         //             track_user_input.track_dao.get_path().split(' ').concat(['clip_slots', index_clip_slot_current, 'clip']).join(' ')\n//         //         );\n//         //\n//         //         let clip_target = new Clip(\n//         //             new ClipDao(\n//         //                 api_clip_target_synchronous,\n//         //                 new Messenger('max', 0)\n//         //             )\n//         //         );\n//         //\n//         //         let clip_user_input = new Clip(\n//         //             new ClipDao(\n//         //                 api_clip_user_input_synchronous,\n//         //                 new Messenger('max', 0)\n//         //             )\n//         //         );\n//         //\n//         //         let notes = clip_target.get_notes(\n//         //             clip_target.get_loop_bracket_lower(),\n//         //             0,\n//         //             clip_target.get_loop_bracket_upper(),\n//         //             128\n//         //         );\n//         //\n//         //         clip_user_input.remove_notes(\n//         //             clip_target.get_loop_bracket_lower(),\n//         //             0,\n//         //             clip_target.get_loop_bracket_upper(),\n//         //             128\n//         //         );\n//         //\n//         //         clip_user_input.set_notes(\n//         //             notes\n//         //         )\n//         //     }\n//         }\n//     }\n//\n//     export class Parse extends Parsed {\n//\n//         constructor() {\n//             super();\n//         }\n//\n//         public get_name(): string {\n//             return PARSE\n//         }\n//\n//         grow_layer(notes_user_input_renderable, notes_to_grow) {\n//             ParseTree.add_layer(\n//                 notes_user_input_renderable,\n//                 notes_to_grow,\n//                 -1\n//             )\n//         }\n//\n//         // TODO: we can't pass in just one clip if we want to initialize an entire track\n//         initialize_tracks(segments: segment.Segment[], track_target: track.Track, track_user_input: track.Track, matrix_target: TargetIterator[][]) {\n//             for (let i_segment in segments) {\n//\n//                 let index_clip_slot_current = Number(i_segment);\n//\n//                 let api_clip_target_synchronous = new ApiJs(\n//                     track_target.track_dao.get_path().split(' ').concat(['clip_slots', index_clip_slot_current, 'clip']).join(' ')\n//                 );\n//\n//                 let api_clip_user_input_synchronous = new ApiJs(\n//                     track_user_input.track_dao.get_path().split(' ').concat(['clip_slots', index_clip_slot_current, 'clip']).join(' ')\n//                 );\n//\n//                 let clip_target: Clip = track_target.get_clip_at_clip_slot(index_clip_slot_current);\n//\n//                 let clip_user_input: Clip = track_user_input.get_clip_at_clip_slot(index_clip_slot_current);\n//\n//                 // let clip_target = new Clip(\n//                 //     new ClipDao(\n//                 //         api_clip_target_synchronous,\n//                 //         new Messenger('max', 0)\n//                 //     )\n//                 // );\n//                 //\n//                 // let clip_user_input = new Clip(\n//                 //     new ClipDao(\n//                 //         api_clip_user_input_synchronous,\n//                 //         new Messenger('max', 0)\n//                 //     )\n//                 // );\n//\n//                 let notes = clip_target.get_notes(\n//                     clip_target.get_loop_bracket_lower(),\n//                     0,\n//                     clip_target.get_loop_bracket_upper(),\n//                     128\n//                 );\n//\n//                 clip_user_input.remove_notes(\n//                     clip_target.get_loop_bracket_lower(),\n//                     0,\n//                     clip_target.get_loop_bracket_upper(),\n//                     128\n//                 );\n//\n//                 clip_user_input.set_notes(\n//                     notes\n//                 )\n//             }\n//         }\n//\n//         // add the root up to which we're going to parse\n//         // add the segments as the layer below\n//         // add the leaf notes\n//         initialize_render(window: Window, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]) {\n//             // first layer\n//             window.add_note_to_clip_root(\n//                 StructParse.create_root_from_segments(\n//                     segments\n//                 )\n//             );\n//\n//             for (let i_segment in segments) {\n//\n//                 let segment = segments[Number(i_segment)];\n//\n//                 let note_segment = segment.get_note();\n//\n//                 let coord_current_virtual_second_layer = [0, Number(i_segment)];\n//\n//                 let notes_leaves = notes_target_track.filter(\n//                     node => node.model.note.beat_start >= segment.get_endpoints_loop()[0] && node.model.note.get_beat_end() <= segment.get_endpoints_loop()[1]\n//                 );\n//\n//                 let coord_current_virtual_leaves = [this.get_depth() - 1, Number(i_segment)];\n//\n//                 // second layer\n//                 window.add_notes_to_clip(\n//                     [note_segment],\n//                     coord_current_virtual_second_layer,\n//                     this\n//                 );\n//\n//                 // leaves\n//                 window.add_notes_to_clip(\n//                     notes_leaves,\n//                     coord_current_virtual_leaves,\n//                     this\n//                 )\n//             }\n//         }\n//\n//         update_roots(coords_roots_previous: number[][], coords_notes_previous: number[][], coord_notes_current: number[]) {\n//             let coords_roots_new = [];\n//\n//             // remove references to old leaves\n//             for (let coord_notes_previous of coords_notes_previous) {\n//                 coords_roots_new = coords_roots_new.concat(\n//                     coords_roots_previous.filter((x) => {\n//                         return !(x[0] === coord_notes_previous[0] && x[1] === coord_notes_previous[1])\n//                     })\n//                 );\n//             }\n//\n//             // add references to new leaves\n//             coords_roots_new.push(\n//                 coord_notes_current\n//             );\n//         }\n//\n//         get_coords_notes_to_grow(coord_notes_input_current) {\n//             return MatrixIterator.get_coords_below([coord_notes_input_current[0], coord_notes_input_current[1]]);\n//         }\n//\n//         // adding the leaf notes to the actual parse tree\n//         // DO NOT set the root or the segments as nodes immediately below that - do that at the end\n//         // set the leaf notes as the notes in the target track\n//         initialize_parse(struct_parse: StructParse, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]) {\n//             // this is to set the leaves as the notes of the target clip\n//\n//             for (let i_segment in segments) {\n//                 let segment = segments[Number(i_segment)];\n//\n//                 let notes = notes_target_track.filter(\n//                     node => node.model.note.beat_start >= segment.get_endpoints_loop()[0] && node.model.note.get_beat_end() <= segment.get_endpoints_loop()[1]\n//                 );\n//\n//                 let coord_current_virtual_leaf = [this.get_depth() - 1, Number(i_segment)];\n//\n//                 struct_parse.add(\n//                     notes,\n//                     coord_current_virtual_leaf,\n//                     this\n//                 );\n//             }\n//         }\n//\n//         finish_parse(struct_parse: StructParse, segments: Segment[]): void {\n//\n//             // make connections with segments\n//             for (let i_segment in segments) {\n//                 let segment = segments[Number(i_segment)];\n//                 struct_parse.add(\n//                     [segment.get_note()],\n//                     [0, Number(i_segment)],\n//                     this\n//                 );\n//             }\n//\n//             struct_parse.set_root(\n//                 StructParse.create_root_from_segments(\n//                     segments\n//                 )\n//             );\n//\n//             // make connections with root\n//             struct_parse.add(\n//                 [Note.from_note_renderable(struct_parse.get_root())],\n//                 [-1],\n//                 this\n//             );\n//         }\n//     }\n//\n//     export class Derive extends Parsed {\n//\n//         public get_name(): string {\n//             return DERIVE\n//         }\n//\n//         get_coords_notes_to_grow(coords_note_input_current) {\n//             return MatrixIterator.get_coords_above([coords_note_input_current[0], coords_note_input_current[1]])\n//         }\n//\n//         grow_layer(notes_user_input_renderable, notes_to_grow) {\n//             ParseTree.add_layer(\n//                 notes_to_grow,\n//                 notes_user_input_renderable,\n//                 -1\n//             )\n//         }\n//\n//         initialize_tracks(segments: segment.Segment[], track_target: track.Track, track_user_input: track.Track, matrix_target: TargetIterator[][]) {\n//             return\n//         }\n//\n//         initialize_parse(struct_parse: StructParse, segments: Segment[]) {\n//             // add the root to the tree immediately\n//             struct_parse.set_root(\n//                 ParseTree.create_root_from_segments(\n//                     segments\n//                 )\n//             );\n//\n//             for (let i_segment in segments) {\n//\n//                 let segment = segments[Number(i_segment)];\n//\n//                 let note = segment.get_note();\n//\n//                 let coord_current_virtual = [0, Number(i_segment)];\n//\n//                 struct_parse.add(\n//                     [note],\n//                     coord_current_virtual,\n//                     this\n//                 );\n//             }\n//         }\n//\n//         initialize_render(window: Window, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]) {\n//             // first layer (root)\n//             window.add_note_to_clip_root(\n//                 StructParse.create_root_from_segments(\n//                     segments\n//                 )\n//             );\n//\n//             for (let i_segment in segments) {\n//\n//                 let segment = segments[Number(i_segment)];\n//\n//                 let note_segment = segment.get_note();\n//\n//                 let coord_current_virtual_second_layer = [0, Number(i_segment)];\n//\n//                 // second layer\n//                 window.add_notes_to_clip(\n//                     [note_segment],\n//                     coord_current_virtual_second_layer,\n//                     this\n//                 );\n//             }\n//         }\n//\n//         finish_parse(struct_parse: StructParse, segments: Segment[]): void {\n//             return\n//         }\n//     }\n// }"]}