{"version":3,"file":"parse.js","sourceRoot":"","sources":["parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {segment} from \"../segment/segment\";\nimport {note as n, note} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {log} from \"../log/logger\";\nimport {utils} from \"../utils/utils\";\nimport {live} from \"../live/live\";\nimport {clip as c} from \"../clip/clip\";\nimport {algorithm} from \"../train/algorithm\";\n\nconst _ = require(\"underscore\");\n\n\nexport namespace parse {\n    import LiveClipVirtual = live.LiveClipVirtual;\n    import DETECT = algorithm.DETECT;\n    import PARSE = algorithm.PARSE;\n    import DERIVE = algorithm.DERIVE;\n\n    export interface Parsable {\n        choose(): boolean;\n\n        // TODO: annotation\n        get_best_candidate(list_candidate_note);\n    }\n\n    abstract class ParseTree {\n        root: TreeModel.Node<n.NoteRenderable>;\n\n        constructor() {\n\n        }\n\n        public get_root(): TreeModel.Node<n.NoteRenderable> {\n            return this.root\n        }\n    }\n\n    export class ParseMatrix extends ParseTree {\n\n        root: TreeModel.Node<n.NoteRenderable>;\n\n        matrix_note_sequence: TreeModel.Node<n.NoteRenderable>[][][];\n\n        coords_roots: number[][]; // list of coordinates\n\n        constructor(matrix) {\n            super();\n\n            // let tree: TreeModel = new TreeModel();\n\n            // this.root = tree.parse(\n            //     {\n            //         id: -1, // TODO: hashing scheme for clip id and beat start\n            //         note: new n.NoteRenderable(\n            //             // Number(splitted[0]),\n            //             // Number(splitted[1]),\n            //             // Number(splitted[2]),\n            //             // Number(splitted[3]),\n            //             // Number(splitted[4]),\n            //             // coordinates_matrix\n            //             note.model.note.pitch,\n            //             note.model.note.beat_start,\n            //             note.model.note.beats_duration,\n            //             note.model.note.velocity,\n            //             note.model.note.muted,\n            //             coordinates_matrix\n            //         ),\n            //         children: [\n            //\n            //         ]\n            //     }\n            // )\n\n            matrix.unshift([]);  // entire row reserved for root\n\n            this.matrix_note_sequence = matrix;\n        }\n\n        public get_roots_at_coord(coord: number[]) {\n            return this.matrix_note_sequence[coord[0]][coord[1]]\n        }\n\n        // // TODO: we actually have to implement\n        // public static add(input_user, list_parse_tree, iterator_matrix_train): ParseTree[] {\n        //     let coord = iterator_matrix_train.get_coord_current()\n        //     return\n        // }\n        //\n        private static get_diff_index_start(notes_new: TreeModel.Node<n.Note>[], notes_old: TreeModel.Node<n.Note>[]): number {\n            let same_start, same_duration, index_start_diff;\n            for (let i=0; i < notes_old.length; i++) {\n                same_start = (notes_old[i].model.note.beat_start === notes_new[i].model.note.beat_start);\n                same_duration = (notes_old[i].model.note.beats_duration === notes_new[i].model.note.beats_duration);\n                if (!(same_start && same_duration)) {\n                    index_start_diff = i;\n                    break;\n                }\n            }\n\n            return index_start_diff;\n        }\n\n        private static get_diff_index_end(notes_new: TreeModel.Node<n.Note>[], notes_old: TreeModel.Node<n.Note>[]): number {\n            let same_start, same_duration, index_end_diff;\n            for (let i=-1; i > -1 * (notes_new.length + 1); i--) {\n                same_start = (notes_new.slice(i)[0].model.note.beat_start === notes_old.slice(i)[0].model.note.beat_start);\n                same_duration = (notes_new.slice(i)[0].model.note.beats_duration === notes_old.slice(i)[0].model.note.beats_duration);\n                if (!(same_start && same_duration)) {\n                    index_end_diff = i;\n                    break;\n                }\n            }\n\n            // NB: add one in order to use with array slice, unless of course the index is -1, then you'll access the front of the array\n            return index_end_diff;\n        }\n\n        // TODO: complete return method signature\n        get_diff_index_notes(notes_parent: TreeModel.Node<n.Note>[], notes_child: TreeModel.Node<n.Note>[]): number[] {\n            return [\n                ParseTree.get_diff_index_start(notes_child, notes_parent),\n                ParseTree.get_diff_index_end(notes_child, notes_parent)\n            ];\n        };\n\n        // public get_root(): TreeModel.Node<n.NoteRenderable> {\n        //     return this.root\n        // }\n\n        public to_coord_parse_matrix(coord: number[]): number[] {\n            if (coord[0] === 0) {\n                return [0, 0] // entire \"row\" is dedicated to root\n            } else {\n                return coord\n            }\n        }\n\n        public add(notes_user_input, iterator_matrix_train, algorithm): void {\n            //\n            // ParseTree.add_layer(,notes_user_input);\n            // return\n\n\n            // TODO: remove coordinates of either 'notes_below' or 'notes_above'\n            this.coords_roots\n\n            let coord_notes_previous;\n\n            let coord_notes_current = this.to_coord_parse_matrix(iterator_matrix_train.get_coord_current());\n\n            this.matrix_note_sequence[coord_notes_current[0]][coord_notes_current[1]] = notes_user_input;\n\n            switch (algorithm.get_name()) {\n                case PARSE: {\n                    // coord_notes_current = iterator_matrix_train.get_coord_current();\n                    coord_notes_previous = this.to_coord_parse_matrix([coord_notes_current[0] - 1, coord_notes_current[1]]);\n                    let notes_below = this.matrix_note_sequence[coord_notes_previous[0]][coord_notes_previous[1]];\n                    let notes_children = notes_below;\n                    this.add_layer(\n                        notes_user_input,\n                        notes_children\n                    );\n                    break;\n                }\n                case DERIVE: {\n                    // coord_notes_current = this.to_coord_parse_matrix(iterator_matrix_train.get_coord_current());\n                    coord_notes_previous = this.to_coord_parse_matrix([coord_notes_current[0] + 1, coord_notes_current[1]]);\n                    let notes_above = this.matrix_note_sequence[coord_notes_previous[0]][coord_notes_previous[1]];\n                    let notes_parent = notes_above;\n                    this.add_layer(\n                        notes_parent,\n                        notes_user_input\n                    );\n                    break;\n                }\n                default: {\n                    throw 'adding notes to parse tree failed'\n                }\n            }\n\n            this.coords_roots.remove(coord_notes_previous);\n\n            this.coords_roots.add(coord_notes_current);\n\n        }\n\n        //\n        // private add_first_layer(notes: TreeModel.Node<n.Note>[], index_new_layer: number): void {\n        //     // var note_parent_best, b_successful;\n        //\n        //     for (let node of notes) {\n        //         node.model.id = index_new_layer;\n        //         this.root_parse_tree.addChild(node);\n        //     }\n        // }\n        //\n        // NB: only works top down currently\n        // private add_layer(notes_parent: TreeModel.Node<n.Note>[], notes_child: TreeModel.Node<n.Note>[]): TreeModel.Node<n.Note>[] {\n        private add_layer(notes_parent: TreeModel.Node<n.Note>[], notes_child: TreeModel.Node<n.Note>[], index_new_layer: number): void {\n\n            var note_parent_best, b_successful;\n\n            for (let node of notes_child) {\n                note_parent_best = node.model.note.get_best_candidate(notes_parent);\n                b_successful = node.model.note.choose();\n                if (b_successful) {\n                    node.model.id = index_new_layer;\n                    note_parent_best.addChild(node);\n                }\n            }\n        };\n        //\n        // private update_leaves(leaves: TreeModel.Node<n.Note>[]) {\n        //     // find leaves in parse/derive beat interval\n        //\n        //     // splice them with their children\n        //     let leaves_spliced = this.leaves;\n        //     let children_to_insert, i_leaf_to_splice;\n        //     for (let leaf of leaves) {\n        //         // find index of leaf to \"splice\"\n        //         // always splice only one leaf\n        //         // find corresponding leaf in leaves_spliced\n        //         children_to_insert = [];\n        //         if (leaf.hasChildren()) {\n        //             i_leaf_to_splice = _.findIndex(leaves_spliced, (leaf_to_splice)=>{\n        //                 // assuming monophony, i.e., no overlap\n        //                 return leaf_to_splice.model.note.beat_start === leaf.model.note.beat_start\n        //             });\n        //\n        //             let beat_end_children_greatest = -Infinity, beat_start_children_least = Infinity;\n        //\n        //             for (let child of leaf.children) {\n        //                 if (child.model.note.get_beat_end() > beat_end_children_greatest) {\n        //                     beat_end_children_greatest = child.model.note.get_beat_end();\n        //                 }\n        //                 if (child.model.note.beat_start < beat_start_children_least) {\n        //                     beat_start_children_least = child.model.note.beat_start;\n        //                 }\n        //                 children_to_insert.push(child);\n        //             }\n        //\n        //             if (false) {\n        //                 // if (leaf.model.note.get_beat_end() > beat_end_children_greatest || leaf.model.note.beat_start < beat_start_children_least) {\n        //                 leaves_spliced.splice(\n        //                     i_leaf_to_splice,\n        //                     0,\n        //                     ...children_to_insert\n        //                 )\n        //             } else {\n        //                 leaves_spliced.splice(\n        //                     i_leaf_to_splice,\n        //                     1,\n        //                     ...children_to_insert\n        //                 )\n        //             }\n        //             // leaves_spliced.splice(\n        //             //     i_leaf_to_splice,\n        //             //     1,\n        //             //     ...children_to_insert\n        //             // )\n        //         }\n        //     }\n        //\n        //     this.leaves = leaves_spliced;\n        // }\n        //\n        // public insert(notes: TreeModel.Node<n.Note>[]) {\n        //     if (this.iterator_tree.get_index_current() == 1) {\n        //         this.set_root(notes[0])\n        //     } else {\n        //         this.grow(\n        //             notes,\n        //             this.iterator_tree.get_breadth_current();\n        //         this.iterator_tree.get_depth_current();\n        //     )\n        //     }\n        // }\n        //\n        // get_notes_leaves(): TreeModel.Node<n.Note>[] {\n        //     return this.leaves;\n        // }\n        //\n        // set_root(note_root: TreeModel.Node<n.Note>) {\n        //     let clip_dao_virtual = new LiveClipVirtual([note_root]);\n        //\n        //     let clip_virtual = new c.Clip(clip_dao_virtual);\n        //\n        //     clip_virtual.clip_dao.beat_start = note_root.model.note.beat_start;\n        //\n        //     clip_virtual.clip_dao.beat_end = note_root.model.note.get_beat_end();\n        //\n        //     this.add_clip(clip_virtual);\n        //\n        //     note_root.model.id = 0;  // index of first clip\n        //\n        //     this.root_parse_tree = note_root;\n        //\n        //     this.leaves = [note_root];\n        // }\n        //\n        // // struct\n        // elaborate(elaboration: TreeModel.Node<n.Note>[], beat_start: number, beat_end: number, index_layer: number): void {\n        //\n        //     if (index_layer + 1 > this.clips.length) {\n        //         let clip_dao_virtual = new LiveClipVirtual(elaboration);\n        //\n        //         clip_dao_virtual.beat_start = elaboration[0].model.note.beat_start;\n        //         clip_dao_virtual.beat_end = elaboration[elaboration.length - 1].model.note.get_beat_end();\n        //\n        //         let clip_virtual = new c.Clip(clip_dao_virtual);\n        //         this.add_clip(clip_virtual);\n        //     } else {\n        //         let clip_last = this.clips[this.clips.length - 1];\n        //         clip_last.clip_dao.beat_end = elaboration[elaboration.length - 1].model.note.get_beat_end();\n        //         clip_last.set_notes(elaboration);\n        //     }\n        //\n        //     let leaves_within_interval = this.get_leaves_within_interval(beat_start, beat_end);\n        //\n        //     if (index_layer == 1) {\n        //         this.add_first_layer(elaboration, this.clips.length - 1)\n        //     } else {\n        //         this.add_layer(leaves_within_interval, elaboration, this.clips.length - 1);\n        //     }\n        //\n        //     this.update_leaves(leaves_within_interval);\n        // }\n        //\n        // // struct\n        // splice_notes(notes_subset: TreeModel.Node<n.Note>[], clip: c.Clip, interval_beats: number[]): TreeModel.Node<n.Note>[] {\n        //     let notes_clip = _.cloneDeep(clip.get_notes_within_loop_brackets());\n        //     let num_notes_to_replace = this.get_order_of_note_at_beat_end(notes_clip, interval_beats[1]) - this.get_order_of_note_at_beat_start(notes_clip, interval_beats[0]) + 1;\n        //     let index_start = this.get_note_index_at_beat(interval_beats[0], notes_clip);\n        //     notes_clip.splice(index_start, num_notes_to_replace, ...notes_subset);\n        //     return notes_clip\n        // }\n        //\n        // // struct\n        // get_note_index_at_beat(beat: number, notes: TreeModel.Node<n.Note>[]): number {\n        //     let val =  _.findIndex(notes, (node)=>{\n        //         return node.model.note.beat_start === beat\n        //     });\n        //     return val;\n        // }\n        //\n        // // struct\n        // get_leaves_within_interval(beat_start: number, beat_end: number): TreeModel.Node<n.Note>[] {\n        //     let val =  this.leaves.filter((node) =>{\n        //         // return node.model.note.beat_start >= beat_start && node.model.note.get_beat_end() <= beat_end\n        //         return (node.model.note.beat_start >= beat_start && node.model.note.beat_start <= beat_end) ||\n        //             (node.model.note.get_beat_end() <= beat_end && node.model.note.get_beat_end() >= beat_start) ||\n        //             (node.model.note.get_beat_end() >= beat_end && node.model.note.beat_start <= beat_start)\n        //\n        //     });\n        //     // this.logger.log(CircularJSON.stringify(this.leaves));\n        //     return val;\n        // }\n\n    }\n}"]}