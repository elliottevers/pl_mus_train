{"version":3,"file":"parse.js","sourceRoot":"","sources":["parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {segment} from \"../segment/segment\";\nimport {note as n, note} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {log} from \"../log/logger\";\nimport {utils} from \"../utils/utils\";\nimport {live} from \"../live/live\";\nimport {clip as c} from \"../clip/clip\";\nimport {algorithm} from \"../train/algorithm\";\nimport {trainer} from \"../train/trainer\";\nimport {iterate} from \"../train/iterate\";\n\nconst _ = require(\"underscore\");\n\n\nexport namespace parse {\n    import LiveClipVirtual = live.LiveClipVirtual;\n    import PARSE = algorithm.PARSE;\n    import DERIVE = algorithm.DERIVE;\n    import MatrixIterator = iterate.MatrixIterator;\n    import NoteRenderable = note.NoteRenderable;\n\n    export interface Parsable {\n        choose(): boolean;\n\n        // TODO: annotation\n        get_best_candidate(list_candidate_note);\n    }\n\n    abstract class ParseTree {\n        root: TreeModel.Node<n.NoteRenderable>;\n\n        constructor() {\n\n        }\n\n        public get_root(): TreeModel.Node<n.NoteRenderable> {\n            return this.root\n        }\n    }\n\n    export class StructParse extends ParseTree {\n\n        root: TreeModel.Node<n.NoteRenderable>;\n\n        matrix_leaves: TreeModel.Node<n.NoteRenderable>[][][];\n\n        coords_roots: number[][]; // list of coordinates\n\n        history: number[][];\n\n        constructor(matrix) {\n            super();\n            this.matrix_leaves = matrix;\n            this.coords_roots = [];\n            this.history = [];\n        }\n\n        public get_notes_at_coord(coord: number[]) {\n            return this.matrix_leaves[coord[0]][coord[1]]\n        }\n\n        private static get_diff_index_start(notes_new: TreeModel.Node<n.Note>[], notes_old: TreeModel.Node<n.Note>[]): number {\n            let same_start, same_duration, index_start_diff;\n            for (let i=0; i < notes_old.length; i++) {\n                same_start = (notes_old[i].model.note.beat_start === notes_new[i].model.note.beat_start);\n                same_duration = (notes_old[i].model.note.beats_duration === notes_new[i].model.note.beats_duration);\n                if (!(same_start && same_duration)) {\n                    index_start_diff = i;\n                    break;\n                }\n            }\n\n            return index_start_diff;\n        }\n\n        private static get_diff_index_end(notes_new: TreeModel.Node<n.Note>[], notes_old: TreeModel.Node<n.Note>[]): number {\n            let same_start, same_duration, index_end_diff;\n            for (let i=-1; i > -1 * (notes_new.length + 1); i--) {\n                same_start = (notes_new.slice(i)[0].model.note.beat_start === notes_old.slice(i)[0].model.note.beat_start);\n                same_duration = (notes_new.slice(i)[0].model.note.beats_duration === notes_old.slice(i)[0].model.note.beats_duration);\n                if (!(same_start && same_duration)) {\n                    index_end_diff = i;\n                    break;\n                }\n            }\n\n            // NB: add one in order to use with array slice, unless of course the index is -1, then you'll access the front of the array\n            return index_end_diff;\n        }\n\n        // TODO: complete return method signature\n        get_diff_index_notes(notes_parent: TreeModel.Node<n.Note>[], notes_child: TreeModel.Node<n.Note>[]): number[] {\n            return [\n                StructParse.get_diff_index_start(notes_child, notes_parent),\n                StructParse.get_diff_index_end(notes_child, notes_parent)\n            ];\n        };\n\n        // public finish_parse() {\n        //     for (let col of this.matrix_leaves[0]) {\n        //         for (let note of col) {\n        //             this.add_layer(\n        //                 [this.root],\n        //                 [note],\n        //                 -1\n        //             )\n        //         }\n        //     }\n        // }\n\n        public set_root(note) {\n            let coord_root = [-1];\n            this.history.push(coord_root);\n            this.root = NoteRenderable.from_note(note, coord_root)\n        }\n\n        public set_notes(notes: TreeModel.Node<n.Note>[], coord) {\n            this.history.push(coord);\n            this.matrix_leaves[coord[0]][coord[1]] = notes.map((note) => {\n                return NoteRenderable.from_note(note, coord)\n            });\n        }\n\n        public get_history(): number[][] {\n            return this.history\n        }\n\n        // TODO: holy fuck refactor\n        public add(notes_user_input, coord_notes_current, algorithm): void {\n\n            // let coord_notes_previous;\n            let coords_notes_previous: number[][] = [];\n\n            let notes_user_input_renderable = notes_user_input.map((note) => {\n                return NoteRenderable.from_note(note, coord_notes_current)\n            });\n\n            if (coord_notes_current[0] === -1) {\n                this.root = notes_user_input_renderable[0]\n            } else {\n                this.matrix_leaves[coord_notes_current[0]][coord_notes_current[1]] = notes_user_input_renderable;\n            }\n\n            this.history.push(coord_notes_current);\n\n            switch (algorithm.get_name()) {\n                case PARSE: {\n                    if (coord_notes_current[0] === -1) {\n                        for (let i in this.matrix_leaves[0]) {\n                            coords_notes_previous.push([0, Number(i)])\n                        }\n                    } else {\n                        coords_notes_previous = MatrixIterator.get_coords_below([coord_notes_current[0], coord_notes_current[1]]);\n                    }\n\n                    for (let coord_to_grow of coords_notes_previous) {\n                        let notes_below = this.matrix_leaves[coord_to_grow[0]][coord_to_grow[1]];\n                        let notes_children = notes_below;\n                        this.add_layer(\n                            notes_user_input_renderable,\n                            notes_children,\n                            -1\n                        );\n                    }\n                    break;\n                }\n                case DERIVE: {\n                    // if (coord_notes_current[0] === -1) {\n                    //     this.root = notes_user_input_renderable\n                    // } else {\n                    //     this.matrix_leaves[coord_notes_current[0]][coord_notes_current[1]] = notes_user_input_renderable;\n                    // }\n                    // coord_notes_previous = MatrixIterator.get_coords_above([coord_notes_current[0], coord_notes_current[1]]);\n                    // let notes_above = this.matrix_leaves[coord_notes_previous[0]][coord_notes_previous[1]];\n                    // let notes_parent = notes_above;\n                    // this.add_layer(\n                    //     notes_parent,\n                    //     notes_user_input_renderable,\n                    //     -1\n                    // );\n                    break;\n                }\n                default: {\n                    throw 'adding notes to parse tree failed'\n                }\n            }\n\n            // remove references to old leaves\n            for (let coord_notes_previous of coords_notes_previous) {\n                this.coords_roots = this.coords_roots.filter((x) => {\n                    return !(x[0] === coord_notes_previous[0] && x[1] === coord_notes_previous[1])\n                });\n            }\n\n            // add references to new leaves\n            this.coords_roots.push(\n                coord_notes_current\n            )\n        }\n\n        private add_layer(notes_parent: TreeModel.Node<n.NoteRenderable>[], notes_child: TreeModel.Node<n.NoteRenderable>[], index_new_layer: number): void {\n\n            var note_parent_best, b_successful;\n\n            for (let node of notes_child) {\n                note_parent_best = node.model.note.get_best_candidate(notes_parent);\n                b_successful = node.model.note.choose();\n                if (b_successful) {\n                    node.model.id = index_new_layer;\n                    note_parent_best.addChild(node);\n                }\n            }\n        };\n    }\n}"]}