{"version":3,"file":"parse.js","sourceRoot":"","sources":["parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {note as n, note} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {algorithm} from \"../train/algorithm\";\n\nconst _ = require(\"underscore\");\n\n\nexport namespace parse {\n    import NoteRenderable = note.NoteRenderable;\n    import Parsed = algorithm.Parsed;\n\n    export interface Parsable {\n        choose(): boolean;\n\n        // TODO: annotation\n        get_best_candidate(list_candidate_note);\n    }\n\n    export abstract class ParseTree {\n        root: TreeModel.Node<n.NoteRenderable>;\n\n        coords_roots: number[][]; // list of coordinates\n\n        constructor() {\n\n        }\n\n        public get_root(): TreeModel.Node<n.NoteRenderable> {\n            return this.root\n        }\n\n        public set_root(root: TreeModel.Node<n.NoteRenderable>): void {\n            this.root = root;\n            this.coords_roots = [[-1]]\n        }\n\n        public static create_root_from_segments(segments): TreeModel.Node<n.NoteRenderable> {\n            let note_segment_last = segments[segments.length - 1].get_note();\n\n            let note_segment_first = segments[0].get_note();\n\n            let tree: TreeModel = new TreeModel();\n\n            return tree.parse(\n                {\n                    id: -1, // TODO: hashing scheme for clip id and beat start\n                    note: new n.NoteRenderable(\n                        note_segment_last.model.note.pitch,\n                        note_segment_first.model.note.beat_start,\n                        (note_segment_last.model.note.beat_start + note_segment_last.model.note.beats_duration) - note_segment_first.model.note.beat_start,\n                        note_segment_last.model.note.velocity,\n                        note_segment_last.model.note.muted,\n                        [-1]\n                    ),\n                    children: [\n\n                    ]\n                }\n            );\n        }\n\n        public static add_layer(notes_parent: TreeModel.Node<n.NoteRenderable>[], notes_child: TreeModel.Node<n.NoteRenderable>[], index_new_layer: number): void {\n\n            var note_parent_best, b_successful;\n\n            for (let node of notes_child) {\n                note_parent_best = node.model.note.get_best_candidate(notes_parent);\n                b_successful = node.model.note.choose();\n                if (b_successful) {\n                    node.model.id = index_new_layer;\n                    note_parent_best.addChild(node);\n                }\n            }\n        };\n    }\n\n    export class StructParse extends ParseTree {\n\n        root: TreeModel.Node<n.NoteRenderable>;\n\n        matrix_leaves: TreeModel.Node<n.NoteRenderable>[][][];\n\n        // theoretically we can render these regions to the user\n        regions_renderable: number[][];\n\n        constructor(matrix) {\n            super();\n            this.matrix_leaves = matrix;\n            this.coords_roots = [];\n            this.regions_renderable = [];\n        }\n\n        public get_notes_at_coord(coord: number[]) {\n            if (coord[0] === -1) {\n                return [this.root]\n            } else {\n                return this.matrix_leaves[coord[0]][coord[1]]\n            }\n        }\n\n        // TODO: don't delete these 3 until we're sure we don't use them\n        // private static get_diff_index_start(notes_new: TreeModel.Node<n.Note>[], notes_old: TreeModel.Node<n.Note>[]): number {\n        //     let same_start, same_duration, index_start_diff;\n        //     for (let i=0; i < notes_old.length; i++) {\n        //         same_start = (notes_old[i].model.note.beat_start === notes_new[i].model.note.beat_start);\n        //         same_duration = (notes_old[i].model.note.beats_duration === notes_new[i].model.note.beats_duration);\n        //         if (!(same_start && same_duration)) {\n        //             index_start_diff = i;\n        //             break;\n        //         }\n        //     }\n        //\n        //     return index_start_diff;\n        // }\n\n        // private static get_diff_index_end(notes_new: TreeModel.Node<n.Note>[], notes_old: TreeModel.Node<n.Note>[]): number {\n        //     let same_start, same_duration, index_end_diff;\n        //     for (let i=-1; i > -1 * (notes_new.length + 1); i--) {\n        //         same_start = (notes_new.slice(i)[0].model.note.beat_start === notes_old.slice(i)[0].model.note.beat_start);\n        //         same_duration = (notes_new.slice(i)[0].model.note.beats_duration === notes_old.slice(i)[0].model.note.beats_duration);\n        //         if (!(same_start && same_duration)) {\n        //             index_end_diff = i;\n        //             break;\n        //         }\n        //     }\n        //\n        //     // NB: add one in order to use with array slice, unless of course the index is -1, then you'll access the front of the array\n        //     return index_end_diff;\n        // }\n\n        // private static get_diff_index_notes(notes_parent: TreeModel.Node<n.Note>[], notes_child: TreeModel.Node<n.Note>[]): number[] {\n        //     return [\n        //         StructParse.get_diff_index_start(notes_child, notes_parent),\n        //         StructParse.get_diff_index_end(notes_child, notes_parent)\n        //     ];\n        // };\n\n        public set_root(note) {\n            let coord_root = [-1];\n            this.regions_renderable.push(coord_root);\n            this.root = NoteRenderable.from_note(note, coord_root)\n        }\n\n        public get_regions_renderable(): number[][] {\n            return this.regions_renderable\n        }\n\n        // TODO: never set the root in this manner - maybe that's how we can get around the if-else barrage\n        public add(notes_user_input, coord_notes_current, algorithm: Parsed): void {\n\n            let notes_user_input_renderable = notes_user_input.map((note) => {\n                return NoteRenderable.from_note(note, coord_notes_current)\n            });\n\n            this.matrix_leaves[coord_notes_current[0]][coord_notes_current[1]] = notes_user_input_renderable;\n\n            this.regions_renderable.push(coord_notes_current);\n\n            let coords_notes_to_grow = algorithm.get_coords_notes_to_grow(coord_notes_current);\n\n            for (let coord_to_grow of coords_notes_to_grow) {\n\n                let notes_to_grow = this.get_notes_at_coord(coord_to_grow);\n\n                algorithm.grow_layer(notes_user_input_renderable, notes_to_grow);\n            }\n\n            this.coords_roots = algorithm.update_roots(\n                this.coords_roots,\n                coords_notes_to_grow,\n                coord_notes_current\n            );\n        }\n    }\n}"]}