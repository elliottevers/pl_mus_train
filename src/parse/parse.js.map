{"version":3,"file":"parse.js","sourceRoot":"","sources":["parse.ts"],"names":[],"mappings":";;AACA,qCAA6C;AAC7C,sCAAyC;AAMzC,IAAM,CAAC,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC;AAGhC,IAAiB,KAAK,CAuQrB;AAvQD,WAAiB,KAAK;IAUlB;QAKI,mBAAY,IAA4B,EAAE,kBAAkB;YACxD,IAAI,IAAI,GAAc,IAAI,SAAS,EAAE,CAAC;YAEtC,8CAA8C;YAE9C,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAClB;gBACI,EAAE,EAAE,CAAC,CAAC;gBACN,IAAI,EAAE,IAAI,WAAC,CAAC,cAAc;gBACtB,uBAAuB;gBACvB,uBAAuB;gBACvB,uBAAuB;gBACvB,uBAAuB;gBACvB,uBAAuB;gBACvB,qBAAqB;gBACrB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,EACrB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,EAC1B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,cAAc,EAC9B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,EACxB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,EACrB,kBAAkB,CACrB;gBACD,QAAQ,EAAE,EAET;aACJ,CACJ,CAAA;QACL,CAAC;QAED,yCAAyC;QACzC,uFAAuF;QACvF,4DAA4D;QAC5D,aAAa;QACb,IAAI;QACJ,EAAE;QACF,0HAA0H;QAC1H,uDAAuD;QACvD,iDAAiD;QACjD,oGAAoG;QACpG,+GAA+G;QAC/G,gDAAgD;QAChD,oCAAoC;QACpC,qBAAqB;QACrB,YAAY;QACZ,QAAQ;QACR,EAAE;QACF,+BAA+B;QAC/B,IAAI;QACJ,EAAE;QACF,wHAAwH;QACxH,qDAAqD;QACrD,6DAA6D;QAC7D,sHAAsH;QACtH,iIAAiI;QACjI,gDAAgD;QAChD,kCAAkC;QAClC,qBAAqB;QACrB,YAAY;QACZ,QAAQ;QACR,EAAE;QACF,mIAAmI;QACnI,6BAA6B;QAC7B,IAAI;QACJ,EAAE;QACF,4CAA4C;QAC5C,kHAAkH;QAClH,eAAe;QACf,qEAAqE;QACrE,kEAAkE;QAClE,SAAS;QACT,KAAK;QACL,EAAE;QACK,4BAAQ,GAAf;YACI,OAAM;QACV,CAAC;QA6KL,gBAAC;IAAD,CAAC,AA5PD,IA4PC;IA5PY,eAAS,YA4PrB,CAAA;AACL,CAAC,EAvQgB,KAAK,GAAL,aAAK,KAAL,aAAK,QAuQrB","sourcesContent":["import {segment} from \"../segment/segment\";\nimport {note as n, note} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {log} from \"../log/logger\";\nimport {utils} from \"../utils/utils\";\nimport {live} from \"../live/live\";\nimport {clip as c} from \"../clip/clip\";\n\nconst _ = require(\"underscore\");\n\n\nexport namespace parse {\n    import LiveClipVirtual = live.LiveClipVirtual;\n\n    export interface Parsable {\n        choose(): boolean;\n\n        // TODO: annotation\n        get_best_candidate(list_candidate_note);\n    }\n\n    export class ParseTree {\n        // matrix_clip: LiveClipVirtual[][];\n\n        root: TreeModel.Node<n.NoteRenderable>;\n\n        constructor(note: TreeModel.Node<n.Note>, coordinates_matrix) {\n            let tree: TreeModel = new TreeModel();\n\n            // let splitted = messages[i_mess].split(' ');\n\n            this.root = tree.parse(\n                {\n                    id: -1, // TODO: hashing scheme for clip id and beat start\n                    note: new n.NoteRenderable(\n                        // Number(splitted[0]),\n                        // Number(splitted[1]),\n                        // Number(splitted[2]),\n                        // Number(splitted[3]),\n                        // Number(splitted[4]),\n                        // coordinates_matrix\n                        note.model.note.pitch,\n                        note.model.note.beat_start,\n                        note.model.note.beats_duration,\n                        note.model.note.velocity,\n                        note.model.note.muted,\n                        coordinates_matrix\n                    ),\n                    children: [\n\n                    ]\n                }\n            )\n        }\n\n        // // TODO: we actually have to implement\n        // public static add(input_user, list_parse_tree, iterator_matrix_train): ParseTree[] {\n        //     let coord = iterator_matrix_train.get_coord_current()\n        //     return\n        // }\n        //\n        // private static get_diff_index_start(notes_new: TreeModel.Node<n.Note>[], notes_old: TreeModel.Node<n.Note>[]): number {\n        //     let same_start, same_duration, index_start_diff;\n        //     for (let i=0; i < notes_old.length; i++) {\n        //         same_start = (notes_old[i].model.note.beat_start === notes_new[i].model.note.beat_start);\n        //         same_duration = (notes_old[i].model.note.beats_duration === notes_new[i].model.note.beats_duration);\n        //         if (!(same_start && same_duration)) {\n        //             index_start_diff = i;\n        //             break;\n        //         }\n        //     }\n        //\n        //     return index_start_diff;\n        // }\n        //\n        // private static get_diff_index_end(notes_new: TreeModel.Node<n.Note>[], notes_old: TreeModel.Node<n.Note>[]): number {\n        //     let same_start, same_duration, index_end_diff;\n        //     for (let i=-1; i > -1 * (notes_new.length + 1); i--) {\n        //         same_start = (notes_new.slice(i)[0].model.note.beat_start === notes_old.slice(i)[0].model.note.beat_start);\n        //         same_duration = (notes_new.slice(i)[0].model.note.beats_duration === notes_old.slice(i)[0].model.note.beats_duration);\n        //         if (!(same_start && same_duration)) {\n        //             index_end_diff = i;\n        //             break;\n        //         }\n        //     }\n        //\n        //     // NB: add one in order to use with array slice, unless of course the index is -1, then you'll access the front of the array\n        //     return index_end_diff;\n        // }\n        //\n        // // TODO: complete return method signature\n        // get_diff_index_notes(notes_parent: TreeModel.Node<n.Note>[], notes_child: TreeModel.Node<n.Note>[]): number[] {\n        //     return [\n        //         ParseTree.get_diff_index_start(notes_child, notes_parent),\n        //         ParseTree.get_diff_index_end(notes_child, notes_parent)\n        //     ];\n        // };\n        //\n        public get_root(): TreeModel.Node<n.NoteRenderable> {\n            return\n        }\n        //\n        // private add_first_layer(notes: TreeModel.Node<n.Note>[], index_new_layer: number): void {\n        //     // var note_parent_best, b_successful;\n        //\n        //     for (let node of notes) {\n        //         node.model.id = index_new_layer;\n        //         this.root_parse_tree.addChild(node);\n        //     }\n        // }\n        //\n        // // NB: only works top down currently\n        // // private add_layer(notes_parent: TreeModel.Node<n.Note>[], notes_child: TreeModel.Node<n.Note>[]): TreeModel.Node<n.Note>[] {\n        // private add_layer(notes_parent: TreeModel.Node<n.Note>[], notes_child: TreeModel.Node<n.Note>[], index_new_layer: number): void {\n        //\n        //     var note_parent_best, b_successful;\n        //\n        //     for (let node of notes_child) {\n        //         note_parent_best = node.model.note.get_best_candidate(notes_parent);\n        //         b_successful = node.model.note.choose();\n        //         if (b_successful) {\n        //             node.model.id = index_new_layer;\n        //             note_parent_best.addChild(node);\n        //         }\n        //     }\n        // };\n        //\n        // private update_leaves(leaves: TreeModel.Node<n.Note>[]) {\n        //     // find leaves in parse/derive beat interval\n        //\n        //     // splice them with their children\n        //     let leaves_spliced = this.leaves;\n        //     let children_to_insert, i_leaf_to_splice;\n        //     for (let leaf of leaves) {\n        //         // find index of leaf to \"splice\"\n        //         // always splice only one leaf\n        //         // find corresponding leaf in leaves_spliced\n        //         children_to_insert = [];\n        //         if (leaf.hasChildren()) {\n        //             i_leaf_to_splice = _.findIndex(leaves_spliced, (leaf_to_splice)=>{\n        //                 // assuming monophony, i.e., no overlap\n        //                 return leaf_to_splice.model.note.beat_start === leaf.model.note.beat_start\n        //             });\n        //\n        //             let beat_end_children_greatest = -Infinity, beat_start_children_least = Infinity;\n        //\n        //             for (let child of leaf.children) {\n        //                 if (child.model.note.get_beat_end() > beat_end_children_greatest) {\n        //                     beat_end_children_greatest = child.model.note.get_beat_end();\n        //                 }\n        //                 if (child.model.note.beat_start < beat_start_children_least) {\n        //                     beat_start_children_least = child.model.note.beat_start;\n        //                 }\n        //                 children_to_insert.push(child);\n        //             }\n        //\n        //             if (false) {\n        //                 // if (leaf.model.note.get_beat_end() > beat_end_children_greatest || leaf.model.note.beat_start < beat_start_children_least) {\n        //                 leaves_spliced.splice(\n        //                     i_leaf_to_splice,\n        //                     0,\n        //                     ...children_to_insert\n        //                 )\n        //             } else {\n        //                 leaves_spliced.splice(\n        //                     i_leaf_to_splice,\n        //                     1,\n        //                     ...children_to_insert\n        //                 )\n        //             }\n        //             // leaves_spliced.splice(\n        //             //     i_leaf_to_splice,\n        //             //     1,\n        //             //     ...children_to_insert\n        //             // )\n        //         }\n        //     }\n        //\n        //     this.leaves = leaves_spliced;\n        // }\n        //\n        // public insert(notes: TreeModel.Node<n.Note>[]) {\n        //     if (this.iterator_tree.get_index_current() == 1) {\n        //         this.set_root(notes[0])\n        //     } else {\n        //         this.grow(\n        //             notes,\n        //             this.iterator_tree.get_breadth_current();\n        //         this.iterator_tree.get_depth_current();\n        //     )\n        //     }\n        // }\n        //\n        // get_notes_leaves(): TreeModel.Node<n.Note>[] {\n        //     return this.leaves;\n        // }\n        //\n        // set_root(note_root: TreeModel.Node<n.Note>) {\n        //     let clip_dao_virtual = new LiveClipVirtual([note_root]);\n        //\n        //     let clip_virtual = new c.Clip(clip_dao_virtual);\n        //\n        //     clip_virtual.clip_dao.beat_start = note_root.model.note.beat_start;\n        //\n        //     clip_virtual.clip_dao.beat_end = note_root.model.note.get_beat_end();\n        //\n        //     this.add_clip(clip_virtual);\n        //\n        //     note_root.model.id = 0;  // index of first clip\n        //\n        //     this.root_parse_tree = note_root;\n        //\n        //     this.leaves = [note_root];\n        // }\n        //\n        // // struct\n        // elaborate(elaboration: TreeModel.Node<n.Note>[], beat_start: number, beat_end: number, index_layer: number): void {\n        //\n        //     if (index_layer + 1 > this.clips.length) {\n        //         let clip_dao_virtual = new LiveClipVirtual(elaboration);\n        //\n        //         clip_dao_virtual.beat_start = elaboration[0].model.note.beat_start;\n        //         clip_dao_virtual.beat_end = elaboration[elaboration.length - 1].model.note.get_beat_end();\n        //\n        //         let clip_virtual = new c.Clip(clip_dao_virtual);\n        //         this.add_clip(clip_virtual);\n        //     } else {\n        //         let clip_last = this.clips[this.clips.length - 1];\n        //         clip_last.clip_dao.beat_end = elaboration[elaboration.length - 1].model.note.get_beat_end();\n        //         clip_last.set_notes(elaboration);\n        //     }\n        //\n        //     let leaves_within_interval = this.get_leaves_within_interval(beat_start, beat_end);\n        //\n        //     if (index_layer == 1) {\n        //         this.add_first_layer(elaboration, this.clips.length - 1)\n        //     } else {\n        //         this.add_layer(leaves_within_interval, elaboration, this.clips.length - 1);\n        //     }\n        //\n        //     this.update_leaves(leaves_within_interval);\n        // }\n        //\n        // // struct\n        // splice_notes(notes_subset: TreeModel.Node<n.Note>[], clip: c.Clip, interval_beats: number[]): TreeModel.Node<n.Note>[] {\n        //     let notes_clip = _.cloneDeep(clip.get_notes_within_loop_brackets());\n        //     let num_notes_to_replace = this.get_order_of_note_at_beat_end(notes_clip, interval_beats[1]) - this.get_order_of_note_at_beat_start(notes_clip, interval_beats[0]) + 1;\n        //     let index_start = this.get_note_index_at_beat(interval_beats[0], notes_clip);\n        //     notes_clip.splice(index_start, num_notes_to_replace, ...notes_subset);\n        //     return notes_clip\n        // }\n        //\n        // // struct\n        // get_note_index_at_beat(beat: number, notes: TreeModel.Node<n.Note>[]): number {\n        //     let val =  _.findIndex(notes, (node)=>{\n        //         return node.model.note.beat_start === beat\n        //     });\n        //     return val;\n        // }\n        //\n        // // struct\n        // get_leaves_within_interval(beat_start: number, beat_end: number): TreeModel.Node<n.Note>[] {\n        //     let val =  this.leaves.filter((node) =>{\n        //         // return node.model.note.beat_start >= beat_start && node.model.note.get_beat_end() <= beat_end\n        //         return (node.model.note.beat_start >= beat_start && node.model.note.beat_start <= beat_end) ||\n        //             (node.model.note.get_beat_end() <= beat_end && node.model.note.get_beat_end() >= beat_start) ||\n        //             (node.model.note.get_beat_end() >= beat_end && node.model.note.beat_start <= beat_start)\n        //\n        //     });\n        //     // this.logger.log(CircularJSON.stringify(this.leaves));\n        //     return val;\n        // }\n\n    }\n}"]}