{"version":3,"file":"history.js","sourceRoot":"","sources":["history.ts"],"names":[],"mappings":";;AAKA,gDAA6C;AAI7C,IAAiB,OAAO,CAsHvB;AAtHD,WAAiB,OAAO;IAIpB,IAAO,MAAM,GAAG,qBAAS,CAAC,MAAM,CAAC;IACjC,IAAO,OAAO,GAAG,qBAAS,CAAC,OAAO,CAAC;IACnC,IAAO,KAAK,GAAG,qBAAS,CAAC,KAAK,CAAC;IAC/B,IAAO,MAAM,GAAG,qBAAS,CAAC,MAAM,CAAC;IAcjC,gCAAgC;IAChC,gCAAgC;IAChC,EAAE;IACF,sBAAsB;IACtB,EAAE;IACF,QAAQ;IACR,EAAE;IACF,yBAAyB;IACzB,EAAE;IACF,QAAQ;IACR,IAAI;IAEJ;QAAA;QAoBA,CAAC;QAnBiB,iDAAyB,GAAvC,UAAwC,SAAS,EAAE,QAAQ;YACvD,QAAQ,SAAS,CAAC,QAAQ,EAAE,EAAE;gBAC1B,KAAK,MAAM,CAAC,CAAC;oBACT,OAAO,IAAI,aAAa,EAAE,CAAC;iBAC9B;gBACD,KAAK,OAAO,CAAC,CAAC;oBACV,OAAO,IAAI,aAAa,EAAE,CAAC;iBAC9B;gBACD,KAAK,KAAK,CAAC,CAAC;oBACR,OAAO,IAAI,YAAY,EAAE,CAAC;iBAC7B;gBACD,KAAK,MAAM,CAAC,CAAC;oBACT,OAAO,IAAI,YAAY,EAAE,CAAC;iBAC7B;gBACD,OAAO,CAAC,CAAC;oBACL,MAAM,4BAA4B,CAAA;iBACrC;aACJ;QACL,CAAC;QACL,8BAAC;IAAD,CAAC,AApBD,IAoBC;IApBY,+BAAuB,0BAoBnC,CAAA;IAQD;QAGI;QAEA,CAAC;QAED,iCAAU,GAAV,UAAW,MAAM;YACb,IAAI,CAAC,YAAY,GAAG,MAAM,CAAA;QAC9B,CAAC;QAED,0BAAG,GAAH,UAAI,KAA6B,EAAE,KAAe;YAC9C,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;QAClD,CAAC;QAED,0BAAG,GAAH,UAAI,KAAe;YACf,OAAO,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QACjD,CAAC;QACL,mBAAC;IAAD,CAAC,AAlBD,IAkBC;IAlBY,oBAAY,eAkBxB,CAAA;IAED;QAII,qCAAqC;QACrC,4BAA4B;QAC5B,kCAAkC;QAClC,uDAAuD;QACvD,QAAQ;QACR,sCAAsC;QACtC,IAAI;QAEJ;QAEA,CAAC;QAED,kCAAU,GAAV,UAAW,MAAM;YACb,IAAI,CAAC,WAAW,GAAG,MAAM,CAAA;QAC7B,CAAC;QAED,qFAAqF;QACrF,4EAA4E;QAC5E,IAAI;QACJ,EAAE;QACF,+DAA+D;QAC/D,iDAAiD;QACjD,IAAI;QAEJ,+EAA+E;QAC/E,6DAA6D;QAC7D,4DAA4D;QAC5D,IAAI;QAEJ,2BAAG,GAAH,UAAI,eAAyB,EAAE,KAAe;YAC1C,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC;QAC3D,CAAC;QACL,oBAAC;IAAD,CAAC,AApCD,IAoCC;IApCY,qBAAa,gBAoCzB,CAAA;AACL,CAAC,EAtHgB,OAAO,GAAP,eAAO,KAAP,eAAO,QAsHvB","sourcesContent":["import {note, note as n} from \"../note/note\";\nimport {log} from \"../log/logger\";\nimport TreeModel = require(\"tree-model\");\nimport {utils} from \"../utils/utils\";\nimport {serialize} from \"../serialize/serialize\";\nimport {algorithm} from \"../train/algorithm\";\nimport {target} from \"../target/target\";\nimport {trainer} from \"../train/trainer\";\n\nexport namespace history {\n\n    import serialize_target_sequence = serialize.serialize_target_sequence;\n    import deserialize_target_sequence = serialize.deserialize_target_sequence;\n    import DETECT = algorithm.DETECT;\n    import PREDICT = algorithm.PREDICT;\n    import PARSE = algorithm.PARSE;\n    import DERIVE = algorithm.DERIVE;\n    import Subtarget = target.Subtarget;\n    import MatrixIterator = trainer.MatrixIterator;\n    import Target = target.Target;\n    import Note = note.Note;\n\n    export type TypeSubtarget = TreeModel.Node<n.Note>;\n\n    export type TypeTarget = TypeSubtarget[]\n\n    export type TypeSequenceNote = TreeModel.Node<n.Note>[];\n\n    export type TypeSequenceTarget = TypeTarget[]\n\n    // export class SequenceTarget {\n    //     data: TypeSequenceTarget;\n    //\n    //     constructor() {\n    //\n    //     }\n    //\n    //     get_subtargets() {\n    //\n    //     }\n    // }\n\n    export class FactoryHistoryUserInput {\n        public static create_history_user_input(algorithm, segments) {\n            switch (algorithm.get_name()) {\n                case DETECT: {\n                    return new TargetHistory();\n                }\n                case PREDICT: {\n                    return new TargetHistory();\n                }\n                case PARSE: {\n                    return new PhaseHistory();\n                }\n                case DERIVE: {\n                    return new PhaseHistory();\n                }\n                default: {\n                    throw 'factory history user input'\n                }\n            }\n        }\n    }\n\n    export interface HistoryUserInput {\n        set_matrix(matrix): void;\n        add(struct, coord): void;\n        // get(coord);\n    }\n\n    export class PhaseHistory implements HistoryUserInput {\n        matrix_notes: TreeModel.Node<Note>[][][];\n\n        constructor() {\n\n        }\n\n        set_matrix(matrix) {\n            this.matrix_notes = matrix\n        }\n\n        add(notes: TreeModel.Node<Note>[], coord: number[]) {\n            this.matrix_notes[coord[0]][coord[1]] = notes;\n        }\n\n        get(coord: number[]): TreeModel.Node<n.Note>[] {\n            return this.matrix_notes[coord[0]][coord[1]];\n        }\n    }\n\n    export class TargetHistory implements HistoryUserInput {\n\n        matrix_data: Target[][][];\n\n        // constructor(algorithm, segments) {\n        //     let matrix_data = [];\n        //     for (let i=0; i < 1; i++) {\n        //         matrix_data[i] = new Array(segments.length);\n        //     }\n        //     this.matrix_data = matrix_data;\n        // }\n\n        constructor() {\n\n        }\n\n        set_matrix(matrix) {\n            this.matrix_data = matrix\n        }\n\n        // set_sequence_target(sequence_target: TypeSequenceTarget, coord_matrix: number[]) {\n        //     this.matrix_data[coord_matrix[0]][coord_matrix[1]] = sequence_target;\n        // }\n        //\n        // get_sequence_target(i_height, i_width): TypeSequenceTarget {\n        //     return this.matrix_data[i_height][i_width]\n        // }\n\n        // add_subtarget(subtarget: Subtarget, iterator_matrix_train: MatrixIterator) {\n        //     let coord = iterator_matrix_train.get_coord_current();\n        //     this.matrix_data[coord[0]][coord[1]] = subtarget.note\n        // }\n\n        add(target_sequence: Target[], coord: number[]) {\n            this.matrix_data[coord[0]][coord[1]] = target_sequence;\n        }\n    }\n}"]}