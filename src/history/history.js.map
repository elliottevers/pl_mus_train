{"version":3,"file":"history.js","sourceRoot":"","sources":["history.ts"],"names":[],"mappings":"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","sourcesContent":["import {note as n} from \"../note/note\";\nimport {log} from \"../log/logger\";\nimport TreeModel = require(\"tree-model\");\nimport {utils} from \"../utils/utils\";\nimport {serialize} from \"../serialize/serialize\";\nimport {algorithm} from \"../train/algorithm\";\nimport {target} from \"../target/target\";\nimport {trainer} from \"../train/trainer\";\n\nexport namespace history {\n\n    import serialize_target_sequence = serialize.serialize_target_sequence;\n    import deserialize_target_sequence = serialize.deserialize_target_sequence;\n    import DETECT = algorithm.DETECT;\n    import PREDICT = algorithm.PREDICT;\n    import PARSE = algorithm.PARSE;\n    import DERIVE = algorithm.DERIVE;\n    import Subtarget = target.Subtarget;\n    import MatrixIterator = trainer.MatrixIterator;\n    import Target = target.Target;\n\n    export type TypeSubtarget = TreeModel.Node<n.Note>;\n\n    export type TypeTarget = TypeSubtarget[]\n\n    export type TypeSequenceNote = TreeModel.Node<n.Note>[];\n\n    export type TypeSequenceTarget = TypeTarget[]\n\n    // export class SequenceTarget {\n    //     data: TypeSequenceTarget;\n    //\n    //     constructor() {\n    //\n    //     }\n    //\n    //     get_subtargets() {\n    //\n    //     }\n    // }\n\n    export class FactoryHistoryUserInput {\n        public static create_history_user_input(algorithm, segments) {\n            switch (algorithm.get_name()) {\n                case DETECT: {\n                    // return new TargetHistory(algorithm, segments);\n                    return new TargetHistory();\n                }\n                case PREDICT: {\n                    // return new TargetHistory(algorithm, segments);\n                    return new TargetHistory();\n                }\n                case PARSE: {\n                    throw 'parse not yet implemented'\n                }\n                case DERIVE: {\n                    throw 'detect not yet implemented'\n                }\n                default: {\n                    throw 'from factory user input'\n                }\n            }\n        }\n    }\n\n    export interface HistoryUserInput {\n        save(filename: string): void\n\n        load(filename: string): HistoryUserInput\n    }\n\n    export class TargetHistory implements HistoryUserInput {\n\n        matrix_data: Target[][][];\n\n        // constructor(algorithm, segments) {\n        //     let matrix_data = [];\n        //     for (let i=0; i < 1; i++) {\n        //         matrix_data[i] = new Array(segments.length);\n        //     }\n        //     this.matrix_data = matrix_data;\n        // }\n\n        constructor() {\n\n        }\n\n        set_matrix(matrix) {\n            this.matrix_data = matrix\n        }\n\n\n        // set_sequence_target(sequence_target: TypeSequenceTarget, coord_matrix: number[]) {\n        //     this.matrix_data[coord_matrix[0]][coord_matrix[1]] = sequence_target;\n        // }\n        //\n        // get_sequence_target(i_height, i_width): TypeSequenceTarget {\n        //     return this.matrix_data[i_height][i_width]\n        // }\n\n        // add_subtarget(subtarget: Subtarget, iterator_matrix_train: MatrixIterator) {\n        //     let coord = iterator_matrix_train.get_coord_current();\n        //     this.matrix_data[coord[0]][coord[1]] = subtarget.note\n        // }\n\n        add_sequence_target(target_sequence: Target[], coord: number[]) {\n            this.matrix_data[coord[0]][coord[1]] = target_sequence;\n        }\n\n        save(filename) {\n            // let data_serializable = this.matrix_data as any;\n            // for (let i_row in this.matrix_data) {\n            //     for (let i_col in this.matrix_data[Number(i_row)]) {\n            //         data_serializable[Number(i_row)][Number(i_col)] = serialize_target_sequence(\n            //             this.matrix_data[Number(i_row)][Number(i_col)]\n            //         )\n            //     }\n            // }\n            //\n            // let f = new File(filename,\"write\",\"JSON\");\n            //\n            // if (f.isopen) {\n            //     post(\"saving session\");\n            //     f.writestring(JSON.stringify(data_serializable));\n            //     f.close();\n            // } else {\n            //     post(\"could not save session\");\n            // }\n        }\n\n        public load(filename): HistoryUserInput {\n            // let f = new File(filename, \"read\",\"JSON\");\n            // let a, data_deserialized;\n            //\n            // if (f.isopen) {\n            //     post(\"reading file\");\n            //     // @ts-ignore\n            //     while ((a = f.readline()) != null) {\n            //         let data_deserialized = JSON.parse(a) as any;\n            //     }\n            //     f.close();\n            // } else {\n            //     post(\"could not open file\");\n            // }\n            //\n            // // let data_deserialized = data_serialized as any;\n            // //\n            // // for (let i_row in data_serialized) {\n            // //     for (let i_col in data_serialized[Number(i_row)]) {\n            // //         data_deserialized[Number(i_row)][Number(i_col)] = ParseMatrix.deserialize(data_serialized[Number(i_row)][Number(i_col)])\n            // //     }\n            // // }\n            // //\n            // // return data_deserialized\n            //\n            // for (let i_row in this.matrix_data) {\n            //     for (let i_col in this.matrix_data[Number(i_row)]) {\n            //         data_deserialized[Number(i_row)][Number(i_col)] = deserialize_target_sequence(\n            //             data_deserialized[Number(i_row)][Number(i_col)]\n            //         )\n            //     }\n            // }\n            //\n            // return data_deserialized\n            return\n        }\n    }\n\n    // export type TypeHistoryList = SegmentTargetable[]\n    //\n    // export type TypeHistoryMatrix = SegmentTargetable[][]\n\n    // export class ParseHistory implements HistoryUserInput {\n    //\n    //     // data: TreeModel.Node<note.Note>[][][];\n    //\n    //     matrix_data: SequenceNote[][];\n    //\n    //     logger: Logger;\n    //\n    //     constructor(algorithm, segments) {\n    //         let matrix_data = [];\n    //         for (let i=0; i < algorithm.get_depth(); i++) {\n    //             if (i == 0) {\n    //                 matrix_data[i] = new Array(1); // root of tree\n    //             } else {\n    //                 matrix_data[i] = new Array(segments.length);\n    //             }\n    //         }\n    //         this.matrix_data = matrix_data;\n    //     }\n    //\n    //     save(filename) {\n    //         let data_serializable = this.data as any;\n    //         for (let i_row in this.data) {\n    //             for (let i_col in this.data[Number(i_row)]) {\n    //                 data_serializable[Number(i_row)][Number(i_col)] = ParseMatrix.serialize(this.data[Number(i_row)][Number(i_col)])\n    //             }\n    //         }\n    //\n    //         let f = new File(filename,\"write\",\"JSON\");\n    //\n    //         if (f.isopen) {\n    //             post(\"saving session\");\n    //             f.writestring(JSON.stringify(data_serializable));\n    //             f.close();\n    //         } else {\n    //             post(\"could not save session\");\n    //         }\n    //     }\n    //\n    //     public load(filename): HistoryUserInput {\n    //         let f = new File(filename, \"read\",\"JSON\");\n    //         let a, data_serialized;\n    //\n    //         if (f.isopen) {\n    //             post(\"reading file\");\n    //             // @ts-ignore\n    //             while ((a = f.readline()) != null) {\n    //                 data_serialized = JSON.parse(a)\n    //             }\n    //             f.close();\n    //         } else {\n    //             post(\"could not open file\");\n    //         }\n    //\n    //         // let data_deserialized = data_serialized as any;\n    //         //\n    //         // for (let i_row in data_serialized) {\n    //         //     for (let i_col in data_serialized[Number(i_row)]) {\n    //         //         data_deserialized[Number(i_row)][Number(i_col)] = ParseMatrix.deserialize(data_serialized[Number(i_row)][Number(i_col)])\n    //         //     }\n    //         // }\n    //\n    //         return data_deserialized\n    //     }\n    // }\n}"]}