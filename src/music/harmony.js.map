{"version":3,"file":"harmony.js","sourceRoot":"","sources":["harmony.ts"],"names":[],"mappings":";;AAAA,qCAAuC;AACvC,sCAAyC;AAEzC,IAAM,CAAC,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC;AAEhC,IAAiB,OAAO,CAoFvB;AApFD,WAAiB,OAAO;IAGpB;QAAA;QAgFA,CAAC;QA/EiB,aAAK,GAAnB,UAAoB,KAA+B;YACnD,wBAAwB;YACxB,+BAA+B;YAC/B,EAAE;YACF,gCAAgC;YAChC,6BAA6B;YAC7B,EAAE;YACF,yEAAyE;YACzE,4CAA4C;YAC5C,6CAA6C;YAC7C,EAAE;YACF,kBAAkB;YAClB,EAAE;YACF,iCAAiC;YACjC,EAAE;YACF,oCAAoC;YACpC,6BAA6B;YAC7B,yCAAyC;YACzC,uCAAuC;YACvC,gBAAgB;YAChB,qBAAqB;YACrB,oBAAoB;YACpB,mBAAmB;YACnB,KAAK;YACL,EAAE;YACF,mGAAmG;YACnG,EAAE;YACF,0CAA0C;YAC1C,2EAA2E;YAC3E,2BAA2B;YAC3B,EAAE;YACF,oBAAoB;YAChB,OAAM;QACV,CAAC;QAEa,mBAAW,GAAzB,UAA0B,KAA+B;YACrD,SAAS,OAAO,CAAC,WAAW,EAAC,WAAW;gBACpC,IAAI,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,GAAG,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU;oBACrE,OAAO,CAAC,CAAC,CAAC;gBACd,IAAI,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,GAAG,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU;oBACrE,OAAO,CAAC,CAAC;gBACb,OAAO,CAAC,CAAC;YACb,CAAC;YAED,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAEpB,IAAI,YAAY,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,YAAY,EAAE,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC;YAEtG,IAAI,mBAAmB,GAAG,YAAY,GAAC,KAAK,CAAC,MAAM,CAAC;YAEpD,IAAI,YAAY,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC;YAElD,IAAI,gBAAgB,GAA6B,EAAE,CAAC;YAEpD,IAAI,IAAI,GAAc,IAAI,SAAS,EAAE,CAAC;YAEtC,KAAiB,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK,EAAE;gBAAnB,IAAI,IAAI,cAAA;gBACT,gBAAgB,CAAC,IAAI,CACjB,IAAI,CAAC,KAAK,CACN;oBACI,EAAE,EAAE,CAAC,CAAC;oBACN,IAAI,EAAE,IAAI,WAAC,CAAC,IAAI,CACZ,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,EACrB,YAAY,EACZ,mBAAmB,EACnB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,EACxB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CACxB;oBACD,QAAQ,EAAE,EAET;iBACJ,CACJ,CACJ,CAAC;gBACF,YAAY,GAAG,YAAY,GAAG,mBAAmB,CAAA;aACpD;YAED,OAAO,gBAAgB,CAAC;QAC5B,CAAC;QACL,cAAC;IAAD,CAAC,AAhFD,IAgFC;IAhFY,eAAO,UAgFnB,CAAA;AACL,CAAC,EApFgB,OAAO,GAAP,eAAO,KAAP,eAAO,QAoFvB","sourcesContent":["import {note as n} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {target} from \"../target/target\";\nconst _ = require('underscore');\n\nexport namespace harmony {\n    import Target = target.Target;\n\n    export class Harmony {\n        public static group(notes: TreeModel.Node<n.Note>[]): TreeModel.Node<n.Note>[][] {\n        //     groups_notes = []\n        //     unique_onsets_beats = []\n        //\n        //     def get_beat_start(note):\n        //     return note.beat_start\n        //\n        //     for beat_start, group_note in groupby(notes_live, get_beat_start):\n        //     groups_notes.append(list(group_note))\n        //     unique_onsets_beats.append(beat_start)\n        //\n        //     chords = []\n        //\n        //     for group in groups_notes:\n        //\n        //     chord = music21.chord.Chord([\n        //         music21.note.Note(\n        //             pitch=music21.pitch.Pitch(\n        //                 midi=note_live.pitch\n        //             )\n        //         ).name for\n        //         note_live\n        //         in group\n        // ])\n        //\n        // # TODO: this makes the assumption that all notes in the group have the same offsets and duration\n        //\n        //     chord.offset = group[-1].beat_start\n        //     chord.duration = music21.duration.Duration(group[-1].beats_duration)\n        //     chords.append(chord)\n        //\n        //     return chords\n            return\n        }\n\n        public static monophonify(notes: TreeModel.Node<n.Note>[]): TypeTarget {\n            function compare(note_former,note_latter) {\n                if (note_former.model.note.beat_start < note_latter.model.note.beat_start)\n                    return -1;\n                if (note_former.model.note.beat_start > note_latter.model.note.beat_start)\n                    return 1;\n                return 0;\n            }\n\n            notes.sort(compare);\n\n            let length_beats = notes[notes.length - 1].model.note.get_beat_end() - notes[0].model.note.beat_start;\n\n            let duration_monophonic = length_beats/notes.length;\n\n            let beat_current = notes[0].model.note.beat_start;\n\n            let notes_monophonic: TreeModel.Node<n.Note>[] = [];\n\n            let tree: TreeModel = new TreeModel();\n\n            for (let note of notes) {\n                notes_monophonic.push(\n                    tree.parse(\n                        {\n                            id: -1, // TODO: hashing scheme for clip id and beat start\n                            note: new n.Note(\n                                note.model.note.pitch,\n                                beat_current,\n                                duration_monophonic,\n                                note.model.note.velocity,\n                                note.model.note.muted\n                            ),\n                            children: [\n\n                            ]\n                        }\n                    )\n                );\n                beat_current = beat_current + duration_monophonic\n            }\n\n            return notes_monophonic;\n        }\n    }\n}\n"]}