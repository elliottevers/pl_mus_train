{"version":3,"file":"serialize.js","sourceRoot":"","sources":["serialize.ts"],"names":[],"mappings":"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","sourcesContent":["import {target} from \"../target/target\";\nimport {note} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {trainer} from \"../train/trainer\";\nimport {file} from \"../io/file\";\nimport {algorithm} from \"../train/algorithm\";\n\nexport namespace serialize {\n\n    export let serialize_note = (note: TreeModel.Node<note.Note>) => {\n        return JSON.stringify(note.model);\n    };\n\n    export let deserialize_note = (note_serialized) => {\n        if (note_serialized === null) {\n            return null\n        }\n        let tree = new TreeModel();\n        return tree.parse(JSON.parse(note_serialized));\n    };\n\n    export let serialize_sequence_note = (notes) => {\n        if (!notes) {\n            return null\n        }\n        let notes_serialized = [];\n        for (let note of notes) {\n            notes_serialized.push(serialize_note(note))\n        }\n        return notes_serialized\n    };\n\n    import Subtarget = target.Subtarget;\n\n    export let serialize_subtarget = (subtarget: Subtarget) => {\n        let subtarget_serialized: any;\n        // TODO: fix\n        // let subtarget_serialized = subtarget;\n        subtarget_serialized = subtarget;\n        subtarget_serialized.note = serialize_note(subtarget.note);\n        return subtarget_serialized;\n    };\n\n    export let deserialize_subtarget = (subtarget_serialized) => {\n        let subtarget_deserialized = subtarget_serialized;\n        subtarget_deserialized.note = deserialize_note(subtarget_serialized.note);\n        return subtarget_deserialized;\n    };\n\n    // import SequenceTarget = history.SequenceTarget;\n\n    export let serialize_target_sequence = (sequence_target) => {\n        let sequence_target_serialized = sequence_target;\n        for (let i_target in sequence_target) {\n            let subtargets = sequence_target[Number(i_target)].iterator_subtarget.subtargets;\n            for (let i_subtarget in subtargets) {\n                let subtarget = subtargets[Number(i_subtarget)];\n                sequence_target_serialized[Number(i_target)][Number(i_subtarget)] = serialize_subtarget(subtarget)\n            }\n        }\n        return sequence_target_serialized;\n    };\n\n    // TODO: deserialize\n    export let deserialize_target_sequence = (sequence_target_serialized) => {\n        let sequence_target_deserialized = sequence_target_serialized;\n\n        for (let i_target in sequence_target_serialized) {\n            let subtargets = sequence_target_serialized[Number(i_target)].get_subtargets();\n            for (let i_subtarget in subtargets) {\n                let subtarget = subtargets[Number(i_subtarget)];\n                sequence_target_deserialized[Number(i_target)][Number(i_subtarget)] = deserialize_subtarget(subtarget)\n            }\n        }\n        return sequence_target_deserialized;\n    };\n}\n\nexport namespace freeze {\n    import Trainer = trainer.Trainer;\n    import serialize_target_sequence = serialize.serialize_target_sequence;\n    import to_json = file.to_json;\n    import DETECT = algorithm.DETECT;\n    import PREDICT = algorithm.PREDICT;\n    import PARSE = algorithm.PARSE;\n    import DERIVE = algorithm.DERIVE;\n    import serialize_sequence_note = serialize.serialize_sequence_note;\n\n    export class TrainFreezer {\n\n        env: string;\n\n        constructor(env: string) {\n            this.env = env;\n        }\n\n        public freeze(trainer: Trainer, filepath: string) {\n            let data_serializable = trainer.history_user_input.matrix_data as any;\n\n            switch (trainer.algorithm.get_name()) {\n                case DETECT: {\n                    for (let i_row in trainer.history_user_input.matrix_data) {\n                        for (let i_col in trainer.history_user_input.matrix_data[Number(i_row)]) {\n                            data_serializable[Number(i_row)][Number(i_col)] = serialize_target_sequence(\n                                trainer.history_user_input.matrix_data[Number(i_row)][Number(i_col)]\n                            )\n                        }\n                    }\n                    break;\n                }\n                case PREDICT: {\n                    // TODO\n                    break;\n                }\n                case PARSE: {\n                    for (let i_row in trainer.history_user_input.matrix_data) {\n                        for (let i_col in trainer.history_user_input.matrix_data[Number(i_row)]) {\n                            data_serializable[Number(i_row)][Number(i_col)] = serialize_sequence_note(\n                                trainer.history_user_input.matrix_data[Number(i_row)][Number(i_col)]\n                            )\n                        }\n                    }\n                    break;\n                }\n                case DERIVE: {\n                    // TODO\n                    break;\n                }\n            }\n\n            to_json(data_serializable, filepath, this.env)\n        }\n    }\n}\n\nexport namespace thaw {\n    import Trainer = trainer.Trainer;\n    import deserialize_target_sequence = serialize.deserialize_target_sequence;\n    import from_json = file.from_json;\n    import Note = note.Note;\n    import PREDICT = algorithm.PREDICT;\n    import PARSE = algorithm.PARSE;\n    import serialize_target_sequence = serialize.serialize_target_sequence;\n    import serialize_sequence_note = serialize.serialize_sequence_note;\n    import DERIVE = algorithm.DERIVE;\n    import DETECT = algorithm.DETECT;\n    import deserialize_note = serialize.deserialize_note;\n\n    export class TrainThawer {\n        env: string;\n\n        constructor(env: string) {\n            this.env = env;\n        }\n\n        public thaw(filepath: string, config): Trainer {\n\n            let trainer;\n\n            let matrix_deserialized = from_json(filepath, config['env']);\n\n            trainer =  new Trainer(\n                config['window'],\n                config['user_input_handler'],\n                config['algorithm'],\n                config['clip_user_input'],\n                config['clip_user_input_synchronous'],\n                config['clip_target'],\n                config['song'],\n                config['segments'],\n                config['messenger']\n            );\n\n            trainer.init(\n                true\n            );\n\n            switch (config['algorithm'].get_name()) {\n                case DETECT: {\n                    let notes = [];\n                    // TODO: this is only valid for forward iteration\n                    for (let row of matrix_deserialized) {\n                        for (let col of row) {\n                            if (col === null) {\n                                continue;\n                            }\n                            for (let sequence_target of col) {\n                                for (let note of sequence_target.iterator_subtarget.subtargets) {\n                                    notes.push(note)\n                                }\n                            }\n                        }\n                    }\n                    let notes_parsed = notes.map((obj)=>{return JSON.parse(obj.note)});\n\n                    let tree: TreeModel = new TreeModel();\n\n                    for (let note_parsed of notes_parsed) {\n                        let note_recovered = tree.parse(\n                            {\n                                id: -1, // TODO: hashing scheme for clip id and beat start\n                                note: new Note(\n                                    note_parsed.note.pitch,\n                                    note_parsed.note.beat_start,\n                                    note_parsed.note.beats_duration,\n                                    note_parsed.note.velocity,\n                                    note_parsed.note.muted\n                                ),\n                                children: [\n\n                                ]\n                            }\n                        );\n                        trainer.accept_input(\n                            [note_recovered]\n                        );\n                    }\n\n                    trainer.pause();\n\n                    break;\n                }\n                case PREDICT: {\n                    break;\n                }\n                case PARSE: {\n                    let input_left = true;\n\n                    while (input_left) {\n                        let coord_current = trainer.iterator_matrix_train.get_coord_current();\n                        trainer.accept_input(\n                            matrix_deserialized[coord_current[0]][coord_current[1]].map((note_serialized) => {\n                                return deserialize_note(note_serialized)\n                            })\n                        );\n\n                        if (trainer.iterator_matrix_train.done) {\n                            input_left = false;\n                        }\n                    }\n\n                    trainer.pause();\n\n                    break;\n                }\n                case DERIVE: {\n                    break;\n                }\n            }\n\n\n            return trainer;\n        }\n    }\n}"]}