{"version":3,"file":"thaw.js","sourceRoot":"","sources":["thaw.ts"],"names":[],"mappings":";;AAAA,mCAAgC;AAEhC,yCAAsC;AAGtC,IAAiB,IAAI,CAgLpB;AAhLD,WAAiB,IAAI;IACjB,IAAO,SAAS,GAAG,WAAI,CAAC,SAAS,CAAC;IAClC,IAAO,gBAAgB,GAAG,qBAAS,CAAC,gBAAgB,CAAC;IAGrD;QAAA;QA0KA,CAAC;QAxKiB,sBAAU,GAAxB,UAAyB,QAAgB,EAAE,GAAW;YAClD,sDAAsD;YAEtD,IAAI,KAAK,GAAG,EAAE,CAAC;YACf,iDAAiD;YACjD,KAAgB,UAA4C,EAA5C,KAAA,WAAW,CAAC,iBAAiB,CAAC,QAAQ,EAAE,GAAG,CAAC,EAA5C,cAA4C,EAA5C,IAA4C,EAAE;gBAAzD,IAAI,GAAG,SAAA;gBACR,KAAgB,UAAG,EAAH,WAAG,EAAH,iBAAG,EAAH,IAAG,EAAE;oBAAhB,IAAI,GAAG,YAAA;oBACR,IAAI,GAAG,KAAK,IAAI,EAAE;wBACd,SAAS;qBACZ;oBACD,KAA8B,UAAG,EAAH,WAAG,EAAH,iBAAG,EAAH,IAAG,EAAE;wBAA9B,IAAI,iBAAiB,YAAA;wBACtB,KAAK,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAA;qBAChC;iBACJ;aACJ;YAED,OAAO,KAAK,CAAA;QAChB,CAAC;QAEa,6BAAiB,GAA/B,UAAgC,QAAgB,EAAE,GAAW;YACzD,IAAI,mBAAmB,GAAG,SAAS,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;YAEnD,IAAI,WAAW,GAAG,mBAAmB,CAAC;YAEtC,iDAAiD;YACjD,KAAK,IAAI,KAAK,IAAI,mBAAmB,EAAE;gBACnC,IAAI,GAAG,GAAG,mBAAmB,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;gBAC7C,KAAK,IAAI,KAAK,IAAI,GAAG,EAAE;oBACnB,IAAI,GAAG,GAAG,mBAAmB,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;oBAC5D,IAAI,GAAG,KAAK,IAAI,EAAE;wBACd,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,CAAC;wBAC/C,SAAS;qBACZ;oBAED,IAAI,KAAK,GAAG,EAAE,CAAC;oBAEf,KAA4B,UAAG,EAAH,WAAG,EAAH,iBAAG,EAAH,IAAG,EAAE;wBAA5B,IAAI,eAAe,YAAA;wBACpB,KAAK,CAAC,IAAI,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC,CAAA;qBAChD;oBAED,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,GAAG,KAAK,CAAA;iBACpD;aACJ;YAED,OAAO,WAAW,CAAA;QACtB,CAAC;QA2HL,kBAAC;IAAD,CAAC,AA1KD,IA0KC;IA1KY,gBAAW,cA0KvB,CAAA;AACL,CAAC,EAhLgB,IAAI,GAAJ,YAAI,KAAJ,YAAI,QAgLpB","sourcesContent":["import {file} from \"../io/file\";\nimport TreeModel = require(\"tree-model\");\nimport {serialize} from \"./serialize\";\nimport {note} from \"../note/note\";\n\nexport namespace thaw {\n    import from_json = file.from_json;\n    import deserialize_note = serialize.deserialize_note;\n    import Note = note.Note;\n\n    export class TrainThawer {\n\n        public static thaw_notes(filepath: string, env: string): TreeModel.Node<Note>[] {\n            // let matrix_deserialized = from_json(filepath, env);\n\n            let notes = [];\n            // TODO: this is only valid for forward iteration\n            for (let row of TrainThawer.thaw_notes_matrix(filepath, env)) {\n                for (let col of row) {\n                    if (col === null) {\n                        continue;\n                    }\n                    for (let note_deserialized of col) {\n                        notes.push(note_deserialized)\n                    }\n                }\n            }\n\n            return notes\n        }\n\n        public static thaw_notes_matrix(filepath: string, env: string) {\n            let matrix_deserialized = from_json(filepath, env);\n\n            let matrix_test = matrix_deserialized;\n\n            // TODO: this is only valid for forward iteration\n            for (let i_row in matrix_deserialized) {\n                let row = matrix_deserialized[Number(i_row)];\n                for (let i_col in row) {\n                    let col = matrix_deserialized[Number(i_row)][Number(i_col)];\n                    if (col === null) {\n                        matrix_test[Number(i_row)][Number(i_col)] = [];\n                        continue;\n                    }\n\n                    let notes = [];\n\n                    for (let note_serialized of col) {\n                        notes.push(deserialize_note(note_serialized))\n                    }\n\n                    matrix_test[Number(i_row)][Number(i_col)] = notes\n                }\n            }\n\n            return matrix_test\n        }\n\n        // public thaw(filepath: string, config): Trainer {\n        //\n        //     let trainer;\n        //\n        //     let matrix_deserialized = from_json(filepath, config['env']);\n        //\n        //     let logger = new Logger(config['env']);\n        //\n        //     logger.log(JSON.stringify(matrix_deserialized));\n        //\n        //     trainer =  new Trainer(\n        //         config['window'],\n        //         config['user_input_handler'],\n        //         config['trainable'],\n        //         config['track_target'],\n        //         config['track_user_input'],\n        //         config['song'],\n        //         config['segments'],\n        //         config['messenger'],\n        //         true\n        //     );\n        //\n        //     trainer.advance(\n        //\n        //     );\n        //\n        //     switch (config['trainable'].get_name()) {\n        //         case DETECT: {\n        //             let notes = [];\n        //             // TODO: this is only valid for forward iteration\n        //             for (let row of matrix_deserialized) {\n        //                 for (let col of row) {\n        //                     if (col === null) {\n        //                         continue;\n        //                     }\n        //                     for (let note_serialized of col) {\n        //                         notes.push(deserialize_note(note_serialized))\n        //                     }\n        //                 }\n        //             }\n        //\n        //             let notes_parsed = notes;\n        //\n        //             let tree: TreeModel = new TreeModel();\n        //\n        //             for (let note_parsed of notes_parsed) {\n        //                 let note_recovered = tree.parse(\n        //                     {\n        //                         id: -1, // TODO: hashing scheme for clip id and beat start\n        //                         note: new Note(\n        //                             note_parsed.model.note.pitch,\n        //                             note_parsed.model.note.beat_start,\n        //                             note_parsed.model.note.beats_duration,\n        //                             note_parsed.model.note.velocity,\n        //                             note_parsed.model.note.muted\n        //                         ),\n        //                         children: [\n        //\n        //                         ]\n        //                     }\n        //                 );\n        //                 trainer.accept_input(\n        //                     [note_recovered]\n        //                 );\n        //             }\n        //\n        //             // trainer.pause();\n        //\n        //             break;\n        //         }\n        //         case PREDICT: {\n        //             break;\n        //         }\n        //         case PARSE: {\n        //             let input_left = true;\n        //\n        //             while (input_left) {\n        //                 let coord_current = trainer.iterator_matrix_train.get_coord_current();\n        //                 trainer.accept_input(\n        //                     matrix_deserialized[coord_current[0]][coord_current[1]].map((note_serialized) => {\n        //                         return deserialize_note(note_serialized)\n        //                     })\n        //                 );\n        //\n        //                 if (trainer.iterator_matrix_train.done) {\n        //                     input_left = false;\n        //                 }\n        //             }\n        //\n        //             // trainer.pause();\n        //\n        //             break;\n        //         }\n        //         // go until we find a segment without user input\n        //         case DERIVE: {\n        //             let input_left = true;\n        //\n        //             while (input_left) {\n        //\n        //                 let coord_current = trainer.iterator_matrix_train.get_coord_current();\n        //\n        //                 if (matrix_deserialized[coord_current[0]][coord_current[1]].length === 0) {\n        //                     input_left = false;\n        //                     continue\n        //                 }\n        //\n        //                 trainer.accept_input(\n        //                     matrix_deserialized[coord_current[0]][coord_current[1]]\n        //                 );\n        //             }\n        //\n        //             // trainer.pause();\n        //\n        //             break;\n        //         }\n        //     }\n        //\n        //     trainer.virtualized = false;\n        //\n        //     return trainer;\n        // }\n    }\n}"]}