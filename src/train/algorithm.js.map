{"version":3,"file":"algorithm.js","sourceRoot":"","sources":["algorithm.ts"],"names":[],"mappings":"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","sourcesContent":["import {note, note as n} from \"../note/note\";\nimport {clip as c} from \"../clip/clip\";\nimport {live} from \"../live/live\";\nimport TreeModel = require(\"tree-model\");\nimport {target} from \"../target/target\";\nimport {harmony} from \"../music/harmony\";\nimport {modes_texture} from \"../constants/constants\";\n\nexport namespace algorithm {\n    export let DETECT = 'detect';\n    export let PREDICT = 'predict';\n    export let PARSE = 'parse';\n    export let DERIVE = 'derive';\n\n    import LiveClipVirtual = live.LiveClipVirtual;\n    import Target = target.Target;\n    import TargetType = target.TargetType;\n    import Harmony = harmony.Harmony;\n    import TargetIterator = target.TargetIterator;\n\n    export interface Temporal {\n        determine_region_current\n\n        determine_region_past\n\n        determine_region_upcoming\n    }\n\n    export interface Targetable {\n        determine_targets\n    }\n\n    export interface Algorithm {\n        get_name(): string\n        get_depth(): number\n    }\n\n    abstract class Targeted {\n        public b_targeted(): boolean {\n            return true;\n        }\n    }\n\n    export class Detect extends Targeted implements Algorithm, Temporal, Targetable {\n        user_input_handler;\n\n        constructor(user_input_handler) {\n            this.user_input_handler = user_input_handler\n        }\n\n        public get_depth(): number {\n            return 1\n        }\n\n        public get_name(): string {\n            return DETECT\n        }\n\n        determine_targets(notes_segment_next: TreeModel.Node<n.Note>[]): TargetIterator {\n            if (this.user_input_handler.mode_texture === modes_texture.POLYPHONY) {\n\n                let chords_grouped: TreeModel.Node<n.Note>[][] = Harmony.group(\n                    notes_segment_next\n                );\n\n                let chords_monophonified: TreeModel.Node<n.Note>[][] = Harmony.monophonify(\n                    notes_segment_next\n                );\n\n                // Subtarget -> Subtarget Iterator -> Target -> Target Iterator\n\n                return chords_monophonified\n\n            } else if (this.user_input_handler.mode_texture === modes_texture.MONOPONY) {\n\n                let notes_grouped_trivial = [];\n\n                for (let note of notes_segment_next) {\n                    notes_grouped_trivial.push(note)\n                }\n\n                // Subtarget -> Subtarget Iterator -> Target -> Target Iterator\n\n                return notes_grouped_trivial\n\n            } else {\n                throw ['mode', this.mode, 'not supported'].join(' ')\n            }\n        }\n\n        pre_advance(clip_user_input) {\n\n        }\n    }\n\n    export class Predict extends Targeted implements Algorithm, Temporal, Targetable {\n\n        public get_name(): string {\n            return PREDICT\n        }\n\n        public get_depth(): number {\n            return 1\n        }\n\n        // TODO: put all calls to Clip in whatever class is a client to algorithms\n        // NB: there can be multiple targets per segment\n        // TODO: replace the notes in clip_target with these\n        determine_targets(notes_segment_next: TreeModel.Node<n.Note>[]): TargetType {\n            if (this.mode === modes.HARMONY) {\n\n                let chords_grouped: TreeModel.Node<n.Note>[][] = harmony.group(\n                    notes_segment_next\n                );\n\n                let chords_monophonified: TreeModel.Node<n.Note>[][] = harmony.monophonify(\n                    notes_segment_next\n                );\n\n                return chords_monophonified\n\n            } else if (this.mode === modes.MELODY) {\n\n                let notes_grouped_trivial = [];\n\n                for (let note of notes_segment_next) {\n                    notes_grouped_trivial.push(note)\n                }\n\n                return notes_grouped_trivial\n\n            } else {\n                throw ['mode', this.mode, 'not supported'].join(' ')\n            }\n        }\n\n\n        determine_region_current(notes_target_next): number[] {\n            return [\n                notes_target_next[0].model.note.beat_start,\n                notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n            ]\n        }\n\n        // set right interval\n        determine_region_past(notes_target_next): number {\n            return notes_target_next[0].model.note.beat_start\n        }\n\n        // set left interval\n        determine_region_upcoming(notes_target_next): number {\n            return notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n        }\n\n        pre_advance() {\n            //\n        }\n    }\n\n    export class Parse implements Algorithm, Temporal {\n\n        depth: number;\n\n        public get_name(): string {\n            return PARSE\n        }\n\n        public get_depth(): number {\n            return this.depth\n        }\n\n        set_depth(depth: number) {\n            this.depth = depth;\n        }\n\n        // happens after loop of first target is set\n        post_init(song, clip_user_input) {\n            song.set_overdub(1);\n\n            song.set_session_record(1);\n\n            clip_user_input.fire();\n        }\n\n        // happens after last target is guessed\n        pre_terminate(song, clip_user_input) {\n            song.set_overdub(0);\n\n            song.set_session_record(0);\n\n            clip_user_input.stop();\n        }\n\n    }\n\n    export class Derive implements Temporal {\n\n        depth: number;\n\n        public get_name(): string {\n            return DERIVE\n        }\n\n        public get_depth(): number {\n            return this.depth\n        }\n\n        set_depth(depth: number) {\n            this.depth = depth;\n        }\n\n        // happens after loop of first target is set\n        post_init(song, clip_user_input) {\n            song.set_overdub(1);\n\n            song.set_session_record(1);\n\n            clip_user_input.fire();\n        }\n\n        // happens after last target is guessed\n        pre_terminate(song, clip_user_input) {\n            song.set_overdub(0);\n\n            song.set_session_record(0);\n\n            clip_user_input.stop();\n        }\n\n        determine_region_current(notes_target_next): number[] {\n            return [\n                notes_target_next[0].model.note.beat_start,\n                notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n            ]\n        }\n\n        // set right interval\n        determine_region_past(notes_target_next): number {\n            return notes_target_next[0].model.note.beat_start\n        }\n\n        // set left interval\n        determine_region_upcoming(notes_target_next): number {\n            return notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n        }\n\n        accept(elaboration: TreeModel.Node<n.Note>[], i_depth: number, i_breadth: number): void {\n\n            this.struct_train.append(elaboration);\n\n            nextthis.iterator_train.next()\n\n            // if (index_layer + 1 > this.clips.length) {\n            //     let clip_dao_virtual = new LiveClipVirtual(elaboration);\n            //\n            //     clip_dao_virtual.beat_start = elaboration[0].model.note.beat_start;\n            //     clip_dao_virtual.beat_end = elaboration[elaboration.length - 1].model.note.get_beat_end();\n            //\n            //     let clip_virtual = new c.Clip(clip_dao_virtual);\n            //     this.add_clsip(clip_virtual);\n            // } else {\n            //     let clip_last = this.clips[this.clips.length - 1];\n            //     clip_last.clip_dao.beat_end = elaboration[elaboration.length - 1].model.note.get_beat_end();\n            //     clip_last.set_notes(elaboration);\n            // }\n            //\n            // let leaves_within_interval = this.get_leaves_within_interval(beat_start, beat_end);\n            //\n            // if (index_layer == 1) {\n            //     this.add_first_layer(elaboration, this.clips.length - 1)\n            // } else {\n            //     this.add_layer(leaves_within_interval, elaboration, this.clips.length - 1);\n            // }\n            //\n            // this.update_leaves(leaves_within_interval);\n        }\n\n    }\n\n    export class Harmonic {\n        transform(notes_target) {\n            function compare(note_former,note_latter) {\n                if (note_former.model.note.beat_start < note_latter.model.note.beat_start)\n                    return -1;\n                if (note_former.model.note.beat_start > note_latter.model.note.beat_start)\n                    return 1;\n                return 0;\n            }\n\n            notes_target.sort(compare);\n\n            let length_beats = notes_target[notes_target.length - 1].model.note.get_beat_end() - notes_target[0].model.note.beat_start\n\n            let duration_monophonic = length_beats/notes_target.length;\n\n            clip_user_input.set_notes(\n\n            )\n        }\n        // once a target is issued, take all notes and spread them out equidistantly with no overlap\n\n    }\n\n    export class Melodic {\n        // do nothing special\n    }\n}"]}