{"version":3,"file":"algorithm.js","sourceRoot":"","sources":["algorithm.ts"],"names":[],"mappings":"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","sourcesContent":["import {note, note as n} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {harmony} from \"../music/harmony\";\nimport {modes_texture} from \"../constants/constants\";\nimport {user_input} from \"../control/user_input\";\nimport {history} from \"../history/history\";\nimport {clip} from \"../clip/clip\";\nimport {parse} from \"../parse/parse\";\nimport {segment} from \"../segment/segment\";\nimport {track} from \"../track/track\";\nimport {window} from \"../render/window\";\nimport {iterate} from \"./iterate\";\nimport {message} from \"../message/messenger\";\nimport {target} from \"../target/target\";\nimport {live} from \"../live/live\";\nimport {scene} from \"../scene/scene\";\nimport {utils} from \"../utils/utils\";\n\nexport namespace algorithm {\n    export let DETECT = 'detect';\n    export let PREDICT = 'predict';\n    export let PARSE = 'parse';\n    export let DERIVE = 'derive';\n    export let FREESTYLE = 'freestyle';\n    import Harmony = harmony.Harmony;\n    import POLYPHONY = modes_texture.POLYPHONY;\n    import MONOPHONY = modes_texture.MONOPHONY;\n    import TypeSequenceTarget = history.TypeSequenceTarget;\n    import Clip = clip.Clip;\n    import Note = note.Note;\n    import ParseTree = parse.ParseTree;\n    import StructParse = parse.StructParse;\n    import Segment = segment.Segment;\n    import get_notes_on_track = track.get_notes_on_track;\n    import Window = window.Window;\n    import Track = track.Track;\n    import MatrixIterator = iterate.MatrixIterator;\n    import Messenger = message.Messenger;\n    import Subtarget = target.Subtarget;\n    import TargetIterator = target.TargetIterator;\n    import LiveApiJs = live.LiveApiJs;\n    import ClipDao = clip.ClipDao;\n    import Target = target.Target;\n    import FactoryMatrixObjectives = iterate.FactoryMatrixObjectives;\n\n    interface Temporal {\n        determine_region_present(notes_next)\n    }\n\n    interface Renderable {\n        initialize_render(window: Window, segments: Segment[], track_target: Track)\n        get_notes_in_region(target: Target, segment: Segment): TreeModel.Node<Note>[]\n    }\n\n    // interface that the trainer uses\n    export interface Trainable extends Temporal, Renderable {\n        depth: number;\n        b_parsed: boolean;\n        b_targeted: boolean;\n\n        get_name(): string\n        get_depth(): number\n        coord_to_index_clip(coord: number[]): number\n        initialize()\n        terminate()\n        stream_bounds(messenger: message.Messenger, subtarget_current: Subtarget, segment_current: Segment): void\n        advance()\n        unpause()\n        pause()\n        create_matrix_targets(segments: Segment[], notes_target_track: TreeModel.Node<Note>[])\n        create_struct_parse()\n\n        warrants_advance(\n            notes_user_input: TreeModel.Node<Note>[],\n            subtarget_current: Subtarget\n        ): boolean\n\n        postprocess_user_input(\n            notes_user_input: TreeModel.Node<Note>[],\n            subtarget_current: Subtarget\n        ): TreeModel.Node<Note>[]\n    }\n\n    // logic common to all algorithms\n    export abstract class SceneIterator {\n\n        // update the clips we'll be using to store user input and retrieve information about it\n        update_clips(clip_user_input_current: Clip, clip_user_input_synchronous_current: Clip): Clip[] {\n\n            let list_path_current_s = clip_user_input_synchronous_current.get_path().split(' ');\n            let index_clipslot_current_s = list_path_current_s[list_path_current_s.length - 2];\n            let list_path_next_s = list_path_current_s;\n\n            let list_path_current = clip_user_input_current.get_path().split(' ');\n            let index_clipslot_current = list_path_current[list_path_current.length - 2];\n            let list_path_next = list_path_current;\n\n            list_path_next_s[list_path_next_s.length - 2] = index_clipslot_current_s + 1;\n\n            let clip_user_input_synchronous_next = new Clip(\n                new ClipDao(\n                    new LiveApiJs(\n                        list_path_next_s.join(' ')\n                    ),\n                    new Messenger('max', 0)\n                )\n            );\n\n            list_path_next[list_path_next.length - 2] = index_clipslot_current + 1;\n\n            let clip_user_input_next = new Clip(\n                new ClipDao(\n                    new LiveApiJs(\n                        list_path_next.join(' ')\n                    ),\n                    new Messenger('max', 0),\n                    true,\n                    'clip_user_input'\n                )\n            );\n\n            clip_user_input_next.set_path_deferlow('set_path_clip_user_input');\n\n            return [clip_user_input_next, clip_user_input_synchronous_next]\n        }\n\n        advance_scene(segment_current: Segment, clip_user_input_current: Clip, clip_user_input_synchronous_current: Clip) {\n            segment_current.scene.fire(true);\n            this.update_clips(clip_user_input_current, clip_user_input_synchronous_current)\n        }\n\n        advance(messenger: message.Messenger, subtarget_current: target.Subtarget, segment_current: segment.Segment) {\n            this.advance_scene(segment_current, clip_user_input_current, clip_user_input_synchronous_current);\n            this.stream_bounds(messenger, subtarget_current, segment_current)\n        }\n\n        protected abstract stream_bounds(messenger: Messenger, subtarget_current: Subtarget, segment_current: Segment)\n    }\n\n    // interface common to both parse and derive, but have different implementations\n    export interface Parsable extends Trainable {\n        initialize_parse(struct_parse, segments, track_target)\n        finish_parse(struct_parse: StructParse, segments: Segment[]): void;\n        determine_parents()\n        determine_children()\n        update_roots(coords_roots_previous: number[][], coords_notes_to_grow: number[][], coord_notes_current: number[])\n        get_coords_notes_to_grow(coords_note_input_current): number[][]\n        grow_layer(notes_user_input_renderable, notes_to_grow)\n    }\n\n    // interface common to both detect and predict, but have different implementations\n    export interface Targetable extends Trainable {\n        determine_targets(notes_in_segment: TreeModel.Node<Note>[])\n        postprocess_subtarget()\n    }\n\n    // logic common to detect and predict\n    abstract class Targeted extends SceneIterator implements Targetable {\n        public b_targeted: boolean;\n\n        determine_targets(notes_segment_next: TreeModel.Node<n.Note>[]): TypeSequenceTarget {\n            if (user_input_handler.mode_texture === POLYPHONY) {\n\n                let chords_grouped: TreeModel.Node<n.Note>[][] = Harmony.group(\n                    notes_segment_next\n                );\n\n                let chords_monophonified: TypeSequenceTarget = [];\n\n                for (let note_group of chords_grouped) {\n                    chords_monophonified.push(\n                        Harmony.monophonify(\n                            note_group\n                        )\n                    );\n                }\n\n                // return [chords_monophonified[Math.floor(Math.random() * chords_monophonified.length)]];\n                return [chords_monophonified[chords_monophonified.length/2]]\n\n            } else if (user_input_handler.mode_texture === MONOPHONY) {\n\n                let notes_grouped_trivial: TypeSequenceTarget = [];\n\n                for (let note of notes_segment_next) {\n                    notes_grouped_trivial.push([note])\n                }\n\n                // return notes_grouped_trivial\n                // TODO: let's put more weight towards the center of the measure\n                // return notes_grouped_trivial[Math.floor(Math.random() * notes_grouped_trivial.length)];\n                return [notes_grouped_trivial[notes_grouped_trivial.length/2]]\n\n            } else {\n                throw ['texture mode', user_input_handler.mode_texture, 'not supported'].join(' ')\n            }\n        }\n\n        public get_depth(): number {\n            return 1\n        }\n\n        coord_to_index_clip(coord: number[]): number {\n            return 0;\n        }\n\n        create_struct_parse() {\n            return null\n        }\n\n        public determine_region_present(notes_target_next): number[] {\n            return [\n                notes_target_next[0].model.note.beat_start,\n                notes_target_next[0].model.note.get_beat_end()\n            ]\n        }\n\n        get_notes_in_region(target: target.Target, segment: segment.Segment) {\n            return target.iterator_subtarget.subtargets.map((subtarget) => {\n                return subtarget.note\n            })\n        }\n\n        initialize() {\n            // TODO: add logic\n        }\n\n        protected abstract initialize_render(window: Window, segments: Segment[], track_target: Track)\n\n        pause(song) {\n            song.start()\n        }\n\n        postprocess_user_input(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current: target.Subtarget): TreeModel.Node<note.Note>[] {\n            return [subtarget_current.note];\n        }\n\n        protected abstract postprocess_subtarget()\n\n        terminate() {\n            // TODO: add logic\n        }\n\n        pause(song) {\n            song.stop()\n        }\n\n        warrants_advance(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current): boolean {\n            return utils.remainder(notes_user_input[0].model.note.pitch, 12) === utils.remainder(subtarget_current.note.model.note.pitch, 12)\n        }\n\n        public create_matrix_targets(segments: Segment[], notes_target_track: TreeModel.Node<Note>[]): TargetIterator[][] {\n\n            let matrix_targets = FactoryMatrixObjectives.create_matrix_objectives(\n                this,\n                segments\n            );\n\n            // TODO: use 'filter' here\n            // this.clip_target.load_notes_within_markers();\n\n            for (let i_segment in segments) {\n                let segment = segments[Number(i_segment)];\n\n                let notes_in_segment = notes_target_track.filter(\n                    node => node.model.note.beat_start >= segment.get_endpoints_loop()[0] && node.model.note.get_beat_end() <= segment.get_endpoints_loop()[1]\n                );\n\n                let sequence_targets = this.determine_targets(\n                    notes_in_segment\n                );\n\n                // set the note as muted for predict\n                // TODO: do we actually use the user input clip for prediction?  Isn't it just for parsing/deriving to store input and overdub?\n                for (let target of sequence_targets) {\n                    for (let subtarget of target) {\n\n                        let subtarget_processed = this.postprocess_subtarget(\n                            subtarget\n                        );\n\n                        clip_user_input.remove_notes(\n                            subtarget_processed.model.note.beat_start,\n                            0,\n                            subtarget_processed.model.note.get_beat_end(),\n                            128\n                        );\n\n                        clip_user_input.set_notes(\n                            [subtarget_processed]\n                        )\n                    }\n                }\n\n                matrix_targets[0][Number(i_segment)] = TargetIterator.from_sequence_target(sequence_targets);\n            }\n\n            return matrix_targets\n        }\n\n        private static stream_subtarget_bounds(messenger: message.Messenger, subtarget_current: Subtarget, segment_current: Segment) {\n            let ratio_bound_lower = (subtarget_current.note.model.note.beat_start - segment_current.get_endpoints_loop()[0])/(segment_current.get_endpoints_loop()[1] - segment_current.get_endpoints_loop()[0]);\n            let ratio_bound_upper = (subtarget_current.note.model.note.get_beat_end() - segment_current.get_endpoints_loop()[0])/(segment_current.get_endpoints_loop()[1] - segment_current.get_endpoints_loop()[0]);\n            messenger.message(['bounds', ratio_bound_lower, ratio_bound_upper])\n        }\n\n        stream_bounds(messenger: message.Messenger, subtarget_current: Subtarget, segment_current: Segment): void {\n            Targeted.stream_subtarget_bounds(messenger, subtarget_current, segment_current)\n        }\n\n        initialize_render(window, segments) {\n            // TODO: implement here because it should be the same for both algorithms\n        }\n\n        initialize(window, segments) {\n            this.create_matrix_targets(window, segments);\n            this.initialize_render(window, segments)\n        }\n    }\n\n    // logic common to parse and derive\n    abstract class Parsed extends SceneIterator implements Parsable {\n\n        public b_parsed: boolean;\n\n        depth: number;\n\n        protected abstract initialize_render(window: Window, segments: Segment[], track_target: Track)\n\n        public get_depth(): number {\n            return this.depth\n        }\n\n        set_depth(depth: number) {\n            this.depth = depth;\n        }\n\n        advance() {\n\n        }\n\n        coord_to_index_clip(coord: number[]): number {\n            if (coord[0] === -1) {\n                return 0\n            } else {\n                return coord[0] + 1\n            }\n        }\n\n        create_matrix_targets(segments: segment.Segment[], notes_target_track: TreeModel.Node<note.Note>[]) {\n            return []\n        }\n\n        create_struct_parse() {\n\n        }\n\n        determine_children() {\n\n        }\n\n        determine_parents() {\n\n        }\n\n        determine_region_present(notes_target_next): number[] {\n            return [\n                notes_target_next[0].model.note.beat_start,\n                notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n            ]\n        }\n\n        finish_parse(struct_parse: parse.StructParse, segments: segment.Segment[]): void {\n        }\n\n        protected abstract get_coords_notes_to_grow(coords_note_input_current): number[][]\n\n        get_notes_in_region(target: target.Target, segment: segment.Segment) {\n            return [segment.get_note()]\n        }\n\n        protected abstract grow_layer(notes_user_input_renderable, notes_to_grow)\n\n        initialize() {\n            // TODO: add logic\n        }\n\n        protected abstract initialize_parse(struct_parse, segments, track_target)\n\n\n        pause(song, clip_user_input) {\n            song.set_overdub(0);\n\n            song.set_session_record(0);\n\n            song.stop()\n        }\n\n        postprocess_user_input(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current: target.Subtarget): TreeModel.Node<note.Note>[] {\n            return notes_user_input;\n        }\n\n        stream_bounds(messenger: message.Messenger, subtarget_current: target.Subtarget, segment_current: segment.Segment): void {\n            Parsed.stream_segment_bounds(messenger)\n        }\n\n        private static stream_segment_bounds(messenger: Messenger) {\n            messenger.message(['bounds', 0, 1])\n        }\n\n        terminate(struct_parse: StructParse, segments: Segment[]) {\n            this.finish_parse(struct_parse, segments)\n        }\n\n        unpause(song, scene_current) {\n            song.set_overdub(1);\n\n            song.set_session_record(1);\n\n            scene_current.fire();\n        }\n\n        update_roots(coords_roots_previous: number[][], coords_notes_to_grow: number[][], coord_notes_current: number[]) {\n\n        }\n\n        warrants_advance(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current: target.Subtarget): boolean {\n            return true;\n        }\n    }\n\n    export class Detect extends Targeted {\n\n        constructor(user_input_handler) {\n            super(user_input_handler);\n        }\n\n        public get_name(): string {\n            return DETECT\n        }\n\n        postprocess_subtarget(note_subtarget) {\n            return note_subtarget\n        }\n    }\n\n    export class Predict extends Targeted {\n\n        public get_name(): string {\n            return PREDICT\n        }\n\n        postprocess_subtarget(note_subtarget) {\n            note_subtarget.model.note.muted = 1;\n            return note_subtarget;\n        }\n    }\n\n    export class Parse extends Parsed {\n\n        constructor(user_input_handler) {\n            super(user_input_handler);\n        }\n\n        public get_name(): string {\n            return PARSE\n        }\n\n        grow_layer(notes_user_input_renderable, notes_to_grow) {\n            ParseTree.add_layer(\n                notes_user_input_renderable,\n                notes_to_grow,\n                -1\n            )\n        }\n\n        initialize_track_user_input(segments: Segment[], track_target: Track, clip_user_input_initial: Clip) {\n            for (let i_segment in segments) {\n\n                let index_clip_slot_current = Number(i_segment);\n\n                let api_clip_target_synchronous = new LiveApiJs(\n                    track_target.track_dao.get_path().split(' ').concat(['clip_slots', index_clip_slot_current, 'clip']).join(' ')\n                );\n\n                let clip_target = new Clip(\n                    new ClipDao(\n                        api_clip_target_synchronous,\n                        new Messenger('max', 0)\n                    )\n                );\n\n                let notes = clip_target.get_notes(\n                    clip_target.get_loop_bracket_lower(),\n                    0,\n                    clip_target.get_loop_bracket_upper(),\n                    128\n                );\n\n                clip_user_input_initial.remove_notes(\n                    clip_target.get_loop_bracket_lower(),\n                    0,\n                    clip_target.get_loop_bracket_upper(),\n                    128\n                );\n\n                clip_user_input_initial.set_notes(\n                    notes\n                )\n            }\n        }\n\n        // add the root up to which we're going to parse\n        // add the segments as the layer below\n        // add the leaf notes\n        initialize_render(window: Window, segments: Segment[], track_target: Track) {\n            let notes_target_track = get_notes_on_track(\n                track_target.track_dao.get_path()\n            );\n\n            // first layer\n            window.add_note_to_clip_root(\n                StructParse.create_root_from_segments(\n                    segments\n                )\n            );\n\n            for (let i_segment in segments) {\n\n                let segment = segments[Number(i_segment)];\n\n                let note_segment = segment.get_note();\n\n                let coord_current_virtual_second_layer = [0, Number(i_segment)];\n\n                let notes_leaves = notes_target_track.filter(\n                    node => node.model.note.beat_start >= segment.get_endpoints_loop()[0] && node.model.note.get_beat_end() <= segment.get_endpoints_loop()[1]\n                );\n\n                let coord_current_virtual_leaves = [this.get_depth() - 1, Number(i_segment)];\n\n                // second layer\n                window.add_notes_to_clip(\n                    [note_segment],\n                    coord_current_virtual_second_layer,\n                    this\n                );\n\n                // leaves\n                window.add_notes_to_clip(\n                    notes_leaves,\n                    coord_current_virtual_leaves,\n                    this\n                )\n            }\n        }\n\n        update_roots(coords_roots_previous: number[][], coords_notes_previous: number[][], coord_notes_current: number[]) {\n            let coords_roots_new = [];\n\n            // remove references to old leaves\n            for (let coord_notes_previous of coords_notes_previous) {\n                coords_roots_new = coords_roots_new.concat(\n                    coords_roots_previous.filter((x) => {\n                        return !(x[0] === coord_notes_previous[0] && x[1] === coord_notes_previous[1])\n                    })\n                );\n            }\n\n            // add references to new leaves\n            coords_roots_new.push(\n                coord_notes_current\n            );\n        }\n\n        get_coords_notes_to_grow(coord_notes_input_current) {\n            return MatrixIterator.get_coords_below([coord_notes_input_current[0], coord_notes_input_current[1]]);\n        }\n\n        // adding the leaf notes to the actual parse tree\n        // DO NOT set the root or the segments as nodes immediately below that - do that at the end\n        // set the leaf notes as the notes in the target track\n        initialize_parse(struct_parse: StructParse, segments: Segment[], track_target: Track) {\n            // this is to set the leaves as the notes of the target clip\n\n            let notes_target_track = get_notes_on_track(\n                track_target.track_dao.get_path()\n            );\n\n            for (let i_segment in segments) {\n                let segment = segments[Number(i_segment)];\n\n                let notes = notes_target_track.filter(\n                    node => node.model.note.beat_start >= segment.get_endpoints_loop()[0] && node.model.note.get_beat_end() <= segment.get_endpoints_loop()[1]\n                );\n\n                let coord_current_virtual_leaf = [this.get_depth() - 1, Number(i_segment)];\n\n                struct_parse.add(\n                    notes,\n                    coord_current_virtual_leaf,\n                    this\n                );\n            }\n        }\n\n        finish_parse(struct_parse: StructParse, segments: Segment[]): void {\n\n            // make connections with segments\n            for (let i_segment in segments) {\n                let segment = segments[Number(i_segment)];\n                struct_parse.add(\n                    [segment.get_note()],\n                    [0, Number(i_segment)],\n                    this\n                );\n            }\n\n            struct_parse.set_root(\n                StructParse.create_root_from_segments(\n                    segments\n                )\n            );\n\n            // make connections with root\n            struct_parse.add(\n                [Note.from_note_renderable(struct_parse.get_root())],\n                [-1],\n                this\n            );\n        }\n    }\n\n    export class Derive extends Parsed {\n\n        public get_name(): string {\n            return DERIVE\n        }\n\n        get_coords_notes_to_grow(coords_note_input_current) {\n            return MatrixIterator.get_coords_above([coords_note_input_current[0], coords_note_input_current[1]])\n        }\n\n        grow_layer(notes_user_input_renderable, notes_to_grow) {\n            ParseTree.add_layer(\n                notes_to_grow,\n                notes_user_input_renderable,\n                -1\n            )\n        }\n\n        initialize_track_user_input(segments: Segment[], track_target: Track, clip_user_input_initial: Clip) {\n            return\n        }\n\n        initialize_parse(struct_parse: StructParse, segments: Segment[]) {\n            // add the root to the tree immediately\n            struct_parse.set_root(\n                ParseTree.create_root_from_segments(\n                    segments\n                )\n            );\n\n            for (let i_segment in segments) {\n\n                let segment = segments[Number(i_segment)];\n\n                let note = segment.get_note();\n\n                let coord_current_virtual = [0, Number(i_segment)];\n\n                struct_parse.add(\n                    [note],\n                    coord_current_virtual,\n                    this\n                );\n            }\n        }\n\n        initialize_render(window: Window, segments: Segment[], track_target: Track) {\n            // first layer (root)\n            window.add_note_to_clip_root(\n                StructParse.create_root_from_segments(\n                    segments\n                )\n            );\n\n            for (let i_segment in segments) {\n\n                let segment = segments[Number(i_segment)];\n\n                let note_segment = segment.get_note();\n\n                let coord_current_virtual_second_layer = [0, Number(i_segment)];\n\n                // second layer\n                window.add_notes_to_clip(\n                    [note_segment],\n                    coord_current_virtual_second_layer,\n                    this\n                );\n            }\n        }\n\n        finish_parse(struct_parse: StructParse, segments: Segment[]): void {\n            return\n        }\n    }\n}"]}