{"version":3,"file":"algorithm.js","sourceRoot":"","sources":["algorithm.ts"],"names":[],"mappings":"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","sourcesContent":["import {note as n} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {harmony} from \"../music/harmony\";\nimport {modes_texture} from \"../constants/constants\";\nimport {user_input} from \"../control/user_input\";\nimport {history} from \"../history/history\";\n\nexport namespace algorithm {\n    import UserInputHandler = user_input.UserInputHandler;\n    export let DETECT = 'detect';\n    export let PREDICT = 'predict';\n    export let PARSE = 'parse';\n    export let DERIVE = 'derive';\n    export let FREESTYLE = 'freestyle';\n    import Harmony = harmony.Harmony;\n    import POLYPHONY = modes_texture.POLYPHONY;\n    import MONOPHONY = modes_texture.MONOPHONY;\n    import TypeSequenceTarget = history.TypeSequenceTarget;\n    import TypeTarget = history.TypeTarget;\n\n    export interface Temporal {\n        determine_region_present\n    }\n\n    export interface Targetable {\n        determine_targets\n    }\n\n    export interface Algorithm {\n        get_name(): string\n        get_depth(): number\n        b_targeted(): boolean\n    }\n\n    abstract class Targeted {\n        user_input_handler: UserInputHandler;\n\n        constructor(user_input_handler) {\n            this.user_input_handler = user_input_handler;\n        }\n\n        public b_targeted(): boolean {\n            return true;\n        }\n    }\n\n    abstract class Parsed {\n        user_input_handler: UserInputHandler;\n\n        constructor(user_input_handler) {\n            this.user_input_handler = user_input_handler;\n        }\n\n        public b_targeted(): boolean {\n            return false;\n        }\n    }\n\n    export class Detect extends Targeted implements Algorithm, Temporal, Targetable {\n\n        constructor(user_input_handler) {\n            super(user_input_handler);\n        }\n\n        public get_depth(): number {\n            return 1\n        }\n\n        public get_name(): string {\n            return DETECT\n        }\n\n        determine_targets(notes_segment_next: TreeModel.Node<n.Note>[]): TypeSequenceTarget {\n            let targets;\n\n            switch(this.user_input_handler.mode_texture) {\n                // TODO: we should never have to use this, but I'm keeping it for the original test cases\n                case POLYPHONY: {\n                    let chords_grouped: TypeTarget[] = Harmony.group(\n                        notes_segment_next\n                    );\n\n                    let chords_monophonified: TypeTarget[] = [];\n\n                    for (let chord of chords_grouped) {\n                        let notes_monophonified: TypeTarget = Harmony.monophonify(\n                            chord\n                        );\n\n                        chords_monophonified.push(notes_monophonified)\n                    }\n\n                    targets = chords_monophonified;\n\n                    break;\n                }\n                case MONOPHONY: {\n                    let notes_grouped_trivial = [];\n\n                    for (let note of notes_segment_next) {\n                        notes_grouped_trivial.push([note])\n                    }\n\n                    targets = notes_grouped_trivial;\n\n                    break;\n                }\n                default: {\n                    throw ['texture mode', this.user_input_handler.mode_texture, 'not supported'].join(' ')\n                }\n            }\n            return targets;\n        }\n\n        public determine_region_present(notes_target_next): number[] {\n            return [\n                notes_target_next[0].model.note.beat_start,\n                notes_target_next[0].model.note.get_beat_end()\n            ]\n        }\n\n        pre_advance(clip_user_input) {\n\n        }\n\n        post_init(song, clip_user_input) {\n            clip_user_input.fire();\n        }\n\n        pre_terminate(song, clip_user_input) {\n            song.stop();\n            clip_user_input.stop();\n        }\n    }\n\n    export class Predict extends Targeted implements Algorithm, Temporal, Targetable {\n\n        public get_name(): string {\n            return PREDICT\n        }\n\n        public get_depth(): number {\n            return 1\n        }\n\n        determine_targets(notes_segment_next: TreeModel.Node<n.Note>[]): TypeSequenceTarget {\n            if (this.user_input_handler.mode_texture === POLYPHONY) {\n\n                let chords_grouped: TreeModel.Node<n.Note>[][] = Harmony.group(\n                    notes_segment_next\n                );\n\n                let chords_monophonified: TreeModel.Node<n.Note>[][] = [];\n\n                for (let note_group of chords_grouped) {\n                    chords_monophonified.push(\n                        Harmony.monophonify(\n                            note_group\n                        )\n                    );\n                }\n\n                return chords_monophonified\n\n            } else if (this.user_input_handler.mode_texture === MONOPHONY) {\n\n                let notes_grouped_trivial = [];\n\n                for (let note of notes_segment_next) {\n                    notes_grouped_trivial.push([note])\n                }\n\n                return notes_grouped_trivial\n\n            } else {\n                throw ['texture mode', this.user_input_handler.mode_texture, 'not supported'].join(' ')\n            }\n        }\n\n\n        determine_region_present(notes_target_next): number[] {\n            return [\n                notes_target_next[0].model.note.beat_start,\n                notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n            ]\n        }\n\n        pre_advance(clip_user_input) {\n\n        }\n\n        post_init(song, clip_user_input) {\n            clip_user_input.fire();\n        }\n\n        pre_terminate(song, clip_user_input) {\n            song.stop();\n            clip_user_input.stop();\n        }\n    }\n\n    export class Parse extends Parsed implements Algorithm, Temporal {\n\n        depth: number;\n\n        constructor(user_input_handler) {\n            super(user_input_handler);\n        }\n\n        public get_name(): string {\n            return PARSE\n        }\n\n        public get_depth(): number {\n            return this.depth\n        }\n\n        set_depth(depth: number) {\n            this.depth = depth;\n        }\n\n        // happens after loop of first target is set\n        post_init(song, clip_user_input) {\n            song.set_overdub(1);\n\n            song.set_session_record(1);\n\n            clip_user_input.fire();\n        }\n\n        // happens after last target is guessed\n        pre_terminate(song, clip_user_input) {\n            song.set_overdub(0);\n\n            song.set_session_record(0);\n\n            clip_user_input.stop();\n        }\n\n        determine_region_present(notes_target_next): number[] {\n            return [\n                notes_target_next[0].model.note.beat_start,\n                notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n            ]\n        }\n    }\n\n    export class Derive extends Parsed implements Temporal {\n\n        depth: number;\n\n        public get_name(): string {\n            return DERIVE\n        }\n\n        public get_depth(): number {\n            return this.depth\n        }\n\n        set_depth(depth: number) {\n            this.depth = depth;\n        }\n\n        // happens after loop of first target is set\n        post_init(song, clip_user_input) {\n            song.set_overdub(1);\n\n            song.set_session_record(1);\n\n            clip_user_input.fire();\n        }\n\n        // happens after last target is guessed\n        pre_terminate(song, clip_user_input) {\n            song.set_overdub(0);\n\n            song.set_session_record(0);\n\n            clip_user_input.stop();\n        }\n\n        determine_region_present(notes_target_next): number[] {\n            return [\n                notes_target_next[0].model.note.beat_start,\n                notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n            ]\n        }\n    }\n}"]}