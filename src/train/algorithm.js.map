{"version":3,"file":"algorithm.js","sourceRoot":"","sources":["algorithm.ts"],"names":[],"mappings":";;AAMA,IAAiB,KAAK,CAyLrB;AAzLD,WAAiB,KAAK;IAAC,IAAA,SAAS,CAyL/B;IAzLsB,WAAA,SAAS;QAK5B;YAAA;YASA,CAAC;YARG,4BAAW,GAAX,UAAY,kBAA4C;gBACpD,OAAO,kBAAkB,CAAA;YAC7B,CAAC;YAED,4BAAW,GAAX,UAAY,eAAe;YAE3B,CAAC;YAEL,aAAC;QAAD,CAAC,AATD,IASC;QATY,gBAAM,SASlB,CAAA;QAED;YAAA;YAsDA,CAAC;YApDG,0EAA0E;YAC1E,gDAAgD;YAChD,oDAAoD;YACpD,mCAAiB,GAAjB,UAAkB,kBAA4C;gBAC1D,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,OAAO,EAAE;oBAE7B,IAAI,cAAc,GAA+B,OAAO,CAAC,KAAK,CAC1D,kBAAkB,CACrB,CAAC;oBAEF,IAAI,oBAAoB,GAA+B,OAAO,CAAC,WAAW,CACtE,kBAAkB,CACrB,CAAC;oBAEF,OAAO,oBAAoB,CAAA;iBAE9B;qBAAM,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,MAAM,EAAE;oBAEnC,IAAI,qBAAqB,GAAG,EAAE,CAAC;oBAE/B,KAAiB,UAAkB,EAAlB,yCAAkB,EAAlB,gCAAkB,EAAlB,IAAkB,EAAE;wBAAhC,IAAI,MAAI,2BAAA;wBACT,qBAAqB,CAAC,IAAI,CAAC,MAAI,CAAC,CAAA;qBACnC;oBAED,OAAO,qBAAqB,CAAA;iBAE/B;qBAAM;oBACH,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;iBACvD;YACL,CAAC;YAGD,0CAAwB,GAAxB,UAAyB,iBAAiB;gBACtC,OAAO;oBACH,iBAAiB,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU;oBAC1C,iBAAiB,CAAC,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,YAAY,EAAE;iBAC5E,CAAA;YACL,CAAC;YAED,qBAAqB;YACrB,uCAAqB,GAArB,UAAsB,iBAAiB;gBACnC,OAAO,iBAAiB,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAA;YACrD,CAAC;YAED,oBAAoB;YACpB,2CAAyB,GAAzB,UAA0B,iBAAiB;gBACvC,OAAO,iBAAiB,CAAC,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,YAAY,EAAE,CAAA;YACpF,CAAC;YAED,6BAAW,GAAX;gBACI,EAAE;YACN,CAAC;YACL,cAAC;QAAD,CAAC,AAtDD,IAsDC;QAtDY,iBAAO,UAsDnB,CAAA;QAED;YAAA;YAMA,CAAC;YAJG,sBAAM,GAAN;YAEA,CAAC;YAEL,YAAC;QAAD,CAAC,AAND,IAMC;QANY,eAAK,QAMjB,CAAA;QAED;YAAA;YAgEA,CAAC;YA9DG,4CAA4C;YAC5C,0BAAS,GAAT;gBACI,oBAAoB;gBACpB,aAAa;gBACb,YAAY;YAChB,CAAC;YAED,uCAAuC;YACvC,8BAAa,GAAb;gBACI,qBAAqB;gBACrB,cAAc;gBACd,YAAY;YAChB,CAAC;YAED,yCAAwB,GAAxB,UAAyB,iBAAiB;gBACtC,OAAO;oBACH,iBAAiB,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU;oBAC1C,iBAAiB,CAAC,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,YAAY,EAAE;iBAC5E,CAAA;YACL,CAAC;YAED,qBAAqB;YACrB,sCAAqB,GAArB,UAAsB,iBAAiB;gBACnC,OAAO,iBAAiB,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAA;YACrD,CAAC;YAED,oBAAoB;YACpB,0CAAyB,GAAzB,UAA0B,iBAAiB;gBACvC,OAAO,iBAAiB,CAAC,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,YAAY,EAAE,CAAA;YACpF,CAAC;YAED,uBAAM,GAAN,UAAO,WAAqC,EAAE,OAAe,EAAE,SAAiB;gBAE5E,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;gBAEtC,QAAQ,CAAC,cAAc,CAAC,IAAI,EAAE,CAAA;gBAE9B,6CAA6C;gBAC7C,+DAA+D;gBAC/D,EAAE;gBACF,0EAA0E;gBAC1E,iGAAiG;gBACjG,EAAE;gBACF,uDAAuD;gBACvD,oCAAoC;gBACpC,WAAW;gBACX,yDAAyD;gBACzD,mGAAmG;gBACnG,wCAAwC;gBACxC,IAAI;gBACJ,EAAE;gBACF,sFAAsF;gBACtF,EAAE;gBACF,0BAA0B;gBAC1B,+DAA+D;gBAC/D,WAAW;gBACX,kFAAkF;gBAClF,IAAI;gBACJ,EAAE;gBACF,8CAA8C;YAClD,CAAC;YAEL,aAAC;QAAD,CAAC,AAhED,IAgEC;QAhEY,gBAAM,SAgElB,CAAA;QAcD;YAAA;YAsBA,CAAC;YArBG,4BAAS,GAAT,UAAU,YAAY;gBAClB,SAAS,OAAO,CAAC,WAAW,EAAC,WAAW;oBACpC,IAAI,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,GAAG,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU;wBACrE,OAAO,CAAC,CAAC,CAAC;oBACd,IAAI,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,GAAG,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU;wBACrE,OAAO,CAAC,CAAC;oBACb,OAAO,CAAC,CAAC;gBACb,CAAC;gBAED,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBAE3B,IAAI,YAAY,GAAG,YAAY,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,YAAY,EAAE,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAA;gBAE1H,IAAI,mBAAmB,GAAG,YAAY,GAAC,YAAY,CAAC,MAAM,CAAC;gBAE3D,eAAe,CAAC,SAAS,EAExB,CAAA;YACL,CAAC;YAGL,eAAC;QAAD,CAAC,AAtBD,IAsBC;QAtBY,kBAAQ,WAsBpB,CAAA;QAED;YAAA;YAEA,CAAC;YAAD,cAAC;QAAD,CAAC,AAFD,IAEC;QAFY,iBAAO,UAEnB,CAAA;IACL,CAAC,EAzLsB,SAAS,GAAT,eAAS,KAAT,eAAS,QAyL/B;AAAD,CAAC,EAzLgB,KAAK,GAAL,aAAK,KAAL,aAAK,QAyLrB","sourcesContent":["import {note, note as n} from \"../note/note\";\nimport {clip as c} from \"../clip/clip\";\nimport {live} from \"../live/live\";\nimport TreeModel = require(\"tree-model\");\nimport {target} from \"../target/target\";\n\nexport namespace train.algorithm {\n    import LiveClipVirtual = live.LiveClipVirtual;\n    import Target = target.Target;\n    import TargetType = target.TargetType;\n\n    export class Detect implements Temporal, Targetable {\n        set_targets(notes_segment_next: TreeModel.Node<n.Note>[]) {\n            return notes_segment_next\n        }\n\n        pre_advance(clip_user_input) {\n\n        }\n\n    }\n\n    export class Predict implements Temporal, Targetable {\n\n        // TODO: put all calls to Clip in whatever class is a client to algorithms\n        // NB: there can be multiple targets per segment\n        // TODO: replace the notes in clip_target with these\n        determine_targets(notes_segment_next: TreeModel.Node<n.Note>[]): TargetType {\n            if (this.mode === modes.HARMONY) {\n\n                let chords_grouped: TreeModel.Node<n.Note>[][] = harmony.group(\n                    notes_segment_next\n                );\n\n                let chords_monophonified: TreeModel.Node<n.Note>[][] = harmony.monophonify(\n                    notes_segment_next\n                );\n\n                return chords_monophonified\n\n            } else if (this.mode === modes.MELODY) {\n\n                let notes_grouped_trivial = [];\n\n                for (let note of notes_segment_next) {\n                    notes_grouped_trivial.push(note)\n                }\n\n                return notes_grouped_trivial\n\n            } else {\n                throw ['mode', this.mode, 'not supported'].join(' ')\n            }\n        }\n\n\n        determine_region_current(notes_target_next): number[] {\n            return [\n                notes_target_next[0].model.note.beat_start,\n                notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n            ]\n        }\n\n        // set right interval\n        determine_region_past(notes_target_next): number {\n            return notes_target_next[0].model.note.beat_start\n        }\n\n        // set left interval\n        determine_region_upcoming(notes_target_next): number {\n            return notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n        }\n\n        pre_advance() {\n            //\n        }\n    }\n\n    export class Parse implements Temporal {\n\n        accept() {\n\n        }\n\n    }\n\n    export class Derive implements Temporal {\n\n        // happens after loop of first target is set\n        post_init() {\n            // session record on\n            // overdub on\n            // clip fire\n        }\n\n        // happens after last target is guessed\n        pre_terminate() {\n            // session record off\n            // overdub off\n            // clip stop\n        }\n\n        determine_region_current(notes_target_next): number[] {\n            return [\n                notes_target_next[0].model.note.beat_start,\n                notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n            ]\n        }\n\n        // set right interval\n        determine_region_past(notes_target_next): number {\n            return notes_target_next[0].model.note.beat_start\n        }\n\n        // set left interval\n        determine_region_upcoming(notes_target_next): number {\n            return notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n        }\n\n        accept(elaboration: TreeModel.Node<n.Note>[], i_depth: number, i_breadth: number): void {\n\n            this.struct_train.append(elaboration);\n\n            nextthis.iterator_train.next()\n\n            // if (index_layer + 1 > this.clips.length) {\n            //     let clip_dao_virtual = new LiveClipVirtual(elaboration);\n            //\n            //     clip_dao_virtual.beat_start = elaboration[0].model.note.beat_start;\n            //     clip_dao_virtual.beat_end = elaboration[elaboration.length - 1].model.note.get_beat_end();\n            //\n            //     let clip_virtual = new c.Clip(clip_dao_virtual);\n            //     this.add_clsip(clip_virtual);\n            // } else {\n            //     let clip_last = this.clips[this.clips.length - 1];\n            //     clip_last.clip_dao.beat_end = elaboration[elaboration.length - 1].model.note.get_beat_end();\n            //     clip_last.set_notes(elaboration);\n            // }\n            //\n            // let leaves_within_interval = this.get_leaves_within_interval(beat_start, beat_end);\n            //\n            // if (index_layer == 1) {\n            //     this.add_first_layer(elaboration, this.clips.length - 1)\n            // } else {\n            //     this.add_layer(leaves_within_interval, elaboration, this.clips.length - 1);\n            // }\n            //\n            // this.update_leaves(leaves_within_interval);\n        }\n\n    }\n    \n    export interface Temporal {\n        determine_region_current\n\n        determine_region_past\n\n        determine_region_upcoming\n    }\n\n    export interface Targetable {\n        determine_targets\n    }\n\n    export class Harmonic {\n        transform(notes_target) {\n            function compare(note_former,note_latter) {\n                if (note_former.model.note.beat_start < note_latter.model.note.beat_start)\n                    return -1;\n                if (note_former.model.note.beat_start > note_latter.model.note.beat_start)\n                    return 1;\n                return 0;\n            }\n\n            notes_target.sort(compare);\n\n            let length_beats = notes_target[notes_target.length - 1].model.note.get_beat_end() - notes_target[0].model.note.beat_start\n\n            let duration_monophonic = length_beats/notes_target.length;\n\n            clip_user_input.set_notes(\n\n            )\n        }\n        // once a target is issued, take all notes and spread them out equidistantly with no overlap\n\n    }\n\n    export class Melodic {\n        // do nothing special\n    }\n}"]}