{"version":3,"file":"algorithm.js","sourceRoot":"","sources":["algorithm.ts"],"names":[],"mappings":"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","sourcesContent":["import {note, note as n} from \"../note/note\";\nimport {clip as c} from \"../clip/clip\";\nimport {live} from \"../live/live\";\nimport TreeModel = require(\"tree-model\");\nimport {target} from \"../target/target\";\nimport {harmony} from \"../music/harmony\";\nimport {modes_texture} from \"../constants/constants\";\nimport {user_input} from \"../control/user_input\";\nimport {history} from \"../history/history\";\n\nexport namespace algorithm {\n    import UserInputHandler = user_input.UserInputHandler;\n    export let DETECT = 'detect';\n    export let PREDICT = 'predict';\n    export let PARSE = 'parse';\n    export let DERIVE = 'derive';\n\n    import LiveClipVirtual = live.LiveClipVirtual;\n    import Target = target.Target;\n    // import TargetType = target.TargetType;\n    import Harmony = harmony.Harmony;\n    import TargetIterator = target.TargetIterator;\n    import POLYPHONY = modes_texture.POLYPHONY;\n    import MONOPONY = modes_texture.MONOPONY;\n    import TypeSequenceTarget = history.TypeSequenceTarget;\n    import TypeTarget = history.TypeTarget;\n\n    export interface Temporal {\n        determine_region_present\n\n        // determine_region_past\n        //\n        // determine_region_upcoming\n    }\n\n    export interface Targetable {\n        determine_targets\n    }\n\n    export interface Algorithm {\n        get_name(): string\n        get_depth(): number\n        b_targeted(): boolean\n    }\n\n    abstract class Targeted {\n        user_input_handler: UserInputHandler;\n\n        constructor(user_input_handler) {\n            this.user_input_handler = user_input_handler;\n        }\n\n        public b_targeted(): boolean {\n            return true;\n        }\n    }\n\n    abstract class Parsed {\n        public b_targeted(): boolean {\n            return false;\n        }\n    }\n\n    export class Detect extends Targeted implements Algorithm, Temporal, Targetable {\n\n        constructor(user_input_handler) {\n            super(user_input_handler);\n        }\n\n        public get_depth(): number {\n            return 1\n        }\n\n        public get_name(): string {\n            return DETECT\n        }\n\n        determine_targets(notes_segment_next: TreeModel.Node<n.Note>[]): TypeSequenceTarget {\n            if (this.user_input_handler.mode_texture === POLYPHONY) {\n\n                let chords_grouped: TypeTarget[] = Harmony.group(\n                    notes_segment_next\n                );\n\n                let chords_monophonified: TypeTarget[] = [];\n\n                for (let chord of chords_grouped) {\n                    let notes_monophonified: TypeTarget = Harmony.monophonify(\n                        chord\n                    );\n\n                    chords_monophonified.push(notes_monophonified)\n                }\n\n                return chords_monophonified\n\n            } else if (this.user_input_handler.mode_texture === MONOPONY) {\n\n                let notes_grouped_trivial = [];\n\n                for (let note of notes_segment_next) {\n                    notes_grouped_trivial.push(note)\n                }\n\n                // Subtarget -> Subtarget Iterator -> Target -> Target Iterator\n\n                return notes_grouped_trivial\n\n            } else {\n                throw ['texture mode', this.user_input_handler.mode_texture, 'not supported'].join(' ')\n            }\n        }\n\n        public determine_region_present(notes_target_next): number[] {\n            return [\n                notes_target_next[0].model.note.beat_start,\n                // notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n                notes_target_next[0].model.note.get_beat_end()\n            ]\n        }\n\n        pre_advance(clip_user_input) {\n\n        }\n\n        post_init(song, clip_user_input) {\n            clip_user_input.fire();\n        }\n    }\n\n    export class Predict extends Targeted implements Algorithm, Temporal, Targetable {\n\n        public get_name(): string {\n            return PREDICT\n        }\n\n        public get_depth(): number {\n            return 1\n        }\n\n        // TODO: put all calls to Clip in whatever class is a client to algorithms\n        // NB: there can be multiple targets per segment\n        // TODO: replace the notes in clip_target with these\n        determine_targets(notes_segment_next: TreeModel.Node<n.Note>[]): TypeSequenceTarget {\n            if (this.user_input_handler.mode_texture === POLYPHONY) {\n\n                let chords_grouped: TreeModel.Node<n.Note>[][] = Harmony.group(\n                    notes_segment_next\n                );\n\n                let chords_monophonified: TreeModel.Node<n.Note>[][] = [];\n\n                for (let note_group of chords_grouped) {\n                    chords_monophonified.push(\n                        Harmony.monophonify(\n                            note_group\n                        )\n                    );\n                }\n\n                return chords_monophonified\n\n            } else if (this.user_input_handler.mode_texture === MONOPONY) {\n\n                let notes_grouped_trivial = [];\n\n                for (let note of notes_segment_next) {\n                    notes_grouped_trivial.push(note)\n                }\n\n                return notes_grouped_trivial\n\n            } else {\n                throw ['texture mode', this.user_input_handler.mode_texture, 'not supported'].join(' ')\n            }\n        }\n\n\n        determine_region_present(notes_target_next): number[] {\n            return [\n                notes_target_next[0].model.note.beat_start,\n                notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n            ]\n        }\n\n        pre_advance() {\n\n        }\n    }\n\n    export class Parse extends Parsed implements Algorithm, Temporal {\n\n        depth: number;\n\n        public get_name(): string {\n            return PARSE\n        }\n\n        public get_depth(): number {\n            return this.depth\n        }\n\n        set_depth(depth: number) {\n            this.depth = depth;\n        }\n\n        // happens after loop of first target is set\n        post_init(song, clip_user_input) {\n            song.set_overdub(1);\n\n            song.set_session_record(1);\n\n            clip_user_input.fire();\n        }\n\n        // happens after last target is guessed\n        pre_terminate(song, clip_user_input) {\n            song.set_overdub(0);\n\n            song.set_session_record(0);\n\n            clip_user_input.stop();\n        }\n\n        determine_region_present(notes_target_next): number[] {\n            return [\n                notes_target_next[0].model.note.beat_start,\n                notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n            ]\n        }\n    }\n\n    export class Derive extends Parsed implements Temporal {\n\n        depth: number;\n\n        public get_name(): string {\n            return DERIVE\n        }\n\n        public get_depth(): number {\n            return this.depth\n        }\n\n        set_depth(depth: number) {\n            this.depth = depth;\n        }\n\n        // happens after loop of first target is set\n        post_init(song, clip_user_input) {\n            song.set_overdub(1);\n\n            song.set_session_record(1);\n\n            clip_user_input.fire();\n        }\n\n        // happens after last target is guessed\n        pre_terminate(song, clip_user_input) {\n            song.set_overdub(0);\n\n            song.set_session_record(0);\n\n            clip_user_input.stop();\n        }\n\n        determine_region_present(notes_target_next): number[] {\n            return [\n                notes_target_next[0].model.note.beat_start,\n                notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n            ]\n        }\n\n        // // set right interval\n        // determine_region_past(notes_target_next): number {\n        //     return notes_target_next[0].model.note.beat_start\n        // }\n        //\n        // // set left interval\n        // determine_region_upcoming(notes_target_next): number {\n        //     return notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n        // }\n\n        accept(elaboration: TreeModel.Node<n.Note>[], i_depth: number, i_breadth: number): void {\n\n\n            // if (index_layer + 1 > this.clips.length) {\n            //     let clip_dao_virtual = new LiveClipVirtual(elaboration);\n            //\n            //     clip_dao_virtual.beat_start = elaboration[0].model.note.beat_start;\n            //     clip_dao_virtual.beat_end = elaboration[elaboration.length - 1].model.note.get_beat_end();\n            //\n            //     let clip_virtual = new c.Clip(clip_dao_virtual);\n            //     this.add_clsip(clip_virtual);\n            // } else {\n            //     let clip_last = this.clips[this.clips.length - 1];\n            //     clip_last.clip_dao.beat_end = elaboration[elaboration.length - 1].model.note.get_beat_end();\n            //     clip_last.set_notes(elaboration);\n            // }\n            //\n            // let leaves_within_interval = this.get_leaves_within_interval(beat_start, beat_end);\n            //\n            // if (index_layer == 1) {\n            //     this.add_first_layer(elaboration, this.clips.length - 1)\n            // } else {\n            //     this.add_layer(leaves_within_interval, elaboration, this.clips.length - 1);\n            // }\n            //\n            // this.update_leaves(leaves_within_interval);\n        }\n\n    }\n}"]}