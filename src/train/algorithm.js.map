{"version":3,"file":"algorithm.js","sourceRoot":"","sources":["algorithm.ts"],"names":[],"mappings":"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","sourcesContent":["import {note, note as n} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {harmony} from \"../music/harmony\";\nimport {modes_texture} from \"../constants/constants\";\nimport {user_input} from \"../control/user_input\";\nimport {history} from \"../history/history\";\nimport {clip} from \"../clip/clip\";\nimport {parse} from \"../parse/parse\";\nimport {segment} from \"../segment/segment\";\nimport {track} from \"../track/track\";\nimport {window} from \"../render/window\";\nimport {iterate} from \"./iterate\";\nimport {message} from \"../message/messenger\";\nimport {target} from \"../target/target\";\nimport {live} from \"../live/live\";\nimport {scene} from \"../scene/scene\";\nimport {utils} from \"../utils/utils\";\nimport {song} from \"../song/song\";\nconst _ = require('underscore');\n\nexport namespace algorithm {\n    import Song = song.Song;\n    export let DETECT = 'detect';\n    export let PREDICT = 'predict';\n    export let PARSE = 'parse';\n    export let DERIVE = 'derive';\n    export let FREESTYLE = 'freestyle';\n    import Harmony = harmony.Harmony;\n    import POLYPHONY = modes_texture.POLYPHONY;\n    import MONOPHONY = modes_texture.MONOPHONY;\n    import TypeSequenceTarget = history.TypeSequenceTarget;\n    import Note = note.Note;\n    import ParseTree = parse.ParseTree;\n    import StructParse = parse.StructParse;\n    import Segment = segment.Segment;\n    import Window = window.Window;\n    import Track = track.Track;\n    import MatrixIterator = iterate.MatrixIterator;\n    import Messenger = message.Messenger;\n    import Subtarget = target.Subtarget;\n    import TargetIterator = target.TargetIterator;\n    import ClipDao = clip.ClipDao;\n    import Target = target.Target;\n    import FactoryMatrixObjectives = iterate.FactoryMatrixObjectives;\n    import Scene = scene.Scene;\n    import UserInputHandler = user_input.UserInputHandler;\n    import Clip = clip.Clip;\n\n\n    interface Temporal {\n        determine_region_present(notes_next)\n        stream_bounds(messenger: message.Messenger, subtarget_current: Subtarget, segment_current: Segment): void\n    }\n\n    interface Renderable {\n        initialize_render(window: Window, segments: Segment[], notes_track_target: TreeModel.Node<Note>[])\n        get_notes_in_region(target: Target, segment: Segment): TreeModel.Node<Note>[]\n    }\n\n    // interface that the trainer uses\n    export interface Trainable extends Temporal, Renderable {\n        depth: number;\n        b_parsed: boolean;\n        b_targeted: boolean;\n\n        get_name(): string\n        get_depth(): number\n        coord_to_index_clip(coord: number[]): number\n        initialize(window: Window, segments: Segment[], notes_target_track: TreeModel.Node<Note>[], user_input_handler: UserInputHandler): void\n        terminate(struct_parse: StructParse, segments: Segment[])\n        unpause(song: Song, scene_current: Scene)\n        pause(song: Song, scene_current: Scene)\n        create_matrix_targets(user_input_handler: UserInputHandler, segments: Segment[], notes_target_track: TreeModel.Node<Note>[])\n        create_struct_parse(segments: Segment[]): StructParse\n        initialize_tracks(segments: segment.Segment[], track_target: track.Track, track_user_input: track.Track, matrix_target: TargetIterator[][])\n\n        warrants_advance(\n            notes_user_input: TreeModel.Node<Note>[],\n            subtarget_current: Subtarget\n        ): boolean\n\n        postprocess_user_input(\n            notes_user_input: TreeModel.Node<Note>[],\n            subtarget_current: Subtarget\n        ): TreeModel.Node<Note>[]\n    }\n\n    // interface common to both parse and derive, but have different implementations\n    export interface Parsable extends Trainable {\n        initialize_parse(struct_parse, segments, track_target)\n        finish_parse(struct_parse: StructParse, segments: Segment[]): void;\n        update_roots(coords_roots_previous: number[][], coords_notes_to_grow: number[][], coord_notes_current: number[])\n        get_coords_notes_to_grow(coords_note_input_current): number[][]\n        grow_layer(notes_user_input_renderable, notes_to_grow)\n    }\n\n    // interface common to both detect and predict, but have different implementations\n    export interface Targetable extends Trainable {\n        determine_targets(user_input_handler: UserInputHandler, notes_in_segment: TreeModel.Node<Note>[])\n        postprocess_subtarget(subtarget: Subtarget)\n    }\n\n    // logic common to detect and predict\n    abstract class Targeted implements Targetable {\n\n        public b_parsed: boolean = false;\n        public b_targeted: boolean = true;\n        public depth: number;\n\n        public abstract get_name()\n\n        public abstract initialize_tracks(segments: segment.Segment[], track_target: track.Track, track_user_input: track.Track, matrix_target: target.TargetIterator[][])\n\n        public abstract determine_targets(user_input_handler: UserInputHandler, notes_segment_next: TreeModel.Node<n.Note>[]): TypeSequenceTarget\n\n        public get_depth(): number {\n            return 1\n        }\n\n        coord_to_index_clip(coord: number[]): number {\n            return 0;\n        }\n\n        create_struct_parse(segments: Segment[]) {\n            return null\n        }\n\n        public determine_region_present(notes_target_next): number[] {\n            return [\n                notes_target_next[0].model.note.beat_start,\n                notes_target_next[0].model.note.get_beat_end()\n            ]\n        }\n\n        get_notes_in_region(target: target.Target, segment: segment.Segment) {\n            return target.iterator_subtarget.subtargets.map((subtarget) => {\n                return subtarget.note\n            })\n        }\n\n        public abstract initialize_render(window: Window, segments: Segment[], notes_target_track: TreeModel.Node<Note>[])\n\n        unpause(song: Song, scene_current: Scene) {\n            // not forcing legato so that it starts immediately\n            scene_current.fire(false)\n        }\n\n        postprocess_user_input(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current: target.Subtarget): TreeModel.Node<note.Note>[] {\n            return [subtarget_current.note];\n        }\n\n        public abstract postprocess_subtarget(subtarget: Subtarget)\n\n        // TODO: verify that we don't need to do anything\n        terminate() {\n            return\n        }\n\n        pause(song: Song, scene_current: Scene) {\n            song.stop()\n        }\n\n        warrants_advance(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current): boolean {\n            return utils.remainder(notes_user_input[0].model.note.pitch, 12) === utils.remainder(subtarget_current.note.model.note.pitch, 12)\n        }\n\n        public create_matrix_targets(user_input_handler: UserInputHandler, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]): TargetIterator[][] {\n\n            let matrix_targets = FactoryMatrixObjectives.create_matrix_objectives(\n                this,\n                segments\n            );\n\n            // TODO: use 'filter' here\n            // this.clip_target.load_notes_within_markers();\n\n            for (let i_segment in segments) {\n                let segment = segments[Number(i_segment)];\n\n                let notes_in_segment = notes_target_track.filter(\n                    node => node.model.note.beat_start >= segment.get_endpoints_loop()[0] && node.model.note.get_beat_end() <= segment.get_endpoints_loop()[1]\n                );\n\n                let sequence_targets = this.determine_targets(\n                    user_input_handler,\n                    notes_in_segment\n                );\n\n                matrix_targets[0][Number(i_segment)] = TargetIterator.from_sequence_target(sequence_targets);\n            }\n\n            return matrix_targets\n        }\n\n        private static stream_subtarget_bounds(messenger: message.Messenger, subtarget_current: Subtarget, segment_current: Segment) {\n            let ratio_bound_lower = (subtarget_current.note.model.note.beat_start - segment_current.get_endpoints_loop()[0])/(segment_current.get_endpoints_loop()[1] - segment_current.get_endpoints_loop()[0]);\n            let ratio_bound_upper = (subtarget_current.note.model.note.get_beat_end() - segment_current.get_endpoints_loop()[0])/(segment_current.get_endpoints_loop()[1] - segment_current.get_endpoints_loop()[0]);\n            messenger.message(['bounds', ratio_bound_lower, ratio_bound_upper])\n        }\n\n        stream_bounds(messenger: message.Messenger, subtarget_current: Subtarget, segment_current: Segment): void {\n            Targeted.stream_subtarget_bounds(messenger, subtarget_current, segment_current)\n        }\n\n        initialize(window: Window, segments: Segment[], notes_target_track: TreeModel.Node<Note>[], user_input_handler: UserInputHandler) {\n            this.create_matrix_targets(user_input_handler, segments, notes_target_track);\n            this.initialize_render(window, segments, notes_target_track)\n        }\n    }\n\n    // logic common to parse and derive\n    abstract class Parsed implements Parsable {\n\n        public b_parsed: boolean = true;\n\n        public b_targeted: boolean = false;\n\n        public abstract get_name();\n\n        depth: number;\n\n        public abstract initialize_render(window: Window, segments: Segment[], notes_track_target: TreeModel.Node<Note>[])\n\n        public abstract initialize_tracks(segments: segment.Segment[], track_target: track.Track, track_user_input: track.Track, matrix_target: target.TargetIterator[][])\n\n        public get_depth(): number {\n            return this.depth\n        }\n\n        set_depth(depth: number) {\n            this.depth = depth;\n        }\n\n        coord_to_index_clip(coord: number[]): number {\n            if (coord[0] === -1) {\n                return 0\n            } else {\n                return coord[0] + 1\n            }\n        }\n\n        create_matrix_targets(user_input_handler: UserInputHandler, segments: segment.Segment[], notes_target_track: TreeModel.Node<note.Note>[]) {\n            return []\n        }\n\n        create_struct_parse(segments: Segment[]): StructParse {\n            return new StructParse(\n                FactoryMatrixObjectives.create_matrix_objectives(\n                    this,\n                    segments\n                )\n            )\n        }\n\n        determine_region_present(notes_target_next): number[] {\n            return [\n                notes_target_next[0].model.note.beat_start,\n                notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n            ]\n        }\n\n        finish_parse(struct_parse: parse.StructParse, segments: segment.Segment[]): void {\n        }\n\n        public abstract get_coords_notes_to_grow(coords_note_input_current): number[][]\n\n        get_notes_in_region(target: target.Target, segment: segment.Segment) {\n            return [segment.get_note()]\n        }\n\n        public abstract grow_layer(notes_user_input_renderable, notes_to_grow)\n\n        initialize() {\n            // TODO: add logic\n        }\n\n        public abstract initialize_parse(struct_parse, segments, track_target)\n\n\n        pause(song: Song, scene_current: Scene) {\n            song.set_overdub(0);\n\n            song.set_session_record(0);\n\n            song.stop()\n        }\n\n        postprocess_user_input(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current: target.Subtarget): TreeModel.Node<note.Note>[] {\n            return notes_user_input;\n        }\n\n        stream_bounds(messenger: message.Messenger, subtarget_current: target.Subtarget, segment_current: segment.Segment): void {\n            Parsed.stream_segment_bounds(messenger)\n        }\n\n        private static stream_segment_bounds(messenger: Messenger) {\n            messenger.message(['bounds', 0, 1])\n        }\n\n        terminate(struct_parse: StructParse, segments: Segment[]) {\n            this.finish_parse(struct_parse, segments)\n        }\n\n        unpause(song: Song, scene_current: Scene) {\n            song.set_overdub(1);\n\n            song.set_session_record(1);\n\n            scene_current.fire(false);\n        }\n\n        update_roots(coords_roots_previous: number[][], coords_notes_to_grow: number[][], coord_notes_current: number[]) {\n\n        }\n\n        warrants_advance(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current: target.Subtarget): boolean {\n            return true;\n        }\n    }\n\n    export class Detect extends Targeted {\n\n        constructor() {\n            super();\n        }\n\n        determine_targets(user_input_handler: UserInputHandler, notes_segment_next: TreeModel.Node<n.Note>[]): TypeSequenceTarget {\n            if (user_input_handler.mode_texture === POLYPHONY) {\n\n                let chords_grouped: TreeModel.Node<n.Note>[][] = Harmony.group(\n                    notes_segment_next\n                );\n\n                let chords_monophonified: TypeSequenceTarget = [];\n\n                for (let note_group of chords_grouped) {\n                    chords_monophonified.push(\n                        Harmony.monophonify(\n                            note_group\n                        )\n                    );\n                }\n\n                // return [chords_monophonified[Math.floor(Math.random() * chords_monophonified.length)]];\n                return [chords_monophonified[chords_monophonified.length/2]]\n\n            } else if (user_input_handler.mode_texture === MONOPHONY) {\n\n                let notes_grouped_trivial: TypeSequenceTarget = [];\n\n                for (let note of notes_segment_next) {\n                    notes_grouped_trivial.push([note])\n                }\n\n                // return notes_grouped_trivial\n                // TODO: let's put more weight towards the center of the measure\n                // return notes_grouped_trivial[Math.floor(Math.random() * notes_grouped_trivial.length)];\n                return [notes_grouped_trivial[notes_grouped_trivial.length/2]]\n\n            } else {\n                throw ['texture mode', user_input_handler.mode_texture, 'not supported'].join(' ')\n            }\n        }\n\n        public get_name(): string {\n            return DETECT\n        }\n\n        postprocess_subtarget(note_subtarget) {\n            return note_subtarget\n        }\n\n        // TODO: verify that we don't have to do anything here\n        initialize_render(window: window.Window, segments: segment.Segment[], notes_target_track: TreeModel.Node<note.Note>[]) {\n            return\n        }\n\n        initialize_tracks(segments: segment.Segment[], track_target: track.Track, track_user_input: track.Track, matrix_target: TargetIterator[][]) {\n            return\n        }\n    }\n\n    export class Predict extends Targeted {\n\n        public get_name(): string {\n            return PREDICT\n        }\n\n        determine_targets(user_input_handler: UserInputHandler, notes_segment_next: TreeModel.Node<n.Note>[]): TypeSequenceTarget {\n\n            if (user_input_handler.mode_texture === POLYPHONY) {\n\n                // let chords_grouped: TreeModel.Node<n.Note>[][] = Harmony.group(\n                //     notes_segment_next\n                // );\n                //\n                // let chords_monophonified: TypeSequenceTarget = [];\n                //\n                // for (let note_group of chords_grouped) {\n                //     chords_monophonified.push(\n                //         Harmony.monophonify(\n                //             note_group\n                //         )\n                //     );\n                // }\n\n                throw 'polyphonic targets for prediction not yet implemented'\n\n            } else if (user_input_handler.mode_texture === MONOPHONY) {\n\n                let notes_grouped: TypeSequenceTarget = [];\n\n                // partition segment into measures\n\n                let position_measure = (node) => {\n                    Math.floor(node.model.note.beat_start/4)\n                };\n\n                let note_partitions: TreeModel.Node<Note>[][] = _.groupBy(notes_segment_next, position_measure);\n\n                for (let partition of note_partitions) {\n                    // get the middle note of the measure\n                    notes_grouped.push([partition[partition.length/2]])\n                }\n\n                return notes_grouped\n\n            } else {\n                throw ['texture mode', user_input_handler.mode_texture, 'not supported'].join(' ')\n            }\n        }\n\n        postprocess_subtarget(note_subtarget) {\n            note_subtarget.model.note.muted = 1;\n            return note_subtarget;\n        }\n\n        // TODO: verify that we don't have to do anythiing here\n        initialize_render(window: window.Window, segments: segment.Segment[], notes_target_track: TreeModel.Node<note.Note>[]) {\n            return\n        }\n\n        // NB: we only have to initialize clips in the target track\n        initialize_tracks(segments: segment.Segment[], track_target: track.Track, track_user_input: track.Track, matrix_target: TargetIterator[][]) {\n\n            for (let i_segment in segments) {\n                let segment = segments[Number(i_segment)];\n\n                let targeted_notes_in_segment = matrix_target[0][Number(i_segment)].get_notes();\n\n                // TODO: this won't work for polyphony\n                for (let note of targeted_notes_in_segment) {\n                    // clip = track_target.get_clip_at_interval(\n                    //     [note.model.note.beat_start, note.model.note.get_beat_end()]\n                    // );\n\n                    segment.clip_user_input_async.remove_notes(\n                        note.model.note.beat_start,\n                        0,\n                        note.model.note.get_beat_end(),\n                        128\n                    );\n\n                    segment.clip_user_input_async.set_notes(\n                        [note]\n                    )\n                }\n            }\n\n            // TODO: get the subtargets that are currently in each segment and mute them\n        //     for (let target of sequence_targets) {\n        //         for (let subtarget of target) {\n        //\n        //             let subtarget_processed = this.postprocess_subtarget(\n        //                 subtarget\n        //             );\n        //\n        //             clip_target_track.remove_notes(\n        //                 subtarget_processed.model.note.beat_start,\n        //                 0,\n        //                 subtarget_processed.model.note.get_beat_end(),\n        //                 128\n        //             );\n        //\n        //             clip_target_track.set_notes(\n        //                 [subtarget_processed]\n        //             )\n        //         }\n        //     }\n        //\n        //     for (let i_segment in segments) {\n        //\n        //         let index_clip_slot_current = Number(i_segment);\n        //\n        //         let api_clip_target_synchronous = new ApiJs(\n        //             track_target.track_dao.get_path().split(' ').concat(['clip_slots', index_clip_slot_current, 'clip']).join(' ')\n        //         );\n        //\n        //         let api_clip_user_input_synchronous = new ApiJs(\n        //             track_user_input.track_dao.get_path().split(' ').concat(['clip_slots', index_clip_slot_current, 'clip']).join(' ')\n        //         );\n        //\n        //         let clip_target = new Clip(\n        //             new ClipDao(\n        //                 api_clip_target_synchronous,\n        //                 new Messenger('max', 0)\n        //             )\n        //         );\n        //\n        //         let clip_user_input = new Clip(\n        //             new ClipDao(\n        //                 api_clip_user_input_synchronous,\n        //                 new Messenger('max', 0)\n        //             )\n        //         );\n        //\n        //         let notes = clip_target.get_notes(\n        //             clip_target.get_loop_bracket_lower(),\n        //             0,\n        //             clip_target.get_loop_bracket_upper(),\n        //             128\n        //         );\n        //\n        //         clip_user_input.remove_notes(\n        //             clip_target.get_loop_bracket_lower(),\n        //             0,\n        //             clip_target.get_loop_bracket_upper(),\n        //             128\n        //         );\n        //\n        //         clip_user_input.set_notes(\n        //             notes\n        //         )\n        //     }\n        }\n    }\n\n    export class Parse extends Parsed {\n\n        constructor() {\n            super();\n        }\n\n        public get_name(): string {\n            return PARSE\n        }\n\n        grow_layer(notes_user_input_renderable, notes_to_grow) {\n            ParseTree.add_layer(\n                notes_user_input_renderable,\n                notes_to_grow,\n                -1\n            )\n        }\n\n        // TODO: we don't need the target track - we should 1) transfer all notes over to user input track and 2) mute the track\n        initialize_tracks(segments: segment.Segment[], track_target: track.Track, track_user_input: track.Track, matrix_target: TargetIterator[][]) {\n            for (let i_segment in segments) {\n\n                let clip_target = track_target.get_clip_at_index(Number(i_segment));\n\n                let clip_user_input = track_user_input.get_clip_at_index(Number(i_segment));\n\n                let notes = clip_target.get_notes(\n                    clip_target.get_loop_bracket_lower(),\n                    0,\n                    clip_target.get_loop_bracket_upper(),\n                    128\n                );\n\n                clip_user_input.remove_notes(\n                    clip_target.get_loop_bracket_lower(),\n                    0,\n                    clip_target.get_loop_bracket_upper(),\n                    128\n                );\n\n                clip_user_input.set_notes(\n                    notes\n                )\n            }\n        }\n\n        // add the root up to which we're going to parse\n        // add the segments as the layer below\n        // add the leaf notes\n        initialize_render(window: Window, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]) {\n            // first layer\n            window.add_note_to_clip_root(\n                StructParse.create_root_from_segments(\n                    segments\n                )\n            );\n\n            for (let i_segment in segments) {\n\n                let segment = segments[Number(i_segment)];\n\n                let note_segment = segment.get_note();\n\n                let coord_current_virtual_second_layer = [0, Number(i_segment)];\n\n                let notes_leaves = notes_target_track.filter(\n                    node => node.model.note.beat_start >= segment.get_endpoints_loop()[0] && node.model.note.get_beat_end() <= segment.get_endpoints_loop()[1]\n                );\n\n                let coord_current_virtual_leaves = [this.get_depth() - 1, Number(i_segment)];\n\n                // second layer\n                window.add_notes_to_clip(\n                    [note_segment],\n                    coord_current_virtual_second_layer,\n                    this\n                );\n\n                // leaves\n                window.add_notes_to_clip(\n                    notes_leaves,\n                    coord_current_virtual_leaves,\n                    this\n                )\n            }\n        }\n\n        update_roots(coords_roots_previous: number[][], coords_notes_previous: number[][], coord_notes_current: number[]) {\n            let coords_roots_new = [];\n\n            // remove references to old leaves\n            for (let coord_notes_previous of coords_notes_previous) {\n                coords_roots_new = coords_roots_new.concat(\n                    coords_roots_previous.filter((x) => {\n                        return !(x[0] === coord_notes_previous[0] && x[1] === coord_notes_previous[1])\n                    })\n                );\n            }\n\n            // add references to new leaves\n            coords_roots_new.push(\n                coord_notes_current\n            );\n        }\n\n        get_coords_notes_to_grow(coord_notes_input_current) {\n            return MatrixIterator.get_coords_below([coord_notes_input_current[0], coord_notes_input_current[1]]);\n        }\n\n        // adding the leaf notes to the actual parse tree\n        // DO NOT set the root or the segments as nodes immediately below that - do that at the end\n        // set the leaf notes as the notes in the target track\n        initialize_parse(struct_parse: StructParse, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]) {\n            // this is to set the leaves as the notes of the target clip\n\n            for (let i_segment in segments) {\n                let segment = segments[Number(i_segment)];\n\n                let notes = notes_target_track.filter(\n                    node => node.model.note.beat_start >= segment.get_endpoints_loop()[0] && node.model.note.get_beat_end() <= segment.get_endpoints_loop()[1]\n                );\n\n                let coord_current_virtual_leaf = [this.get_depth() - 1, Number(i_segment)];\n\n                struct_parse.add(\n                    notes,\n                    coord_current_virtual_leaf,\n                    this\n                );\n            }\n        }\n\n        finish_parse(struct_parse: StructParse, segments: Segment[]): void {\n\n            // make connections with segments\n            for (let i_segment in segments) {\n                let segment = segments[Number(i_segment)];\n                struct_parse.add(\n                    [segment.get_note()],\n                    [0, Number(i_segment)],\n                    this\n                );\n            }\n\n            struct_parse.set_root(\n                StructParse.create_root_from_segments(\n                    segments\n                )\n            );\n\n            // make connections with root\n            struct_parse.add(\n                [Note.from_note_renderable(struct_parse.get_root())],\n                [-1],\n                this\n            );\n        }\n    }\n\n    export class Derive extends Parsed {\n\n        public get_name(): string {\n            return DERIVE\n        }\n\n        get_coords_notes_to_grow(coords_note_input_current) {\n            return MatrixIterator.get_coords_above([coords_note_input_current[0], coords_note_input_current[1]])\n        }\n\n        grow_layer(notes_user_input_renderable, notes_to_grow) {\n            ParseTree.add_layer(\n                notes_to_grow,\n                notes_user_input_renderable,\n                -1\n            )\n        }\n\n        // TODO: verify that the segments should already be here so we don't have to do anything\n        initialize_tracks(segments: segment.Segment[], track_target: track.Track, track_user_input: track.Track, matrix_target: TargetIterator[][]) {\n            return\n        }\n\n        initialize_parse(struct_parse: StructParse, segments: Segment[]) {\n            // add the root to the tree immediately\n            struct_parse.set_root(\n                ParseTree.create_root_from_segments(\n                    segments\n                )\n            );\n\n            for (let i_segment in segments) {\n\n                let segment = segments[Number(i_segment)];\n\n                let note = segment.get_note();\n\n                let coord_current_virtual = [0, Number(i_segment)];\n\n                struct_parse.add(\n                    [note],\n                    coord_current_virtual,\n                    this\n                );\n            }\n        }\n\n        initialize_render(window: Window, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]) {\n            // first layer (root)\n            window.add_note_to_clip_root(\n                StructParse.create_root_from_segments(\n                    segments\n                )\n            );\n\n            for (let i_segment in segments) {\n\n                let segment = segments[Number(i_segment)];\n\n                let note_segment = segment.get_note();\n\n                let coord_current_virtual_second_layer = [0, Number(i_segment)];\n\n                // second layer\n                window.add_notes_to_clip(\n                    [note_segment],\n                    coord_current_virtual_second_layer,\n                    this\n                );\n            }\n        }\n\n        finish_parse(struct_parse: StructParse, segments: Segment[]): void {\n            return\n        }\n    }\n}"]}