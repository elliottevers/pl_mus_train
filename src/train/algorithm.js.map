{"version":3,"file":"algorithm.js","sourceRoot":"","sources":["algorithm.ts"],"names":[],"mappings":"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","sourcesContent":["import {note, note as n} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {harmony} from \"../music/harmony\";\nimport {modes_texture} from \"../constants/constants\";\nimport {user_input} from \"../control/user_input\";\nimport {history} from \"../history/history\";\nimport {clip} from \"../clip/clip\";\nimport {parse} from \"../parse/parse\";\nimport {segment} from \"../segment/segment\";\nimport {track} from \"../track/track\";\nimport {window} from \"../render/window\";\nimport {iterate} from \"./iterate\";\nimport {message} from \"../message/messenger\";\nimport {target} from \"../target/target\";\nimport {scene} from \"../scene/scene\";\nimport {utils} from \"../utils/utils\";\nimport {song} from \"../song/song\";\nimport {trainer} from \"./trainer\";\nimport {log} from \"../log/logger\";\nconst _ = require('underscore');\n\nexport namespace algorithm {\n    import Song = song.Song;\n    export let DETECT = 'detect';\n    export let PREDICT = 'predict';\n    export let PARSE = 'parse';\n    export let DERIVE = 'derive';\n    export let FREESTYLE = 'freestyle';\n    import Harmony = harmony.Harmony;\n    import POLYPHONY = modes_texture.POLYPHONY;\n    import MONOPHONY = modes_texture.MONOPHONY;\n    import TypeSequenceTarget = history.TypeSequenceTarget;\n    import Note = note.Note;\n    import ParseTree = parse.ParseTree;\n    import StructParse = parse.StructParse;\n    import Segment = segment.Segment;\n    import Window = window.Window;\n    import Track = track.Track;\n    import MatrixIterator = iterate.MatrixIterator;\n    import Messenger = message.Messenger;\n    import Subtarget = target.Subtarget;\n    import TargetIterator = target.TargetIterator;\n    import ClipDao = clip.ClipDao;\n    import Target = target.Target;\n    import FactoryMatrixObjectives = iterate.FactoryMatrixObjectives;\n    import Scene = scene.Scene;\n    import UserInputHandler = user_input.UserInputHandler;\n    import Clip = clip.Clip;\n    import HistoryUserInput = history.HistoryUserInput;\n    import StructTrain = trainer.StructTrain;\n    import MatrixWindow = window.MatrixWindow;\n    import StructTargets = trainer.StructTargets;\n    import Logger = log.Logger;\n\n\n    interface Temporal {\n        determine_region_present(\n            notes_next: TreeModel.Node<Note>[],\n            segment_current: Segment\n        )\n\n        stream_bounds(\n            messenger: message.Messenger,\n            subtarget_current: Subtarget,\n            segment_current: Segment,\n            segments: Segment[]\n        ): void\n    }\n\n    interface Renderable {\n        initialize_render(window: MatrixWindow, segments: Segment[], notes_track_target: TreeModel.Node<Note>[]): MatrixWindow\n        get_notes_in_region(target: Target, segment: Segment): TreeModel.Node<Note>[]\n    }\n\n    // interface that the trainer uses\n    export interface Trainable extends Temporal, Renderable {\n        depth: number;\n        b_parsed: boolean;\n        b_targeted: boolean;\n\n        get_name(): string\n        get_depth(): number\n        set_depth(depth: number): void\n        coord_to_index_clip(coord: number[]): number\n\n        preprocess_history_user_input(\n            history_user_input: HistoryUserInput,\n            segments: Segment[]\n        ): HistoryUserInput\n\n        create_struct_train(\n            window: Window,\n            segments: Segment[],\n            track_target: Track,\n            user_input_handler: UserInputHandler,\n            struct_train: StructTrain\n        ): StructTrain\n\n        terminate(\n            struct_train: StructTrain,\n            segments: Segment[]\n        )\n\n        advance_scene(\n            scene_current: Scene,\n            song: Song\n        )\n\n        unpause(\n            song: Song,\n            scene_current: Scene\n        )\n\n        pause(\n            song: Song,\n            scene_current: Scene\n        )\n\n        preprocess_struct_train(\n            struct_train: StructTrain,\n            segments: Segment[],\n            notes_target_track: TreeModel.Node<Note>[]\n        ): StructTrain\n\n        update_struct(\n            notes_input_user: TreeModel.Node<Note>[],\n            struct_train: StructTrain,\n            trainable: Trainable,\n            iterator_matrix_train: MatrixIterator\n        ): StructTrain\n\n        initialize_tracks(\n            segments: segment.Segment[],\n            track_target: track.Track,\n            track_user_input: track.Track,\n            // matrix_target: TargetIterator[][]\n            struct_train: StructTrain\n        )\n\n        update_history_user_input(\n            input_postprocessed: TreeModel.Node<Note>[],\n            history_user_input: HistoryUserInput,\n            iterator_matrix_train: MatrixIterator\n        ): HistoryUserInput\n\n        warrants_advance(\n            notes_user_input: TreeModel.Node<Note>[],\n            subtarget_current: Subtarget\n        ): boolean\n\n        postprocess_user_input(\n            notes_user_input: TreeModel.Node<Note>[],\n            subtarget_current: Subtarget\n        ): TreeModel.Node<Note>[]\n    }\n\n    // interface common to both parse and derive, but have different implementations\n    export interface Parsable extends Trainable {\n        preprocess_struct_parse(struct_parse, segments, track_target)\n        finish_parse(struct_parse: StructParse, segments: Segment[]): void;\n        update_roots(coords_roots_previous: number[][], coords_notes_to_grow: number[][], coord_notes_current: number[])\n        get_coords_notes_to_grow(coords_note_input_current): number[][]\n        grow_layer(notes_user_input_renderable, notes_to_grow)\n    }\n\n    // interface common to both detect and predict, but have different implementations\n    export interface Targetable extends Trainable {\n        determine_targets(user_input_handler: UserInputHandler, notes_in_segment: TreeModel.Node<Note>[])\n        postprocess_subtarget(subtarget: Subtarget)\n    }\n\n    // logic common to detect and predict\n    abstract class Targeted implements Targetable {\n\n        update_history_user_input(\n            input_postprocessed: TreeModel.Node<note.Note>[],\n            history_user_input: history.HistoryUserInput,\n            iterator_matrix_train: iterate.MatrixIterator\n        ): history.HistoryUserInput {\n            history_user_input.concat(\n                input_postprocessed,\n                iterator_matrix_train.get_coord_current()\n            );\n            return history_user_input\n        }\n\n        public b_parsed: boolean = false;\n        public b_targeted: boolean = true;\n        public depth: number;\n\n        public abstract get_name()\n\n        public abstract initialize_tracks(segments: segment.Segment[], track_target: track.Track, track_user_input: track.Track, struct_train: StructTrain)\n\n        public abstract determine_targets(user_input_handler: UserInputHandler, notes_segment_next: TreeModel.Node<n.Note>[]): TypeSequenceTarget\n\n        public get_depth(): number {\n            return 1\n        }\n\n        coord_to_index_clip(coord: number[]): number {\n            return 0;\n        }\n\n        public determine_region_present(notes_target_next: TreeModel.Node<Note>[], segment_current: Segment): number[] {\n            return [\n                notes_target_next[0].model.note.beat_start,\n                notes_target_next[0].model.note.get_beat_end()\n            ]\n        }\n\n        get_notes_in_region(target: target.Target, segment: segment.Segment) {\n            return target.iterator_subtarget.subtargets.map((subtarget) => {\n                return subtarget.note\n            })\n        }\n\n        public abstract initialize_render(window: Window, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]): MatrixWindow\n\n        unpause(song: Song, scene_current: Scene) {\n            // not forcing legato so that it starts immediately\n            scene_current.fire(false)\n        }\n\n        postprocess_user_input(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current: target.Subtarget): TreeModel.Node<note.Note>[] {\n            return [subtarget_current.note];\n        }\n\n        public abstract postprocess_subtarget(subtarget: Subtarget)\n\n        // TODO: verify that we don't need to do anything\n        terminate(struct_train: StructTrain, segments: Segment[]) {\n            return\n        }\n\n        pause(song: Song, scene_current: Scene) {\n            song.stop()\n        }\n\n        warrants_advance(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current): boolean {\n            return utils.remainder(notes_user_input[0].model.note.pitch, 12) === utils.remainder(subtarget_current.note.model.note.pitch, 12)\n        }\n\n        preprocess_struct_train(struct_train: StructTrain, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]): StructTrain {\n            return this.preprocess_struct_targets(struct_train as StructTargets, segments, notes_target_track) as StructTrain\n        }\n\n        preprocess_struct_targets(struct_targets: StructTargets, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]): StructTargets {\n            return struct_targets\n        }\n\n        public create_matrix_targets(user_input_handler: UserInputHandler, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]): TargetIterator[][] {\n\n            let matrix_targets = FactoryMatrixObjectives.create_matrix_objectives(\n                this,\n                segments\n            );\n\n            for (let i_segment in segments) {\n                let segment = segments[Number(i_segment)];\n\n                let notes_in_segment = notes_target_track.filter(\n                    node => node.model.note.beat_start >= segment.get_endpoints_loop()[0] && node.model.note.get_beat_end() <= segment.get_endpoints_loop()[1]\n                );\n\n                let sequence_targets = this.determine_targets(\n                    user_input_handler,\n                    notes_in_segment\n                );\n\n                matrix_targets[0][Number(i_segment)] = TargetIterator.from_sequence_target(sequence_targets);\n            }\n\n            return matrix_targets\n        }\n\n        private static stream_subtarget_bounds(messenger: message.Messenger, subtarget_current: Subtarget, segment_current: Segment, segments: Segment[]) {\n            messenger.message(['offset_beats_current_segment', segment_current.beat_start], true);\n            messenger.message(['duration_beats_current_segment', segment_current.beat_end - segment_current.beat_start], true);\n            messenger.message(['duration_training_data', segments[segments.length - 1].beat_end], true);\n            let length_segment = segment_current.get_note().model.note.get_beat_end() - segment_current.get_note().model.note.beat_start;\n            messenger.message(\n                [\n                    'bounds',\n                    subtarget_current.note.model.note.beat_start/length_segment,\n                    subtarget_current.note.model.note.get_beat_end()/length_segment\n                ],\n                true\n            )\n        }\n\n        stream_bounds(\n            messenger: message.Messenger,\n            subtarget_current: Subtarget,\n            segment_current: Segment,\n            segments: Segment[]\n        ): void {\n            Targeted.stream_subtarget_bounds(messenger, subtarget_current, segment_current, segments)\n        }\n\n        update_struct(notes_input_user: TreeModel.Node<note.Note>[], struct_train: StructTrain, trainable: Trainable, iterator_matrix_train: iterate.MatrixIterator): StructTrain {\n            return struct_train;\n        }\n\n        create_struct_train(window: window.Window, segments: segment.Segment[], track_target: track.Track, user_input_handler: user_input.UserInputHandler, struct_train: trainer.StructTrain): trainer.StructTrain {\n            let notes_target_track = track_target.get_notes();\n            return this.create_matrix_targets(user_input_handler, segments, notes_target_track);\n        }\n\n        set_depth(): void {\n\n        }\n\n        advance_scene(scene_current: scene.Scene, song: song.Song) {\n            scene_current.fire(true);\n        }\n\n        preprocess_history_user_input(history_user_input: history.HistoryUserInput, segments: segment.Segment[]): HistoryUserInput {\n            return history_user_input\n        }\n    }\n\n    // logic common to parse and derive\n    abstract class Parsed implements Parsable {\n\n        public b_parsed: boolean = true;\n\n        public b_targeted: boolean = false;\n\n        public abstract get_name();\n\n        depth: number;\n\n        update_struct(notes_input_user: TreeModel.Node<Note>[], struct_train: StructTrain, trainable: Trainable, iterator_matrix_train: MatrixIterator): StructTrain {\n\n            let struct_parse = struct_train as StructParse;\n\n            struct_parse.add(\n                notes_input_user,\n                iterator_matrix_train.get_coord_current(),\n                trainable as Parsable\n            );\n\n            return struct_parse\n        }\n\n        public abstract initialize_render(window: Window, segments: Segment[], notes_track_target: TreeModel.Node<Note>[]): MatrixWindow\n\n        public abstract initialize_tracks(segments: segment.Segment[], track_target: track.Track, track_user_input: track.Track, struct_train: StructTrain)\n\n        public update_history_user_input(\n            input_postprocessed: TreeModel.Node<Note>[],\n            history_user_input: HistoryUserInput,\n            iterator_matrix_train: MatrixIterator\n        ): HistoryUserInput {\n            history_user_input.concat(\n                input_postprocessed,\n                iterator_matrix_train.get_coord_current()\n            );\n            return history_user_input\n        }\n\n        public get_depth(): number {\n            return this.depth\n        }\n\n        set_depth(depth: number) {\n            this.depth = depth;\n        }\n\n        coord_to_index_clip(coord: number[]): number {\n            if (coord[0] === -1) {\n                return 0\n            } else {\n                return coord[0] + 1\n            }\n        }\n\n        create_struct_parse(segments: Segment[]): StructParse {\n            return new StructParse(\n                FactoryMatrixObjectives.create_matrix_objectives(\n                    this,\n                    segments\n                )\n            )\n        }\n\n        determine_region_present(notes_target_next: TreeModel.Node<Note>[], segment_current: Segment): number[] {\n            // return [\n            //     notes_target_next[0].model.note.beat_start,\n            //     notes_target_next[notes_target_next.length - 1].model.note.get_beat_end()\n            // ]\n            // let logger = new Logger('max');\n            // logger.log(JSON.stringify(segment_current));\n            return [\n                segment_current.beat_start,\n                segment_current.beat_end\n            ]\n        }\n\n        finish_parse(struct_parse: parse.StructParse, segments: segment.Segment[]): void {\n        }\n\n        public abstract get_coords_notes_to_grow(coords_note_input_current): number[][]\n\n        get_notes_in_region(target: target.Target, segment: segment.Segment) {\n            return [segment.get_note()]\n        }\n\n        public abstract grow_layer(notes_user_input_renderable, notes_to_grow)\n\n\n        preprocess_struct_train(struct_train: StructTrain, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]): StructTrain {\n            return this.preprocess_struct_parse(struct_train as StructParse, segments, notes_target_track)\n        }\n\n        public abstract preprocess_struct_parse(struct_parse, segments, track_target)\n\n        pause(song: Song, scene_current: Scene) {\n\n            song.set_overdub(0);\n\n            song.set_session_record(0);\n\n            song.stop()\n        }\n\n        postprocess_user_input(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current: target.Subtarget): TreeModel.Node<note.Note>[] {\n            return notes_user_input;\n        }\n\n        stream_bounds(\n            messenger: message.Messenger,\n            subtarget_current: target.Subtarget,\n            segment_current: segment.Segment,\n            segments: Segment[]\n        ): void {\n            Parsed.stream_segment_bounds(messenger, subtarget_current, segment_current, segments)\n        }\n\n        private static stream_segment_bounds(\n            messenger: message.Messenger,\n            subtarget_current: target.Subtarget,\n            segment_current: segment.Segment,\n            segments: Segment[]\n        ) {\n            // route offset_beats_current_segment duration_beats_current_segment duration_training_data\n            messenger.message(['offset_beats_current_segment', segment_current.beat_start], true);\n            messenger.message(['duration_beats_current_segment', segment_current.beat_end - segment_current.beat_start], true);\n            messenger.message(['duration_training_data', segments[segments.length - 1].beat_end], true);\n            messenger.message(['bounds', 0, 1], true)\n        }\n\n        terminate(struct_train: StructTrain, segments: Segment[]) {\n            this.finish_parse(struct_train as StructParse, segments)\n        }\n\n        unpause(song: Song, scene_current: Scene) {\n            song.set_overdub(1);\n\n            song.set_session_record(1);\n\n            scene_current.fire(false);\n        }\n\n        public abstract update_roots(coords_roots_previous: number[][], coords_notes_to_grow: number[][], coord_notes_current: number[])\n\n        warrants_advance(notes_user_input: TreeModel.Node<note.Note>[], subtarget_current: target.Subtarget): boolean {\n            return true;\n        }\n\n        create_struct_train(window: window.Window, segments: segment.Segment[], track_target: track.Track, user_input_handler: user_input.UserInputHandler, struct_train: trainer.StructTrain): trainer.StructTrain {\n            return this.create_struct_parse(segments);\n        }\n\n        advance_scene(scene_current: scene.Scene, song: song.Song) {\n\n            song.set_overdub(1);\n\n            song.set_session_record(1);\n\n            scene_current.fire(true);\n        }\n\n        preprocess_history_user_input(history_user_input: history.HistoryUserInput, segments: segment.Segment[]): HistoryUserInput {\n            for (let i_segment in segments) {\n                let segment = segments[Number(i_segment)];\n                history_user_input.concat(\n                    [segment.get_note()],\n                    [0, Number(i_segment)]\n                )\n            }\n            return history_user_input\n        }\n    }\n\n    export class Detect extends Targeted {\n\n        constructor() {\n            super();\n        }\n\n        determine_targets(user_input_handler: UserInputHandler, notes_segment_next: TreeModel.Node<n.Note>[]): TypeSequenceTarget {\n            if (user_input_handler.mode_texture === POLYPHONY) {\n\n                let chords_grouped: TreeModel.Node<n.Note>[][] = Harmony.group(\n                    notes_segment_next\n                );\n\n                let chords_monophonified: TypeSequenceTarget = [];\n\n                for (let note_group of chords_grouped) {\n                    chords_monophonified.push(\n                        Harmony.monophonify(\n                            note_group\n                        )\n                    );\n                }\n\n                return chords_monophonified\n\n            } else if (user_input_handler.mode_texture === MONOPHONY) {\n\n                let notes_grouped_trivial: TypeSequenceTarget = [];\n\n                for (let note of notes_segment_next) {\n                    notes_grouped_trivial.push([note])\n                }\n                return notes_grouped_trivial\n\n            } else {\n                throw ['texture mode', user_input_handler.mode_texture, 'not supported'].join(' ')\n            }\n        }\n\n        public get_name(): string {\n            return DETECT\n        }\n\n        postprocess_subtarget(note_subtarget) {\n            return note_subtarget\n        }\n\n        // TODO: verify that we don't have to do anything here\n        initialize_render(window: window.MatrixWindow, segments: segment.Segment[], notes_target_track: TreeModel.Node<note.Note>[]): MatrixWindow {\n            return window\n        }\n\n        initialize_tracks(segments: segment.Segment[], track_target: track.Track, track_user_input: track.Track, struct_train: StructTrain) {\n            return\n        }\n    }\n\n    export class Predict extends Targeted {\n\n        public get_name(): string {\n            return PREDICT\n        }\n\n        determine_targets(user_input_handler: UserInputHandler, notes_segment_next: TreeModel.Node<n.Note>[]): TypeSequenceTarget {\n\n            if (user_input_handler.mode_texture === POLYPHONY) {\n\n                // let chords_grouped: TreeModel.Node<n.Note>[][] = Harmony.group(\n                //     notes_segment_next\n                // );\n                //\n                // let chords_monophonified: TypeSequenceTarget = [];\n                //\n                // for (let note_group of chords_grouped) {\n                //     chords_monophonified.push(\n                //         Harmony.monophonify(\n                //             note_group\n                //         )\n                //     );\n                // }\n\n                throw 'polyphonic targets for prediction not yet implemented'\n\n            } else if (user_input_handler.mode_texture === MONOPHONY) {\n\n                let notes_grouped: TypeSequenceTarget = [];\n\n                // partition segment into measures\n\n                let position_measure = (node) => {\n                    Math.floor(node.model.note.beat_start/4)\n                };\n\n                let note_partitions: TreeModel.Node<Note>[][] = _.groupBy(notes_segment_next, position_measure);\n\n                for (let partition of note_partitions) {\n                    // get the middle note of the measure\n                    notes_grouped.push([partition[partition.length/2]])\n                }\n\n                return notes_grouped\n\n            } else {\n                throw ['texture mode', user_input_handler.mode_texture, 'not supported'].join(' ')\n            }\n        }\n\n        postprocess_subtarget(note_subtarget) {\n            note_subtarget.model.note.muted = 1;\n            return note_subtarget;\n        }\n\n        // TODO: verify that we don't have to do anythiing here\n        initialize_render(window: window.MatrixWindow, segments: segment.Segment[], notes_target_track: TreeModel.Node<note.Note>[]) {\n            return window\n        }\n\n        // NB: we only have to initialize clips in the target track\n        initialize_tracks(segments: segment.Segment[], track_target: track.Track, track_user_input: track.Track, struct_train: StructTrain) {\n\n            let matrix_targets = struct_train;\n\n            for (let i_segment in segments) {\n                let segment = segments[Number(i_segment)];\n\n                let targeted_notes_in_segment = matrix_targets[0][Number(i_segment)].get_notes();\n\n                // TODO: this won't work for polyphony\n                for (let note of targeted_notes_in_segment) {\n\n                    segment.clip_user_input.remove_notes(\n                        note.model.note.beat_start,\n                        0,\n                        note.model.note.get_beat_end(),\n                        128\n                    );\n\n                    segment.clip_user_input.set_notes(\n                        [note]\n                    )\n                }\n            }\n        }\n    }\n\n    export class Parse extends Parsed {\n\n        constructor() {\n            super();\n        }\n\n        public get_name(): string {\n            return PARSE\n        }\n\n        grow_layer(notes_user_input_renderable, notes_to_grow) {\n            ParseTree.add_layer(\n                notes_user_input_renderable,\n                notes_to_grow,\n                -1\n            )\n        }\n\n        // TODO: we don't need the target track - we should 1) transfer all notes over to user input track and 2) mute the track\n        initialize_tracks(segments: segment.Segment[], track_target: track.Track, track_user_input: track.Track, struct_train: StructTrain) {\n            // transfer notes from target track to user input track\n            for (let i_segment in segments) {\n\n                let clip_target = track_target.get_clip_at_index(Number(i_segment));\n\n                let clip_user_input = track_user_input.get_clip_at_index(Number(i_segment));\n\n                let notes = clip_target.get_notes(\n                    clip_target.get_loop_bracket_lower(),\n                    0,\n                    clip_target.get_loop_bracket_upper(),\n                    128\n                );\n\n                clip_user_input.remove_notes(\n                    clip_target.get_loop_bracket_lower(),\n                    0,\n                    clip_target.get_loop_bracket_upper(),\n                    128\n                );\n\n                clip_user_input.set_notes(\n                    notes\n                )\n            }\n\n            // mute target track\n            track_target.mute()\n        }\n\n        // add the root up to which we're going to parse\n        // add the segments as the layer below\n        // add the leaf notes\n        initialize_render(window: MatrixWindow, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]): MatrixWindow {\n            // first layer\n            window.add_note_to_clip_root(\n                StructParse.create_root_from_segments(\n                    segments\n                )\n            );\n\n            for (let i_segment in segments) {\n\n                let segment = segments[Number(i_segment)];\n\n                let note_segment = segment.get_note();\n\n                let coord_current_virtual_second_layer = [0, Number(i_segment)];\n\n                let notes_leaves = notes_target_track.filter(\n                    node => node.model.note.beat_start >= segment.get_endpoints_loop()[0] && node.model.note.get_beat_end() <= segment.get_endpoints_loop()[1]\n                );\n\n                let coord_current_virtual_leaves = [this.get_depth() - 1, Number(i_segment)];\n\n                // second layer\n                window.add_notes_to_clip(\n                    [note_segment],\n                    coord_current_virtual_second_layer,\n                    this\n                );\n\n                // leaves\n                window.add_notes_to_clip(\n                    notes_leaves,\n                    coord_current_virtual_leaves,\n                    this\n                )\n            }\n\n            return window\n        }\n\n        update_roots(coords_roots_previous: number[][], coords_notes_previous: number[][], coord_notes_current: number[]) {\n            let coords_roots_new = [];\n\n            // remove references to old leaves\n            for (let coord_notes_previous of coords_notes_previous) {\n                coords_roots_new = coords_roots_new.concat(\n                    coords_roots_previous.filter((x) => {\n                        return !(x[0] === coord_notes_previous[0] && x[1] === coord_notes_previous[1])\n                    })\n                );\n            }\n\n            // add references to new leaves\n            coords_roots_new.push(\n                coord_notes_current\n            );\n        }\n\n        get_coords_notes_to_grow(coord_notes_input_current) {\n            return MatrixIterator.get_coords_below([coord_notes_input_current[0], coord_notes_input_current[1]]);\n        }\n\n        // adding the leaf notes to the actual parse tree\n        // DO NOT set the root or the segments as nodes immediately below that - do that at the end\n        // set the leaf notes as the notes in the target track\n        preprocess_struct_parse(struct_parse: StructParse, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]) {\n            // this is to set the leaves as the notes of the target clip\n\n            for (let i_segment in segments) {\n                let segment = segments[Number(i_segment)];\n\n                let notes = notes_target_track.filter(\n                    node => node.model.note.beat_start >= segment.get_endpoints_loop()[0] && node.model.note.get_beat_end() <= segment.get_endpoints_loop()[1]\n                );\n\n                let coord_current_virtual_leaf = [this.get_depth() - 1, Number(i_segment)];\n\n                struct_parse.add(\n                    notes,\n                    coord_current_virtual_leaf,\n                    this\n                );\n            }\n\n            return struct_parse\n        }\n\n        finish_parse(struct_parse: StructParse, segments: Segment[]): void {\n\n            // make connections with segments\n            for (let i_segment in segments) {\n                let segment = segments[Number(i_segment)];\n                struct_parse.add(\n                    [segment.get_note()],\n                    [0, Number(i_segment)],\n                    this\n                );\n            }\n\n            struct_parse.set_root(\n                StructParse.create_root_from_segments(\n                    segments\n                )\n            );\n\n            // make connections with root\n            struct_parse.add(\n                [Note.from_note_renderable(struct_parse.get_root())],\n                [-1],\n                this\n            );\n        }\n    }\n\n    export class Derive extends Parsed {\n\n        public get_name(): string {\n            return DERIVE\n        }\n\n        get_coords_notes_to_grow(coords_note_input_current) {\n            return MatrixIterator.get_coords_above([coords_note_input_current[0], coords_note_input_current[1]])\n        }\n\n        grow_layer(notes_user_input_renderable, notes_to_grow) {\n            ParseTree.add_layer(\n                notes_to_grow,\n                notes_user_input_renderable,\n                -1\n            )\n        }\n\n        initialize_tracks(segments: segment.Segment[], track_target: track.Track, track_user_input: track.Track, struct_train: StructTrain) {\n            track_target.mute();\n        }\n\n        preprocess_struct_parse(struct_parse: StructParse, segments: Segment[]): StructParse {\n            // add the root to the tree immediately\n            struct_parse.set_root(\n                ParseTree.create_root_from_segments(\n                    segments\n                )\n            );\n\n            for (let i_segment in segments) {\n\n                let segment = segments[Number(i_segment)];\n\n                let note = segment.get_note();\n\n                let coord_current_virtual = [0, Number(i_segment)];\n\n                struct_parse.add(\n                    [note],\n                    coord_current_virtual,\n                    this\n                );\n            }\n\n            return struct_parse\n        }\n\n        initialize_render(window: MatrixWindow, segments: Segment[], notes_target_track: TreeModel.Node<Note>[]): MatrixWindow {\n            // first layer (root)\n            window.add_note_to_clip_root(\n                StructParse.create_root_from_segments(\n                    segments\n                )\n            );\n\n            for (let i_segment in segments) {\n\n                let segment = segments[Number(i_segment)];\n\n                let note_segment = segment.get_note();\n\n                let coord_current_virtual_second_layer = [0, Number(i_segment)];\n\n                // second layer\n                window.add_notes_to_clip(\n                    [note_segment],\n                    coord_current_virtual_second_layer,\n                    this\n                );\n            }\n\n            return window\n        }\n\n        finish_parse(struct_parse: StructParse, segments: Segment[]): void {\n            return\n        }\n\n        update_roots(coords_roots_previous: number[][], coords_notes_previous: number[][], coord_notes_current: number[]) {\n            return coords_roots_previous\n        }\n    }\n}"]}