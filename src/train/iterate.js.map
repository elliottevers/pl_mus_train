{"version":3,"file":"iterate.js","sourceRoot":"","sources":["iterate.ts"],"names":[],"mappings":"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","sourcesContent":["import {algorithm, algorithm as algo} from \"./algorithm\";\nimport {utils} from \"../utils/utils\";\nimport {segment} from \"../segment/segment\";\n\nexport namespace iterate {\n    import division_int = utils.division_int;\n    import remainder = utils.remainder;\n    import Algorithm = algorithm.Algorithm;\n    import Segment = segment.Segment;\n\n    export class MatrixIterator {\n\n        private num_rows: number;\n        private num_columns: number;\n\n        private downward: boolean;\n        private rightward: boolean;\n\n        private index_row_start: number;\n        private index_row_stop: number;\n\n        private i;\n        private index_start;\n        private index_stop;\n\n        private history: number[];\n\n        constructor(num_rows: number, num_columns: number, downward?: boolean, rightward?: boolean, start_at_row?: number, stop_at_row?: number) {\n            this.num_rows = num_rows;\n            this.num_columns = num_columns;\n\n            this.downward = (downward == null) ? true : downward;\n            this.rightward = (rightward == null) ? true : rightward;\n\n            this.index_row_start = start_at_row;\n            this.index_row_stop = stop_at_row;\n\n            this.determine_index_start();\n            this.determine_index_stop();\n\n            this.i = this.index_start;\n            this.history = [];\n        }\n\n        private determine_index_start() {\n\n            let i_start;\n\n            if (this.downward && this.rightward) {\n                i_start = -1 + (this.num_columns * this.index_row_start) - this.num_columns\n            } else if (!this.downward && this.rightward) {\n                i_start = (this.num_columns * (this.index_row_start + 2)) - 1 - this.num_columns\n            } else if (this.downward && !this.rightward) {\n                throw 'not yet supported'\n            }\n            else if (!this.downward && !this.rightward) {\n                throw 'not yet supported'\n            }\n            else {\n                throw 'not yet supported'\n            }\n\n            this.index_start = i_start;\n        }\n\n        private determine_index_stop() {\n\n            let i_stop;\n\n            if (this.downward && this.rightward) {\n                i_stop = this.index_row_stop * this.num_columns\n            } else if (!this.downward && this.rightward) {\n                i_stop = (this.index_row_stop - 1) * this.num_columns\n            } else if (this.downward && !this.rightward) {\n                throw 'not yet supported'\n            }\n            else if (!this.downward && !this.rightward) {\n                throw 'not yet supported'\n            }\n            else {\n                throw 'not yet supported'\n            }\n\n            this.index_stop = i_stop;\n        }\n\n        private next_column() {\n            if (this.downward && this.rightward) {\n                this.i++;\n            } else if (!this.downward && this.rightward) {\n                if (remainder(this.i + 1, this.num_columns) === 0) {\n                    this.i = this.i - (this.num_columns - 1) - this.num_columns\n                } else {\n                    this.i++\n                }\n            } else if (this.downward && !this.rightward) {\n                // if (remainder(this.i + 1, this.num_rows) === 0) {\n                //     this.i = this.i + (this.num_columns - 1) + this.num_columns\n                // } else {\n                //     this.i--\n                // }\n                throw 'not yet supported'\n            } else if (!this.downward && !this.rightward) {\n                // this.i--;\n                throw 'not yet supported'\n            } else {\n                throw 'not yet supported'\n            }\n        }\n\n        add_history(i): void {\n            this.history.push(i)\n        }\n\n        get_history(): number[] {\n            return this.history\n        }\n\n        public next() {\n\n            let value: number[] = null;\n\n            this.next_column();\n\n            this.add_history(this.i);\n\n            if (this.i === this.index_stop) {\n                return {\n                    value: value,\n                    done: true\n                }\n            }\n\n            return {\n                value: this.get_coord_current(),\n                done: false\n            };\n        }\n\n        public get_coord_current(): number[] {\n            return MatrixIterator.get_coord(this.get_state_current(), this.num_columns)\n        }\n\n        public get_state_current(): number {\n            return this.i;\n        }\n\n        public static get_coord(i, num_columns): number[] {\n            let pos_row = division_int(i, num_columns);\n            let pos_column = remainder(i, num_columns);\n            return [pos_row, pos_column]\n        }\n\n        public static get_coords_above(coord): number[][] {\n            return [[coord[0] - 1, coord[1]]]\n        }\n\n        public static get_coords_below(coord): number[][] {\n            return [[coord[0] + 1, coord[1]]]\n        }\n    }\n\n    export class FactoryMatrixTargetIterator {\n        public static create_matrix_focus(algorithm: Algorithm, segments: Segment[]): any[][] {\n            let matrix_data = [];\n            switch(algorithm.get_name()) {\n                case algo.DETECT || algo.PREDICT: {\n                    for (let i=0; i < 1; i++) {\n                        matrix_data[i] = new Array(segments.length);\n                    }\n                    break;\n                }\n                case algo.PARSE || algo.DERIVE: {\n                    for (let i=0; i < algorithm.get_depth(); i++) {\n                        matrix_data[i] = new Array(segments.length);\n                    }\n                    break;\n                }\n                default: {\n                    throw 'case not considered';\n                }\n            }\n            return matrix_data;\n        }\n    }\n\n    export class IteratorTrainFactory {\n        public static get_iterator_train(algorithm: Algorithm, segments: Segment[]) {\n\n            let iterator: MatrixIterator;\n\n            let downward, rightward;\n\n            switch (algorithm.get_name()) {\n                case algo.DETECT: {\n                    iterator = new MatrixIterator(1, segments.length);\n                    break;\n                }\n                case algo.PREDICT: {\n                    iterator = new MatrixIterator(1, segments.length);\n                    break;\n                }\n                case algo.PARSE: {\n                    downward = false;\n                    rightward = true;\n                    let index_row_start = algorithm.get_depth() - 1;\n                    let index_row_stop = 1;\n                    iterator = new MatrixIterator(\n                        algorithm.get_depth(),\n                        segments.length,\n                        downward,\n                        rightward,\n                        index_row_start,\n                        index_row_stop\n                    );\n                    break;\n                }\n                case algo.DERIVE: {\n                    downward = true;\n                    rightward = true;\n                    let index_row_start = 1;\n                    let index_row_stop = algorithm.get_depth();\n                    iterator = new MatrixIterator(\n                        algorithm.get_depth(),\n                        segments.length,\n                        downward,\n                        rightward,\n                        index_row_start,\n                        index_row_stop\n                    );\n                    break;\n                }\n                default: {\n                    throw ['algorithm of name', algorithm.get_name(), 'not supported'].join(' ')\n                }\n            }\n            return iterator\n        }\n    }\n}"]}