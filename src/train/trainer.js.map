{"version":3,"file":"trainer.js","sourceRoot":"","sources":["trainer.ts"],"names":[],"mappings":";;AAEA,oDAA4D;AAC5D,yCAA6C;AAC7C,8CAA2C;AAE3C,IAAiB,OAAO,CAiJvB;AAjJD,WAAiB,OAAO;IAEpB,IAAO,UAAU,GAAG,iBAAK,CAAC,SAAS,CAAC,UAAU,CAAC;IAC/C,IAAO,gBAAgB,GAAG,iBAAO,CAAC,gBAAgB,CAAC;IAEnD;QAKI,gCAAgC;QAChC,qCAAqC;QACrC,wDAAwD;QACxD,UAAU;QACV,iBAAY,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,eAAe;YAChD,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;YACrB,IAAI,IAAI,KAAK,KAAK,CAAC,OAAO,EAAE;aAE3B;YACD,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;YAC3B,IAAI,CAAC,kBAAkB,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,CAAC;YACrD,IAAI,CAAC,eAAe,GAAG,eAAe,CAAA;YACtC,IAAI,CAAC,MAAM,GAAG,IAAI,aAAa,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA;QACpD,CAAC;QAEM,kCAAgB,GAAvB;YACI,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,UAAU,CAAC,OAAO,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE;gBACvE,eAAe,CAAC,SAAS,CACrB,IAAI,CAAC,MAAM,CAAC,SAAS;gBACjB,mCAAmC;iBACtC,CACJ,CAAC;aACL;iBAAM;aAEN;QACL,CAAC;QAEO,0BAAQ,GAAhB;YACI,IAAI,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,EAAE,CAAC;YAEzD,IAAI,CAAC,eAAe,CAAC,kBAAkB,CACnC,QAAQ,CAAC,CAAC,CAAC,EACX,QAAQ,CAAC,CAAC,CAAC,CACd,CAAA;QACL,CAAC;QAEM,wBAAM,GAAb;YACI,sBAAsB;YACtB,qBAAqB;YACrB,wBAAwB;YACxB,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE,CAAA;QAC9B,CAAC;QAEM,uBAAK,GAAZ;YACI,IAAI,CAAC,SAAS,CAAC,aAAa,EAAE,CAAA;QAClC,CAAC;QAEM,sBAAI,GAAX;YACI,IAAI,CAAC,eAAe,EAAE,CAAC;YACvB,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE,CAAA;QAC9B,CAAC;QAED,iCAAe,GAAf;YACI,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,CAAC;YACpD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC;YAClD,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,CAAC;YAEvD,IAAI,IAAI,EAAE;gBACN,IAAI,CAAC,SAAS,CAAC,aAAa,EAAE,CAAA;aACjC;QACL,CAAC;QAED,gCAAc,GAAd;YACI,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,CAAA;QACrD,CAAC;QAED,mCAAiB,GAAjB;YACI,IAAI,GAAG,GAAG,IAAI,CAAC,kBAAkB,CAAC,IAAI,EAAE,CAAC;YACzC,IAAI,GAAG,CAAC,IAAI,EAAE;gBACV,IAAI,CAAC,cAAc,EAAE,CAAA;aACxB;iBAAM;gBACH,IAAI,CAAC,iBAAiB,GAAG,GAAG,CAAC,KAAK,CAAA;aACrC;QACL,CAAC;QAED,8BAAY,GAAZ,UAAa,UAAU;YAEnB,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAE1B,IAAI,IAAI,CAAC,kBAAkB,IAAI,IAAI,CAAC,gBAAgB,EAAE;gBAClD,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAA;aAClC;YAED,IAAI,IAAI,CAAC,mBAAmB,EAAE;gBAC1B,oBAAoB;aACvB;YAED,IAAI,UAAU,GAAG,IAAI,CAAC,SAAS,YAAY,UAAU,CAAC;YAEtD,IAAI,CAAC,UAAU,EAAE;gBACb,IAAI,CAAC,eAAe,EAAE,CAAC;gBACvB,sCAAsC;aACzC;YAED,IAAI,UAAU,KAAK,IAAI,CAAC,iBAAiB,EAAE;gBACvC,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;gBACxC,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBACzB,wJAAwJ;gBACxJ,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;gBAC5B,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAA;aACvB;QACL,CAAC;QAEM,wBAAM,GAAb,UAAc,KAA+B;YACzC,wCAAwC;YAExC,IAAI,CAAC,MAAM,CAAC,MAAM,CACd,KAAK,CACR,CAAC;YAEF,yBAAY,CAAC,SAAS,CAClB,mBAAmB,CAAC,iBAAiB,EAAE,EACvC,gBAAgB,CAAC,iBAAiB,EAAE,EACpC,KAAK,CACR,CAAC;YAEF,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;YAErB,IAAI,YAAY,CAAC,IAAI,EAAE;gBAEnB,IAAI,CAAC,IAAI,EAAE,CAAC;gBAEZ,OAAM;aACT;YAED,IAAI,CAAC,eAAe,GAAG,gBAAgB,CAAC;YAExC,IAAI,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,EAAE,CAAC;YAEzD,IAAI,CAAC,eAAe,CAAC,kBAAkB,CACnC,QAAQ,CAAC,CAAC,CAAC,EACX,QAAQ,CAAC,CAAC,CAAC,CACd,CAAC;QACN,CAAC;QACL,cAAC;IAAD,CAAC,AA3ID,IA2IC;IA3IY,eAAO,UA2InB,CAAA;AACL,CAAC,EAjJgB,OAAO,GAAP,eAAO,KAAP,eAAO,QAiJvB","sourcesContent":["import {note as n} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {parse_matrix, pwindow} from \"../scripts/parse_tree\";\nimport {algorithm, train} from \"./algorithm\";\nimport {history} from \"../history/history\";\n\nexport namespace trainer {\n\n    import Targetable = train.algorithm.Targetable;\n    import HistoryUserInput = history.HistoryUserInput;\n\n    export class Trainer {\n\n        private history_user_input;\n        private algorithm; // TODO: annotation\n\n        // window is either tree or list\n        // mode is either harmonic or melodic\n        // algorithm is either detect, predict, parse, or derive\n        // history\n        constructor(window, mode, algorithm, clip_user_input) {\n            this.window = window;\n            if (mode === modes.HARMONY) {\n\n            }\n            this.algorithm = algorithm;\n            this.history_user_input = new HistoryUserInput(mode);\n            this.clip_user_input = clip_user_input\n            this.struct = new StructFactory.get_struct(mode)\n        }\n\n        public reset_user_input() {\n            if ([algorithms.DETECT, algorithms.PREDICT].includes(this.algorithm.name)) {\n                clip_user_input.set_notes(\n                    this.struct.get_notes(\n                        // TODO: pass requisite information\n                    )\n                );\n            } else {\n\n            }\n        }\n\n        private set_loop() {\n            let interval = this.segment_current.get_endpoints_loop();\n\n            this.clip_user_input.set_endpoints_loop(\n                interval[0],\n                interval[1]\n            )\n        }\n\n        public resume() {\n            // set segment current\n            // set target current\n            // set subtarget current\n            this.algorithm.post_init()\n        }\n\n        public pause() {\n            this.algorithm.pre_terminate()\n        }\n\n        public init() {\n            this.advance_segment();\n            this.algorithm.post_init()\n        }\n\n        advance_segment() {\n            this.segment_current = this.segment_iterator.next();\n            this.target_current = this.target_iterator.next();\n            this.subtarget_current = this.subtarget_current.next();\n\n            if (done) {\n                this.algorithm.pre_terminate()\n            }\n        }\n\n        advance_target() {\n            this.target_current = this.target_iterator.next()\n        }\n\n        advance_subtarget() {\n            let val = this.subtarget_iterator.next();\n            if (val.done) {\n                this.advance_target()\n            } else {\n                this.subtarget_current = val.value\n            }\n        }\n\n        accept_input(input_user) {\n\n            this.counter_user_input++;\n\n            if (this.counter_user_input >= this.limit_user_input) {\n                this.limit_input_reached = true\n            }\n\n            if (this.limit_input_reached) {\n                // completely ignore\n            }\n\n            let targetable = this.algorithm instanceof Targetable;\n\n            if (!targetable) {\n                this.advance_segment();\n                // return this.segment_iterator.next()\n            }\n\n            if (input_user === this.subtarget_current) {\n                this.history_user_input.add(input_user);\n                this.advance_subtarget();\n                // TODO: make sure for detection/prediction we're making \"input_user\" exactly the same as the \"target note\", if we're restoring sessions from user input\n                this.window.add(input_user);\n                this.window.render()\n            }\n        }\n\n        public accept(notes: TreeModel.Node<n.Note>[]) {\n            // elaborate, summarize, detect, predict\n\n            this.window.insert(\n                notes\n            );\n\n            parse_matrix.set_notes(\n                tree_depth_iterator.get_index_current(),\n                segment_iterator.get_index_current(),\n                notes\n            );\n\n            this.window.render();\n\n            if (segment_next.done) {\n\n                this.stop();\n\n                return\n            }\n\n            this.segment_current = val_segment_next;\n\n            let interval = this.segment_current.get_endpoints_loop();\n\n            this.clip_user_input.set_endpoints_loop(\n                interval[0],\n                interval[1]\n            );\n        }\n    }\n}"]}