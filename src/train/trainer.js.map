{"version":3,"file":"trainer.js","sourceRoot":"","sources":["trainer.ts"],"names":[],"mappings":"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","sourcesContent":["import {note as n} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {algorithm} from \"./algorithm\";\nimport {history} from \"../history/history\";\nimport {target} from \"../target/target\";\nimport {segment} from \"../segment/segment\";\nimport {parse} from \"../parse/parse\";\nimport {message} from \"../message/messenger\";\nimport {song} from \"../song/song\";\nimport {clip} from \"../clip/clip\";\nimport {iterate} from \"./iterate\";\nconst _ = require('underscore');\nconst l = require('lodash');\n\nexport namespace trainer {\n\n    import HistoryUserInput = history.HistoryUserInput;\n    import TargetIterator = target.TargetIterator;\n    import Segment = segment.Segment;\n    import PARSE = algorithm.PARSE;\n    import DERIVE = algorithm.DERIVE;\n    import DETECT = algorithm.DETECT;\n    import PREDICT = algorithm.PREDICT;\n    import Subtarget = target.Subtarget;\n    import Target = target.Target;\n    import Messenger = message.Messenger;\n    import Song = song.Song;\n    import Clip = clip.Clip;\n    import SubtargetIterator = target.SubtargetIterator;\n    import StructParse = parse.StructParse;\n    import MatrixIterator = iterate.MatrixIterator;\n    import FactoryMatrixTargetIterator = iterate.FactoryMatrixTargetIterator;\n    import IteratorTrainFactory = iterate.IteratorTrainFactory;\n\n    export class Trainer {\n\n        private window;\n        private algorithm; // TODO: type\n        private clip_user_input: Clip;\n        private clip_target: Clip;\n        private song: Song;\n        private segments: Segment[];\n        private messenger: Messenger;\n\n        private struct_parse: StructParse;\n        public history_user_input;\n\n        private counter_user_input: number;\n        private limit_user_input: number;\n        private limit_input_reached: boolean;\n\n        private segment_current: Segment;\n        private target_current: Target;\n        private subtarget_current: Subtarget;\n\n        private matrix_focus: TargetIterator[][];\n        private iterator_matrix_train: MatrixIterator;\n        private iterator_target_current: TargetIterator;\n        private iterator_subtarget_current: SubtargetIterator;\n\n        constructor(window, user_input_handler, algorithm, clip_user_input, clip_target, song, segments, messenger) {\n            this.window = window;\n            this.algorithm = algorithm;\n            this.clip_user_input = clip_user_input;\n            this.clip_target = clip_target;\n            this.song = song;\n            this.segments = segments;\n            this.messenger = messenger;\n\n            this.iterator_matrix_train = IteratorTrainFactory.get_iterator_train(\n                this.algorithm,\n                this.segments\n            );\n\n            this.matrix_focus = FactoryMatrixTargetIterator.create_matrix_focus(\n                this.algorithm,\n                this.segments\n            );\n\n            this.history_user_input = new HistoryUserInput(\n                l.cloneDeep(this.matrix_focus)\n            );\n\n            this.window.initialize_clips(\n                this.algorithm,\n                this.segments\n            );\n\n            this.window.set_length_beats(\n                this.segments[this.segments.length - 1].beat_end\n            );\n\n            if (this.algorithm.b_targeted()) {\n                this.create_targets()\n            } else {\n                this.struct_parse = new StructParse(\n                    l.cloneDeep(this.matrix_focus)\n                );\n                this.initialize_struct_parse();\n            }\n        }\n\n        private initialize_struct_parse() {\n\n            let note_root = this.segments[0].get_note();\n\n            this.struct_parse.root = note_root;\n\n            // TODO: make the root the length of the entire song\n\n            this.window.add_note_to_clip_root(\n                note_root\n            );\n\n            // set first layer, which are the various key center estimates\n\n            for (let i_segment in this.segments) {\n                let segment = this.segments[Number(i_segment)];\n                let note = segment.get_note();\n                let coord_current_virtual = [0, Number(i_segment)];\n                // TODO: can we make a function to simultaneous add to all 3 of struct parse, history user input, and window?\n                this.struct_parse.matrix_leaves[coord_current_virtual[0]][coord_current_virtual[1]] = [note];\n                this.window.add_notes_to_clip(note, coord_current_virtual)\n            }\n\n            switch (this.algorithm.get_name()) {\n                case PARSE: {\n                    for (let i_segment in this.segments) {\n                        let segment = this.segments[Number(i_segment)];\n                        let notes = this.clip_target.get_notes(\n                            segment.beat_start,\n                            0,\n                            segment.beat_end - segment.beat_start,\n                            128\n                        );\n                        this.struct_parse.matrix_leaves[this.algorithm.get_depth() - 1][Number(i_segment)] = notes\n                    }\n                    break;\n                }\n                case DERIVE: {\n                    //  TODO: anything?\n                    break;\n                }\n                default: {\n                    throw ['algorithm of name', this.algorithm.get_name(), 'not supported'].join(' ')\n                }\n            }\n        }\n\n\n\n        // now we can assume we have a list instead of a matrix\n        private create_targets() {\n\n            this.clip_target.load_notes_within_markers();\n\n            for (let i_segment in this.segments) {\n                let sequence_targets = this.algorithm.determine_targets(\n                    this.clip_target.get_notes(\n                        this.segments[Number(i_segment)].beat_start,\n                        0,\n                        this.segments[Number(i_segment)].beat_end - this.segments[Number(i_segment)].beat_start,\n                        128\n                    )\n                );\n                this.matrix_focus[0][Number(i_segment)] = TargetIterator.from_sequence_target(sequence_targets);\n            }\n        }\n\n        public clear_window() {\n            this.window.clear()\n        }\n\n        public render_window() {\n            this.window.render(\n                this.iterator_matrix_train,\n                this.matrix_focus,\n                this.algorithm,\n                this.struct_parse\n            )\n        }\n\n        public reset_user_input() {\n            if (_.contains([DETECT, PREDICT], this.algorithm.get_name())) {\n                let coords = this.iterator_matrix_train.get_coord_current();\n                let notes_last = this.matrix_focus[coords[0] - 1][coords[1]].get_notes();\n                this.clip_user_input.set_notes(\n                    notes_last\n                );\n            } else {\n                return\n            }\n        }\n\n        private set_loop() {\n            let interval = this.segment_current.get_endpoints_loop();\n\n            this.clip_user_input.set_endpoints_loop(\n                interval[0],\n                interval[1]\n            )\n        }\n\n        public resume() {\n            this.algorithm.post_init()\n        }\n\n        public pause() {\n            this.algorithm.pre_terminate()\n        }\n\n        public terminate() {\n            this.algorithm.pre_terminate()\n        }\n\n        public init() {\n            if (this.algorithm.b_targeted()) {\n                this.advance_subtarget();\n            } else {\n                this.advance_segment();\n            }\n            this.algorithm.post_init(this.song, this.clip_user_input)\n        }\n\n        private advance_segment() {\n            // TODO:\n            let obj_next_coord = this.iterator_matrix_train.next();\n\n            if (obj_next_coord.done) {\n                if (this.algorithm.get_name() === PARSE) {\n                    // TODO: make the connections with the root\n                    // public add(notes_user_input, iterator_matrix_train, algorithm): void {\n                    for (let segment of this.segments) {\n                        this.struct_parse.add(\n                            [segment.get_note()],\n                            // this.struct_parse,\n                            this.iterator_matrix_train.get_coord_current(),\n                            this.algorithm\n                        );\n                    }\n                    this.struct_parse.finish()\n                }\n                this.algorithm.pre_terminate(this.song, this.clip_user_input)\n                return\n            }\n\n            let coord = obj_next_coord.value;\n\n            this.segment_current = this.segments[coord[1]];\n        }\n\n        private advance_subtarget() {\n\n            let possibly_history: Target[] = this.iterator_target_current.targets;\n\n            let coord_at_time: number[] = this.iterator_matrix_train.get_coord_current();\n\n            let obj_next_subtarget = this.iterator_subtarget_current.next();\n\n            if (obj_next_subtarget.done) {\n\n                let obj_next_target = this.iterator_target_current.next();\n\n                if (obj_next_target.done) {\n\n                    let obj_next_coord = this.iterator_matrix_train.next();\n\n                    this.history_user_input.add_sequence_target(\n                        possibly_history,\n                        coord_at_time\n                    );\n\n                    if (obj_next_coord.done) {\n                        this.history_user_input.add_sequence_target(\n                            possibly_history,\n                            coord_at_time\n                        );\n\n                        this.algorithm.pre_terminate();\n\n                        return\n                    }\n\n                    let coord_next = obj_next_coord.value;\n\n                    this.iterator_target_current = this.matrix_focus[coord_next[0]][coord_next[1]];\n\n                    this.segment_current = this.segments[coord_next[1]];\n\n                    let obj_next_target_twice_nested = this.iterator_target_current.next();\n\n                    this.target_current = obj_next_target_twice_nested.value;\n\n                    let obj_next_subtarget_twice_nested = this.target_current.iterator_subtarget.next();\n\n                    this.subtarget_current = obj_next_subtarget_twice_nested.value;\n\n                    this.iterator_subtarget_current = this.target_current.iterator_subtarget;\n\n                    return\n                }\n\n                this.target_current = obj_next_target.value;\n\n                let obj_next_subtarget_once_nested = this.target_current.iterator_subtarget.next();\n\n                this.subtarget_current = obj_next_subtarget_once_nested.value;\n\n                this.iterator_subtarget_current = this.target_current.iterator_subtarget;\n\n                return\n            }\n\n            this.subtarget_current = obj_next_subtarget.value;\n        }\n\n        // user input can be either 1) a pitch or 2) a sequence of notes\n        accept_input(notes_input_user: TreeModel.Node<n.Note>[]) {\n\n            this.counter_user_input++;\n\n            if (this.counter_user_input >= this.limit_user_input) {\n                this.limit_input_reached = true\n            }\n\n            if (this.limit_input_reached) {\n                // completely ignore\n                return\n            }\n\n            // parse/derive logic\n            if (!this.algorithm.b_targeted()) {\n\n                this.history_user_input.add(\n                    notes_input_user,\n                    this.iterator_matrix_train.get_coord_current()\n                );\n\n                this.window.add_notes_to_clip(\n                    notes_input_user,\n                    this.iterator_matrix_train.get_coord_current()\n                );\n\n                // TODO: implement\n                this.struct_parse.add(\n                    notes_input_user,\n                    this.iterator_matrix_train.get_coord_current(),\n                    this.algorithm\n                );\n\n                this.advance_segment();\n\n                this.render_window();\n\n                return\n            }\n\n            // detect/predict logic\n            // NB: assumes we're only giving list of a single note as input\n            if (notes_input_user[0].model.note.pitch === this.subtarget_current.note.model.note.pitch) {\n\n                this.window.add_notes_to_clip(\n                    [this.subtarget_current.note],\n                    this.iterator_matrix_train.get_coord_current()\n                );\n\n                if (this.algorithm.b_targeted()) {\n                    // set the targets and shit\n                }\n\n                this.advance_subtarget();\n\n                this.set_loop();\n\n                this.render_window();\n            }\n        }\n    }\n}"]}