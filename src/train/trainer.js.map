{"version":3,"file":"trainer.js","sourceRoot":"","sources":["trainer.ts"],"names":[],"mappings":"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","sourcesContent":["import {note as n} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {parse_matrix, pwindow} from \"../scripts/parse_tree\";\nimport {algorithm as algo, train} from \"./algorithm\";\nimport {history} from \"../history/history\";\nimport {target} from \"../target/target\";\nimport {segment} from \"../segment/segment\";\nimport {parse} from \"../parse/parse\";\nimport {utils} from \"../utils/utils\";\n\nexport namespace trainer {\n\n    import Targetable = train.algorithm.Targetable;\n    import HistoryUserInput = history.HistoryUserInput;\n    import TargetType = target.TargetType;\n    import TargetIterator = target.TargetIterator;\n    import MatrixIterator = history.MatrixIterator;\n    import Segment = segment.Segment;\n    import ParseTree = parse.ParseTree;\n    import Algorithm = algorithm.Algorithm;\n    import division_int = utils.division_int;\n    import remainder = utils.remainder;\n\n    export class MatrixIterator {\n        private num_rows: number;\n        private num_columns: number;\n\n        private row_current: number;\n        private column_current: number;\n\n        private i;\n\n        constructor(num_rows: number, num_columns: number) {\n            this.num_rows = num_rows;\n            this.num_columns = num_columns;\n\n            this.i = -1;\n        }\n\n        private next_row() {\n            this.i = this.i + this.num_columns;\n        }\n\n        private next_column() {\n            this.i = this.i + 1;\n        }\n\n        public next() {\n\n            let value: number[] = null;\n\n            this.next_column();\n\n            if (this.i === this.num_columns * this.num_rows + 1) {\n                return {\n                    value: value,\n                    done: true\n                }\n            }\n\n            let pos_row = division_int(this.i + 1, this.num_columns);\n            let pos_column = remainder(this.i + 1, this.num_columns);\n\n            value = [pos_row, pos_column];\n\n            return {\n                value: value,\n                done: false\n            };\n        }\n    }\n\n    class IteratorTrainFactory {\n        public static get_iterator_train(algorithm: Algorithm, segments: Segment[]) {\n\n            let iterator: MatrixIterator;\n\n            switch (algorithm.get_name()) {\n                case algo.DETECT: {\n                    iterator = new MatrixIterator(1, segments.length);\n                    break;\n                }\n                case algo.PREDICT: {\n                    iterator = new MatrixIterator(1, segments.length);\n                    break;\n                }\n                case algo.PARSE: {\n                    iterator = new MatrixIterator(algorithm.get_depth(), segments.length);\n                    break;\n                }\n                case algo.DERIVE: {\n                    iterator = new MatrixIterator(algorithm.get_depth(), segments.length);\n                    break;\n                }\n                default: {\n                    throw ['algorithm of name', algorithm.get_name(), 'not supported'].join(' ')\n                }\n            }\n            return iterator\n        }\n    }\n\n    export class Trainer {\n\n        private window;\n        private algorithm;\n        private clip_user_input;\n        private clip_target;\n        private song;\n        private segments;\n        private messenger;\n\n        // maybe,\n        private struct;\n        private history_user_input;\n\n        private counter_user_input;\n        private limit_user_input;\n        private limit_input_reached;\n\n        private segment_current;\n        private target_current;\n        private subtarget_current;\n\n        // private segment_iterator;\n        private target_iterator;\n        private subtarget_iterator;\n\n        private iterator_matrix_train: MatrixIterator;\n\n        // window is either tree or list\n        // mode is either harmonic or melodic\n        // algorithm is either detect, predict, parse, or derive\n        // history\n        constructor(window, user_input_handler, algorithm, clip_user_input, clip_target, song, segments, messenger) {\n            this.window = window;\n            this.algorithm = algorithm;\n            this.clip_user_input = clip_user_input;\n            this.clip_target = clip_target;\n            this.song = song;\n            this.segments = segments;\n            this.messenger = messenger;\n\n            // this.struct = new StructFactory.get_struct(user_input_handler.mode);\n            this.history_user_input = new HistoryUserInput(\n                this.algorithm,\n                this.segments\n            );\n\n            if (this.algorithm.b_targetable()) {\n                this.create_targets()\n            }\n\n            if (this.algorithm.b_growable()) {\n                this.create_parse_trees()\n            }\n\n            this.iterator_matrix_train = IteratorTrainFactory.get_iterator_train(\n                this.algorithm,\n                this.segments\n            );\n        }\n\n        private create_parse_trees() {\n            let list_parse_tree: ParseTree[] = [];\n\n            switch (this.algorithm.get_name()) {\n                case: algorithms.PARSE {\n                    for (let segment of this.segments) {\n                        for (let note of segment.get_notes()) {\n                            list_parse_tree.push(\n                                new ParseTree(\n                                    note,\n                                    this.algorithm.get_depth()\n                                )\n                            )\n                        }\n                    }\n                    break;\n                }\n                case: algorithms.DERIVE {\n                    let note = this.segments[0].get_note();\n                    list_parse_tree.push(\n                        new ParseTree(\n                            note,\n                            this.algorithm.get_depth()\n                        )\n                    );\n                    break;\n                }\n                default: {\n                    throw ['algorithm of name', this.algorithm.get_name(), 'not supported'].join(' ')\n                }\n            }\n            return list_parse_tree;\n        }\n\n        // now we can assume we have a list instead of a matrix\n        private create_targets() {\n\n            this.clip_target.load_notes_within_markers();\n\n            // let segment_targetable: SegmentTargetable;\n\n            let target_iterators: TargetIterator[] = [];\n\n            for (let segment of this.segments) {\n                // need SegmentTargetable -> TargetIterator\n                target_iterators.push(\n                    this.algorithm.determine_targets(\n                        this.clip_target.get_notes(\n                            segment.beat_start,\n                            0,\n                            segment.beat_end,\n                            128\n                        )\n                    )\n                )\n            }\n\n            this.target_iterators = target_iterators;\n        }\n\n        public clear_window() {\n            this.window.clear()\n        }\n\n        public render_window() {\n            this.window.render()\n        }\n\n        public reset_user_input() {\n            if ([algorithms.DETECT, algorithms.PREDICT].includes(this.algorithm.name)) {\n                this.clip_user_input.set_notes(\n                    this.struct.get_notes(\n                        // TODO: pass requisite information\n                    )\n                );\n            } else {\n                return\n            }\n        }\n\n        private set_loop() {\n            let interval = this.segment_current.get_endpoints_loop();\n\n            this.clip_user_input.set_endpoints_loop(\n                interval[0],\n                interval[1]\n            )\n        }\n\n        public resume() {\n            // set segment current\n            // set target current\n            // set subtarget current\n            this.algorithm.post_init()\n        }\n\n        public pause() {\n            this.algorithm.pre_terminate()\n        }\n\n        // calls next() under the hood, emits intervals to the UserInputHandler, renders the region of interest to cue user\n        public init() {\n            this.advance();\n            this.algorithm.post_init()\n        }\n\n        private advance_segment() {\n\n        }\n\n        private advance() {\n            // this.segment_current = this.segment_iterator.next();\n            // this.target_current = this.target_iterator.next();\n            // this.subtarget_current = this.subtarget_current.next();\n            [i_height, i_width] = this.iterator_matrix_train.next();\n\n            if (this.algorithm.b_targeted()) {\n                // set the targets and shit\n            }\n\n            // set the context in ableton\n            this.set_loop();\n\n            if (done) {\n                this.algorithm.pre_terminate()\n            }\n        }\n\n        // advance_target() {\n        //     this.target_current = this.target_iterator.next()\n        // }\n        //\n        // advance_subtarget() {\n        //     let val = this.subtarget_iterator.next();\n        //     if (val.done) {\n        //         this.advance_target()\n        //     } else {\n        //         this.subtarget_current = val.value\n        //     }\n        // }\n\n        accept_input(input_user) {\n\n            this.counter_user_input++;\n\n            if (this.counter_user_input >= this.limit_user_input) {\n                this.limit_input_reached = true\n            }\n\n            if (this.limit_input_reached) {\n                // completely ignore\n                return\n            }\n\n            if (!this.algorithm.b_targeted()) {\n                this.advance_segment();\n            }\n\n            if (input_user.note.pitch === this.subtarget_current.note.pitch) {\n\n                // NB: we actually add the note that the user was trying to guess, not the note played\n                this.history_user_input.add_subtarget(\n                    this.target_iterator.current().subtarget_iterator.current()\n                );\n\n                this.advance();\n\n                // TODO: make sure for detection/prediction we're making \"input_user\" exactly the same as the \"target note\", if we're restoring sessions from user input\n                // this.window.add(input_user);\n                this.struct.add(input_user);\n                this.window.render(\n                    // this.struct\n                )\n            }\n        }\n    }\n}"]}