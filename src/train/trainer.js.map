{"version":3,"file":"trainer.js","sourceRoot":"","sources":["trainer.ts"],"names":[],"mappings":"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","sourcesContent":["import {note as n} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\n// import {parse_matrix, pwindow} from \"../scripts/parse_tree\";\nimport {algorithm, algorithm as algo} from \"./algorithm\";\nimport {history} from \"../history/history\";\nimport {target} from \"../target/target\";\nimport {segment} from \"../segment/segment\";\nimport {parse} from \"../parse/parse\";\nimport {utils} from \"../utils/utils\";\nimport {window} from \"../render/window\";\nimport {message} from \"../message/messenger\";\nimport {song} from \"../song/song\";\nimport {clip} from \"../clip/clip\";\nconst _ = require('underscore');\nconst l = require('lodash');\n\nexport namespace trainer {\n\n    // import Targetable = train.algorithm.Targetable;\n    import HistoryUserInput = history.HistoryUserInput;\n    // import TargetType = target.TargetType;\n    import TargetIterator = target.TargetIterator;\n    // import MatrixIterator = history.MatrixIterator;\n    import Segment = segment.Segment;\n    import ParseTree = parse.ParseTree;\n    import Algorithm = algorithm.Algorithm;\n    import division_int = utils.division_int;\n    import remainder = utils.remainder;\n    import PARSE = algorithm.PARSE;\n    import DERIVE = algorithm.DERIVE;\n    import DETECT = algorithm.DETECT;\n    import PREDICT = algorithm.PREDICT;\n    import Parse = algorithm.Parse;\n    import Renderable = window.Renderable;\n    import TreeRenderable = window.TreeRenderable;\n    import Subtarget = target.Subtarget;\n    import Target = target.Target;\n    import Messenger = message.Messenger;\n    import Song = song.Song;\n    import Clip = clip.Clip;\n    import FactoryHistoryUserInput = history.FactoryHistoryUserInput;\n    import SubtargetIterator = target.SubtargetIterator;\n\n    export class MatrixIterator {\n        private num_rows: number;\n        private num_columns: number;\n\n        private row_current: number;\n        private column_current: number;\n\n        private i;\n\n        constructor(num_rows: number, num_columns: number) {\n            this.num_rows = num_rows;\n            this.num_columns = num_columns;\n\n            this.i = -1;\n        }\n\n        private next_row() {\n            this.i = this.i + this.num_columns;\n        }\n\n        private next_column() {\n            this.i = this.i + 1;\n        }\n\n        public next() {\n\n            let value: number[] = null;\n\n            this.next_column();\n\n            if (this.i === this.num_columns * this.num_rows + 1) {\n                return {\n                    value: value,\n                    done: true\n                }\n            }\n\n            return {\n                value: this.get_coord_current(),\n                done: false\n            };\n        }\n\n        public get_coord_current(): number[] {\n                // let pos_row = division_int(this.i + 1, this.num_columns);\n                // let pos_column = remainder(this.i + 1, this.num_columns);\n            let pos_row = division_int(this.i, this.num_columns);\n            let pos_column = remainder(this.i, this.num_columns);\n            return [pos_row, pos_column]\n        }\n    }\n\n    class IteratorTrainFactory {\n        public static get_iterator_train(algorithm: Algorithm, segments: Segment[]) {\n\n            let iterator: MatrixIterator;\n\n            switch (algorithm.get_name()) {\n                case algo.DETECT: {\n                    iterator = new MatrixIterator(1, segments.length);\n                    break;\n                }\n                case algo.PREDICT: {\n                    iterator = new MatrixIterator(1, segments.length);\n                    break;\n                }\n                case algo.PARSE: {\n                    iterator = new MatrixIterator(algorithm.get_depth(), segments.length);\n                    break;\n                }\n                case algo.DERIVE: {\n                    iterator = new MatrixIterator(algorithm.get_depth(), segments.length);\n                    break;\n                }\n                default: {\n                    throw ['algorithm of name', algorithm.get_name(), 'not supported'].join(' ')\n                }\n            }\n            return iterator\n        }\n    }\n\n    export class Trainer {\n\n        private window;\n        private algorithm; // TODO: type\n        private clip_user_input: Clip;\n        private clip_target: Clip;\n        private song: Song;\n        private segments: Segment[];\n        private messenger: Messenger;\n\n        private list_parse_tree: ParseTree[];\n        private history_user_input;\n\n        private counter_user_input: number;\n        private limit_user_input: number;\n        private limit_input_reached: boolean;\n\n        private segment_current: Segment;\n        private target_current: Target;\n        private subtarget_current: Subtarget;\n\n        private matrix_target_iterator: TargetIterator[][];\n        private iterator_target_current: TargetIterator;\n\n        private iterator_matrix_train: MatrixIterator;\n\n        private iterator_subtarget_current: SubtargetIterator;\n\n        // window is either tree or list\n        // mode is either harmonic or melodic\n        // algorithm is either detect, predict, parse, or derive\n        // history\n        constructor(window, user_input_handler, algorithm, clip_user_input, clip_target, song, segments, messenger) {\n            this.window = window;\n            this.algorithm = algorithm;\n            this.clip_user_input = clip_user_input;\n            this.clip_target = clip_target;\n            this.song = song;\n            this.segments = segments;\n            this.messenger = messenger;\n\n            // this.struct = new StructFactory.get_struct(user_input_handler.mode);\n            // this.history_user_input = new HistoryUserInput(\n            //     this.algorithm,\n            //     this.segments\n            // );\n\n            this.history_user_input = FactoryHistoryUserInput.create_history_user_input(\n                this.algorithm,\n                this.segments\n            );\n\n            this.iterator_matrix_train = IteratorTrainFactory.get_iterator_train(\n                this.algorithm,\n                this.segments\n            );\n\n            this.matrix_target_iterator = l.cloneDeep(this.history_user_input.matrix_data);\n\n            if (this.algorithm.b_targeted()) {\n                this.create_targets()\n            } else {\n                this.create_parse_trees();\n            }\n        }\n\n        private create_parse_trees() {\n            let list_parse_tree: ParseTree[] = [];\n\n            switch (this.algorithm.get_name()) {\n                case PARSE: {\n                    for (let segment of this.segments) {\n                        let notes = this.clip_user_input.get_notes(\n                            segment.beat_start,\n                            0,\n                            segment.beat_end - segment.beat_start,\n                            128\n                        );\n                        for (let note of notes) {\n                            list_parse_tree.push(\n                                new ParseTree(\n                                    note,\n                                    this.algorithm.get_depth()\n                                )\n                            )\n                        }\n                    }\n                    break;\n                }\n                case DERIVE: {\n                    let note = this.segments[0].get_note();\n                    list_parse_tree.push(\n                        new ParseTree(\n                            note,\n                            this.algorithm.get_depth()\n                        )\n                    );\n                    break;\n                }\n                default: {\n                    throw ['algorithm of name', this.algorithm.get_name(), 'not supported'].join(' ')\n                }\n            }\n            return list_parse_tree;\n        }\n\n        // now we can assume we have a list instead of a matrix\n        private create_targets() {\n\n            this.clip_target.load_notes_within_markers();\n\n            // let segment_targetable: SegmentTargetable;\n\n            // let iterators_target: TargetIterator[] = [];\n\n            for (let i_segment in this.segments) {\n                // need SegmentTargetable -> TargetIterator\n                let segment = this.segments[Number(i_segment)];\n                this.matrix_target_iterator[0][Number(i_segment)] = this.algorithm.determine_targets(\n                    this.clip_target.get_notes(\n                        segment.beat_start,\n                        0,\n                        segment.beat_end,\n                        128\n                    )\n                )\n            }\n        }\n\n        public clear_window() {\n            this.window.clear()\n        }\n\n        public render_window() {\n            this.window.render()\n        }\n\n        public reset_user_input() {\n            if (_.contains([DETECT, PREDICT], this.algorithm.get_name())) {\n                let coords = this.iterator_matrix_train.get_coord_current();\n                let notes_last = this.matrix_target_iterator[coords[0] - 1][coords[1]].get_notes();\n                this.clip_user_input.set_notes(\n                    notes_last\n                );\n            } else {\n                return\n            }\n        }\n\n        private set_loop() {\n            let interval = this.segment_current.get_endpoints_loop();\n\n            this.clip_user_input.set_endpoints_loop(\n                interval[0],\n                interval[1]\n            )\n        }\n\n        public resume() {\n            // set segment current\n            // set target current\n            // set subtarget current\n            this.algorithm.post_init()\n        }\n\n        public pause() {\n            this.algorithm.pre_terminate()\n        }\n\n        public terminate() {\n            this.algorithm.pre_terminate()\n        }\n\n        // calls next() under the hood, emits intervals to the UserInputHandler, renders the region of interest to cue user\n        public init() {\n            this.advance_segment();\n            this.algorithm.post_init(this.song, this.clip_user_input)\n        }\n\n        private advance_segment() {\n            // TODO:\n            let obj_next_coord = this.iterator_matrix_train.next();\n\n            if (obj_next_coord.done) {\n                this.algorithm.terminate()\n            }\n\n            let coord = obj_next_coord.value;\n            this.segment_current = this.segments[coord[1]];\n            this.iterator_target_current = this.matrix_target_iterator[coord[0]][coord[1]];\n\n            let obj_target = this.iterator_target_current.next();\n\n            if (obj_target.done) {\n                return\n            }\n\n            this.target_current = obj_target.value;\n\n            this.iterator_subtarget_current = this.target_current.iterator_subtarget;\n\n            let obj_subtarget = this.iterator_subtarget_current.next();\n\n            if (obj_subtarget.done) {\n                return\n            }\n\n            this.subtarget_current = obj_subtarget.value;\n        }\n\n        private advance_subtarget() {\n            // this.segment_current = this.segment_iterator.next();\n            // this.target_current = this.target_iterator.next();\n            // this.subtarget_current = this.subtarget_current.next();\n            // [i_height, i_width] = this.iterator_matrix_train.next();\n\n\n            let obj_next_subtarget = this.iterator_subtarget_current.next();\n\n            let obj_next_target;\n\n            if (obj_next_subtarget.done) {\n                obj_next_target = this.iterator_target_current.next();\n            }\n\n            if (obj_next_target.done) {\n                let obj_next_coord = this.iterator_matrix_train.next();\n\n                if (obj_next_coord.done) {\n                    this.algorithm.pre_terminate();\n                    return\n                }\n\n                let coord_next = obj_next_coord.value;\n\n                this.iterator_target_current = this.matrix_target_iterator[coord_next[0]][coord_next[1]];\n            }\n\n            // let obj_matrix_next = this.iterator_matrix_train.next();\n            //\n            // if (obj_matrix_next.done) {\n            //     this.algorithm.pre_terminate()\n            // }\n\n            // set segment current\n\n            if (this.algorithm.b_targeted()) {\n                // set the targets and shit\n            }\n\n            // set the context in ableton\n            this.set_loop();\n        }\n\n        // advance_target() {\n        //     this.target_current = this.target_iterator.next()\n        // }\n        //\n        // advance_subtarget() {\n        //     let val = this.subtarget_iterator.next();\n        //     if (val.done) {\n        //         this.advance_target()\n        //     } else {\n        //         this.subtarget_current = val.value\n        //     }\n        // }\n\n        accept_input(input_user) {\n\n            this.counter_user_input++;\n\n            if (this.counter_user_input >= this.limit_user_input) {\n                this.limit_input_reached = true\n            }\n\n            if (this.limit_input_reached) {\n                // completely ignore\n                return\n            }\n\n            // parse/derive logic\n            if (!this.algorithm.b_targeted()) {\n                // this.struct.add(\n                //     input_user\n                // );\n\n                this.list_parse_tree = ParseTree.add(\n                    input_user,\n                    this.list_parse_tree,\n                    this.iterator_matrix_train\n                );\n\n                this.advance_segment();\n\n                this.window.render_regions(\n                    this.iterator_matrix_train,\n                    this.matrix_target_iterator\n                );\n\n                this.window.render_notes(\n                    this.history_user_input\n                );\n\n                this.window.render_tree(\n                    this.list_parse_tree\n                );\n\n                return\n            }\n\n            // detect/predict logic\n            if (input_user.note.pitch === this.subtarget_current.note.pitch) {\n\n                let coords = this.iterator_matrix_train.get_coord_current();\n\n                let target_iterator_current = this.matrix_target_iterator[coords[0]][coords[1]];\n\n                // NB: we actually add the note that the user was trying to guess, not the note played\n                this.history_user_input.add_subtarget(\n                    this.iterator_target_current.current().iterator_subtarget.current()\n                );\n\n                this.advance_subtarget();\n\n                this.window.render_regions(\n                    this.iterator_matrix_train,\n                    this.matrix_target_iterator\n                );\n            }\n        }\n    }\n}"]}