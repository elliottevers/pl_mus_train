{"version":3,"file":"trainer.js","sourceRoot":"","sources":["trainer.ts"],"names":[],"mappings":";;AAAA,qCAA6C;AAC7C,sCAAyC;AACzC,yCAAsC;AACtC,8CAA2C;AAC3C,2CAAwC;AAExC,wCAAqC;AAIrC,qCAAkC;AAClC,wCAAkC;AAClC,IAAM,CAAC,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC;AAChC,IAAM,CAAC,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;AAE5B,IAAiB,OAAO,CA8cvB;AA9cD,WAAiB,OAAO;IAEpB,IAAO,gBAAgB,GAAG,iBAAO,CAAC,gBAAgB,CAAC;IACnD,IAAO,cAAc,GAAG,eAAM,CAAC,cAAc,CAAC;IAE9C,IAAO,KAAK,GAAG,qBAAS,CAAC,KAAK,CAAC;IAC/B,IAAO,MAAM,GAAG,qBAAS,CAAC,MAAM,CAAC;IACjC,IAAO,MAAM,GAAG,qBAAS,CAAC,MAAM,CAAC;IACjC,IAAO,OAAO,GAAG,qBAAS,CAAC,OAAO,CAAC;IAOnC,IAAO,WAAW,GAAG,aAAK,CAAC,WAAW,CAAC;IAEvC,IAAO,2BAA2B,GAAG,iBAAO,CAAC,2BAA2B,CAAC;IACzE,IAAO,oBAAoB,GAAG,iBAAO,CAAC,oBAAoB,CAAC;IAC3D,IAAO,IAAI,GAAG,WAAI,CAAC,IAAI,CAAC;IACxB,IAAO,MAAM,GAAG,YAAG,CAAC,MAAM,CAAC;IAE3B;QA0BI,iBAAY,MAAM,EAAE,kBAAkB,EAAE,SAAS,EAAE,eAAe,EAAE,WAAW,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS;YACtG,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;YACrB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;YAC3B,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;YACvC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;YAC/B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;YACjB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;YACzB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;YAE3B,IAAI,CAAC,qBAAqB,GAAG,oBAAoB,CAAC,kBAAkB,CAChE,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,QAAQ,CAChB,CAAC;YAEF,IAAI,CAAC,YAAY,GAAG,2BAA2B,CAAC,mBAAmB,CAC/D,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,QAAQ,CAChB,CAAC;YAEF,IAAI,CAAC,kBAAkB,GAAG,IAAI,gBAAgB,CAC1C,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,YAAY,CAAC,CACjC,CAAC;YAEF,IAAI,CAAC,MAAM,CAAC,gBAAgB,CACxB,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,QAAQ,CAChB,CAAC;YAEF,IAAI,CAAC,MAAM,CAAC,gBAAgB,CACxB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,CACnD,CAAC;YAEF,IAAI,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,EAAE;gBAC7B,IAAI,CAAC,cAAc,EAAE,CAAA;aACxB;iBAAM;gBACH,IAAI,CAAC,YAAY,GAAG,IAAI,WAAW,CAC/B,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,YAAY,CAAC,CACjC,CAAC;gBACF,IAAI,CAAC,uBAAuB,EAAE,CAAC;aAClC;QACL,CAAC;QAEO,yCAAuB,GAA/B;YAEI,IAAI,iBAAiB,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC;YAE3E,IAAI,IAAI,GAAc,IAAI,SAAS,EAAE,CAAC;YAEtC,IAAI,gBAAgB,GAAG,IAAI,CAAC,KAAK,CAC7B;gBACI,EAAE,EAAE,CAAC,CAAC;gBACN,IAAI,EAAE,IAAI,WAAC,CAAC,IAAI,CACZ,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,EAClC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,EACjD,CAAC,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,GAAG,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,EAC3I,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,EACrC,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CACrC;gBACD,QAAQ,EAAE,EAET;aACJ,CACJ,CAAC;YAEF,IAAI,CAAC,YAAY,CAAC,QAAQ,CACtB,gBAAgB,CACnB,CAAC;YAEF,oDAAoD;YAEpD,IAAI,CAAC,MAAM,CAAC,qBAAqB,CAC7B,gBAAgB,CACnB,CAAC;YAEF,8DAA8D;YAE9D,KAAK,IAAI,SAAS,IAAI,IAAI,CAAC,QAAQ,EAAE;gBAEjC,IAAI,SAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC;gBAE/C,IAAI,MAAI,GAAG,SAAO,CAAC,QAAQ,EAAE,CAAC;gBAE9B,IAAI,qBAAqB,GAAG,CAAC,CAAC,EAAE,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC;gBAEnD,IAAI,CAAC,YAAY,CAAC,SAAS,CACvB,CAAC,MAAI,CAAC,EACN,qBAAqB,CACxB,CAAC;gBACF,IAAI,CAAC,MAAM,CAAC,iBAAiB,CACzB,CAAC,MAAI,CAAC,EACN,qBAAqB,CACxB,CAAA;aACJ;YAED,QAAQ,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,EAAE;gBAC/B,KAAK,KAAK,CAAC,CAAC;oBACR,KAAK,IAAI,SAAS,IAAI,IAAI,CAAC,QAAQ,EAAE;wBACjC,IAAI,SAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC;wBAC/C,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,CAClC,SAAO,CAAC,UAAU,EAClB,CAAC,EACD,SAAO,CAAC,QAAQ,GAAG,SAAO,CAAC,UAAU,EACrC,GAAG,CACN,CAAC;wBACF,IAAI,qBAAqB,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE,GAAG,CAAC,EAAE,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC;wBAEhF,IAAI,CAAC,YAAY,CAAC,SAAS,CACvB,KAAK,EACL,qBAAqB,CACxB,CAAC;wBACF,IAAI,CAAC,MAAM,CAAC,iBAAiB,CACzB,KAAK,EACL,qBAAqB,CACxB,CAAA;qBACJ;oBACD,MAAM;iBACT;gBACD,KAAK,MAAM,CAAC,CAAC;oBACT,mBAAmB;oBACnB,MAAM;iBACT;gBACD,OAAO,CAAC,CAAC;oBACL,MAAM,CAAC,mBAAmB,EAAE,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,EAAE,eAAe,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;iBACpF;aACJ;QACL,CAAC;QAED,uDAAuD;QAC/C,gCAAc,GAAtB;YAEI,IAAI,CAAC,WAAW,CAAC,yBAAyB,EAAE,CAAC;YAE7C,kCAAkC;YAElC,KAAK,IAAI,SAAS,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACjC,IAAI,gBAAgB,GAAG,IAAI,CAAC,SAAS,CAAC,iBAAiB,CACnD,IAAI,CAAC,WAAW,CAAC,SAAS,CACtB,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,UAAU,EAC3C,CAAC,EACD,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,UAAU,EACvF,GAAG,CACN,CACJ,CAAC;gBACF,gDAAgD;gBAChD,iEAAiE;gBACjE,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,GAAG,cAAc,CAAC,oBAAoB,CAAC,gBAAgB,CAAC,CAAC;gBAChG,kCAAkC;gBAClC,gDAAgD;aACnD;QACL,CAAC;QAEM,8BAAY,GAAnB;YACI,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAA;QACvB,CAAC;QAEM,+BAAa,GAApB;YACI,IAAI,KAAK,CAAC;YACV,IAAI,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,EAAE;gBAC7B,kCAAkC;gBAClC,mDAAmD;gBACnD,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,UAAU,CAAC,GAAG,CAAC,UAAC,SAAS;oBACpE,OAAO,SAAS,CAAC,IAAI,CAAA;gBACzB,CAAC,CAAC,CAAA;aACL;iBAAM;gBACH,KAAK,GAAG,CAAC,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,CAAC,CAAA;aAC5C;YACD,IAAI,CAAC,MAAM,CAAC,MAAM,CACd,IAAI,CAAC,qBAAqB,EAC1B,KAAK,EACL,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,YAAY,CACpB,CAAA;QACL,CAAC;QAEM,kCAAgB,GAAvB;YACI,IAAI,CAAC,CAAC,QAAQ,CAAC,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,EAAE;gBAC1D,IAAI,MAAM,GAAG,IAAI,CAAC,qBAAqB,CAAC,iBAAiB,EAAE,CAAC;gBAC5D,IAAI,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,EAAE,CAAC;gBACzE,IAAI,CAAC,eAAe,CAAC,SAAS,CAC1B,UAAU,CACb,CAAC;aACL;iBAAM;gBACH,OAAM;aACT;QACL,CAAC;QAEO,0BAAQ,GAAhB;YACI,IAAI,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,EAAE,CAAC;YAEzD,IAAI,CAAC,eAAe,CAAC,kBAAkB,CACnC,QAAQ,CAAC,CAAC,CAAC,EACX,QAAQ,CAAC,CAAC,CAAC,CACd,CAAA;QACL,CAAC;QAEM,wBAAM,GAAb;YACI,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE,CAAA;QAC9B,CAAC;QAEM,uBAAK,GAAZ;YACI,IAAI,MAAM,GAAG,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC;YAC/B,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YACtC,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,eAAe,CAAC,CAAA;QACjE,CAAC;QAEM,2BAAS,GAAhB;YACI,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,eAAe,CAAC,CAAA;QACjE,CAAC;QAEM,sBAAI,GAAX,UAAY,OAAiB;YACzB,IAAI,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,EAAE;gBAC7B,IAAI,CAAC,iBAAiB,EAAE,CAAC;aAC5B;iBAAM;gBACH,IAAI,CAAC,eAAe,EAAE,CAAC;aAC1B;YACD,IAAI,CAAC,OAAO,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,eAAe,CAAC,CAAA;aAE5D;QACL,CAAC;QAEO,iCAAe,GAAvB;YAEI,IAAI,cAAc,GAAG,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,CAAC;YAEvD,IAAI,cAAc,CAAC,IAAI,EAAE;gBACrB,QAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,EAAE;oBAC9B,KAAK,KAAK,CAAC,CAAC;wBAER,iCAAiC;wBACjC,KAAK,IAAI,SAAS,IAAI,IAAI,CAAC,QAAQ,EAAE;4BACjC,IAAI,SAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC;4BAC/C,IAAI,CAAC,YAAY,CAAC,GAAG,CACjB,CAAC,SAAO,CAAC,QAAQ,EAAE,CAAC,EACpB,CAAC,CAAC,EAAE,MAAM,CAAC,SAAS,CAAC,CAAC,EACtB,IAAI,CAAC,SAAS,CACjB,CAAC;yBACL;wBAED,6BAA6B;wBAC7B,IAAI,CAAC,YAAY,CAAC,GAAG,CACjB,CAAC,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC,CAAC,EACzD,CAAC,CAAC,CAAC,CAAC,EACJ,IAAI,CAAC,SAAS,CACjB,CAAC;wBACF,MAAM;qBACT;oBACD,KAAK,MAAM,CAAC,CAAC;wBACT,MAAM;qBACT;oBACD,OAAO,CAAC,CAAC;wBACL,MAAM,yBAAyB,CAAA;qBAClC;iBACJ;gBAED,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;gBAE9D,OAAM;aACT;YAED,IAAI,KAAK,GAAG,cAAc,CAAC,KAAK,CAAC;YAEjC,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QACnD,CAAC;QAEO,mCAAiB,GAAzB;YAEI,IAAI,cAAc,GAAY,CAAC,CAAC,IAAI,CAAC,qBAAqB,CAAC,SAAS,CAAC,CAAC;YAEtE,IAAI,cAAc,EAAE;gBAChB,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,CAAC;gBAElC,IAAI,CAAC,uBAAuB,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAEvD,IAAI,CAAC,uBAAuB,CAAC,IAAI,EAAE,CAAC;gBAEpC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,uBAAuB,CAAC,OAAO,EAAE,CAAC;gBAE7D,IAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC;gBAEzE,IAAI,CAAC,0BAA0B,CAAC,IAAI,EAAE,CAAC;gBAEvC,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,0BAA0B,CAAC,OAAO,EAAE,CAAC;gBAEnE,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,qBAAqB,CAAC,iBAAiB,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;gBAExF,OAAM;aACT;YAED,IAAI,cAAc,GAAa,IAAI,CAAC,uBAAuB,CAAC,OAAO,CAAC;YAEpE,IAAI,aAAa,GAAa,IAAI,CAAC,qBAAqB,CAAC,iBAAiB,EAAE,CAAC;YAE7E,IAAI,kBAAkB,GAAG,IAAI,CAAC,0BAA0B,CAAC,IAAI,EAAE,CAAC;YAEhE,IAAI,kBAAkB,CAAC,IAAI,EAAE;gBAEzB,IAAI,eAAe,GAAG,IAAI,CAAC,uBAAuB,CAAC,IAAI,EAAE,CAAC;gBAE1D,IAAI,eAAe,CAAC,IAAI,EAAE;oBAEtB,IAAI,cAAc,GAAG,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,CAAC;oBAEvD,IAAI,CAAC,kBAAkB,CAAC,GAAG,CACvB,cAAc,EACd,aAAa,CAChB,CAAC;oBAEF,IAAI,cAAc,CAAC,IAAI,EAAE;wBACrB,IAAI,CAAC,kBAAkB,CAAC,GAAG,CACvB,cAAc,EACd,aAAa,CAChB,CAAC;wBAEF,IAAI,CAAC,SAAS,CAAC,aAAa,EAAE,CAAC;wBAE/B,OAAM;qBACT;oBAED,IAAI,UAAU,GAAG,cAAc,CAAC,KAAK,CAAC;oBAEtC,IAAI,CAAC,uBAAuB,GAAG,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;oBAE/E,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;oBAEpD,IAAI,4BAA4B,GAAG,IAAI,CAAC,uBAAuB,CAAC,IAAI,EAAE,CAAC;oBAEvE,IAAI,CAAC,cAAc,GAAG,4BAA4B,CAAC,KAAK,CAAC;oBAEzD,IAAI,+BAA+B,GAAG,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,IAAI,EAAE,CAAC;oBAEpF,IAAI,CAAC,iBAAiB,GAAG,+BAA+B,CAAC,KAAK,CAAC;oBAE/D,IAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC;oBAEzE,OAAM;iBACT;gBAED,IAAI,CAAC,cAAc,GAAG,eAAe,CAAC,KAAK,CAAC;gBAE5C,IAAI,8BAA8B,GAAG,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,IAAI,EAAE,CAAC;gBAEnF,IAAI,CAAC,iBAAiB,GAAG,8BAA8B,CAAC,KAAK,CAAC;gBAE9D,IAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC;gBAEzE,OAAM;aACT;YAED,IAAI,CAAC,iBAAiB,GAAG,kBAAkB,CAAC,KAAK,CAAC;YAElD,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,qBAAqB,CAAC,iBAAiB,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5F,CAAC;QAED,8BAAY,GAAZ,UAAa,gBAA0C;YAEnD,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAE1B,IAAI,IAAI,CAAC,kBAAkB,IAAI,IAAI,CAAC,gBAAgB,EAAE;gBAClD,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAA;aAClC;YAED,IAAI,IAAI,CAAC,mBAAmB,EAAE;gBAC1B,oBAAoB;gBACpB,OAAM;aACT;YAED,qBAAqB;YACrB,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,EAAE;gBAE9B,IAAI,CAAC,kBAAkB,CAAC,GAAG,CACvB,gBAAgB,EAChB,IAAI,CAAC,qBAAqB,CAAC,iBAAiB,EAAE,CACjD,CAAC;gBAEF,IAAI,CAAC,MAAM,CAAC,iBAAiB,CACzB,gBAAgB,EAChB,IAAI,CAAC,qBAAqB,CAAC,iBAAiB,EAAE,CACjD,CAAC;gBAEF,kBAAkB;gBAClB,IAAI,CAAC,YAAY,CAAC,GAAG,CACjB,gBAAgB,EAChB,IAAI,CAAC,qBAAqB,CAAC,iBAAiB,EAAE,EAC9C,IAAI,CAAC,SAAS,CACjB,CAAC;gBAEF,IAAI,CAAC,eAAe,EAAE,CAAC;gBAEvB,IAAI,CAAC,aAAa,EAAE,CAAC;gBAErB,OAAM;aACT;YAED,uBAAuB;YACvB,IAAI,gBAAgB,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,KAAK,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE;gBAEvF,IAAI,CAAC,MAAM,CAAC,iBAAiB,CACzB,CAAC,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAC7B,IAAI,CAAC,qBAAqB,CAAC,iBAAiB,EAAE,CACjD,CAAC;gBAEF,IAAI,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,EAAE;oBAC7B,2BAA2B;iBAC9B;gBAED,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBAEzB,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAEhB,IAAI,CAAC,aAAa,EAAE,CAAC;aACxB;QACL,CAAC;QACL,cAAC;IAAD,CAAC,AAvbD,IAubC;IAvbY,eAAO,UAubnB,CAAA;AACL,CAAC,EA9cgB,OAAO,GAAP,eAAO,KAAP,eAAO,QA8cvB","sourcesContent":["import {note, note as n} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {algorithm} from \"./algorithm\";\nimport {history} from \"../history/history\";\nimport {target} from \"../target/target\";\nimport {segment} from \"../segment/segment\";\nimport {parse} from \"../parse/parse\";\nimport {message} from \"../message/messenger\";\nimport {song} from \"../song/song\";\nimport {clip} from \"../clip/clip\";\nimport {iterate} from \"./iterate\";\nimport {log} from \"../log/logger\";\nconst _ = require('underscore');\nconst l = require('lodash');\n\nexport namespace trainer {\n\n    import HistoryUserInput = history.HistoryUserInput;\n    import TargetIterator = target.TargetIterator;\n    import Segment = segment.Segment;\n    import PARSE = algorithm.PARSE;\n    import DERIVE = algorithm.DERIVE;\n    import DETECT = algorithm.DETECT;\n    import PREDICT = algorithm.PREDICT;\n    import Subtarget = target.Subtarget;\n    import Target = target.Target;\n    import Messenger = message.Messenger;\n    import Song = song.Song;\n    import Clip = clip.Clip;\n    import SubtargetIterator = target.SubtargetIterator;\n    import StructParse = parse.StructParse;\n    import MatrixIterator = iterate.MatrixIterator;\n    import FactoryMatrixTargetIterator = iterate.FactoryMatrixTargetIterator;\n    import IteratorTrainFactory = iterate.IteratorTrainFactory;\n    import Note = note.Note;\n    import Logger = log.Logger;\n\n    export class Trainer {\n\n        private window;\n        public algorithm; // TODO: type\n        private clip_user_input: Clip;\n        private clip_target: Clip;\n        private song: Song;\n        private segments: Segment[];\n        private messenger: Messenger;\n\n        private struct_parse: StructParse;\n        public history_user_input;\n\n        private counter_user_input: number;\n        private limit_user_input: number;\n        private limit_input_reached: boolean;\n\n        private segment_current: Segment;\n        private target_current: Target;\n        private subtarget_current: Subtarget;\n\n        private matrix_focus: TargetIterator[][];\n        public iterator_matrix_train: MatrixIterator;\n        private iterator_target_current: TargetIterator;\n        private iterator_subtarget_current: SubtargetIterator;\n\n        constructor(window, user_input_handler, algorithm, clip_user_input, clip_target, song, segments, messenger) {\n            this.window = window;\n            this.algorithm = algorithm;\n            this.clip_user_input = clip_user_input;\n            this.clip_target = clip_target;\n            this.song = song;\n            this.segments = segments;\n            this.messenger = messenger;\n\n            this.iterator_matrix_train = IteratorTrainFactory.get_iterator_train(\n                this.algorithm,\n                this.segments\n            );\n\n            this.matrix_focus = FactoryMatrixTargetIterator.create_matrix_focus(\n                this.algorithm,\n                this.segments\n            );\n\n            this.history_user_input = new HistoryUserInput(\n                l.cloneDeep(this.matrix_focus)\n            );\n\n            this.window.initialize_clips(\n                this.algorithm,\n                this.segments\n            );\n\n            this.window.set_length_beats(\n                this.segments[this.segments.length - 1].beat_end\n            );\n\n            if (this.algorithm.b_targeted()) {\n                this.create_targets()\n            } else {\n                this.struct_parse = new StructParse(\n                    l.cloneDeep(this.matrix_focus)\n                );\n                this.initialize_struct_parse();\n            }\n        }\n\n        private initialize_struct_parse() {\n\n            let note_segment_last = this.segments[this.segments.length - 1].get_note();\n\n            let tree: TreeModel = new TreeModel();\n\n            let note_length_full = tree.parse(\n                {\n                    id: -1, // TODO: hashing scheme for clip id and beat start\n                    note: new n.Note(\n                        note_segment_last.model.note.pitch,\n                        this.segments[0].get_note().model.note.beat_start,\n                        (note_segment_last.model.note.beat_start + note_segment_last.model.note.beats_duration) - this.segments[0].get_note().model.note.beat_start,\n                        note_segment_last.model.note.velocity,\n                        note_segment_last.model.note.muted\n                    ),\n                    children: [\n\n                    ]\n                }\n            );\n\n            this.struct_parse.set_root(\n                note_length_full\n            );\n\n            // TODO: make the root the length of the entire song\n\n            this.window.add_note_to_clip_root(\n                note_length_full\n            );\n\n            // set first layer, which are the various key center estimates\n\n            for (let i_segment in this.segments) {\n\n                let segment = this.segments[Number(i_segment)];\n\n                let note = segment.get_note();\n\n                let coord_current_virtual = [0, Number(i_segment)];\n\n                this.struct_parse.set_notes(\n                    [note],\n                    coord_current_virtual\n                );\n                this.window.add_notes_to_clip(\n                    [note],\n                    coord_current_virtual\n                )\n            }\n\n            switch (this.algorithm.get_name()) {\n                case PARSE: {\n                    for (let i_segment in this.segments) {\n                        let segment = this.segments[Number(i_segment)];\n                        let notes = this.clip_target.get_notes(\n                            segment.beat_start,\n                            0,\n                            segment.beat_end - segment.beat_start,\n                            128\n                        );\n                        let coord_current_virtual = [this.algorithm.get_depth() - 1, Number(i_segment)];\n\n                        this.struct_parse.set_notes(\n                            notes,\n                            coord_current_virtual\n                        );\n                        this.window.add_notes_to_clip(\n                            notes,\n                            coord_current_virtual\n                        )\n                    }\n                    break;\n                }\n                case DERIVE: {\n                    //  TODO: anything?\n                    break;\n                }\n                default: {\n                    throw ['algorithm of name', this.algorithm.get_name(), 'not supported'].join(' ')\n                }\n            }\n        }\n\n        // now we can assume we have a list instead of a matrix\n        private create_targets() {\n\n            this.clip_target.load_notes_within_markers();\n\n            // let logger = new Logger('max');\n\n            for (let i_segment in this.segments) {\n                let sequence_targets = this.algorithm.determine_targets(\n                    this.clip_target.get_notes(\n                        this.segments[Number(i_segment)].beat_start,\n                        0,\n                        this.segments[Number(i_segment)].beat_end - this.segments[Number(i_segment)].beat_start,\n                        128\n                    )\n                );\n                // logger.log(JSON.stringify(sequence_targets));\n                // logger.log(JSON.stringify(this.clip_target.get_end_marker()));\n                this.matrix_focus[0][Number(i_segment)] = TargetIterator.from_sequence_target(sequence_targets);\n                // let logger = new Logger('max');\n                // logger.log(JSON.stringify(sequence_targets));\n            }\n        }\n\n        public clear_window() {\n            this.window.clear()\n        }\n\n        public render_window() {\n            let notes;\n            if (this.algorithm.b_targeted()) {\n                // let logger = new Logger('max');\n                // logger.log(JSON.stringify(this.target_current));\n                notes = this.target_current.iterator_subtarget.subtargets.map((subtarget)=> {\n                    return subtarget.note\n                })\n            } else {\n                notes = [this.segment_current.get_note()]\n            }\n            this.window.render(\n                this.iterator_matrix_train,\n                notes,\n                this.algorithm,\n                this.struct_parse\n            )\n        }\n\n        public reset_user_input() {\n            if (_.contains([DETECT, PREDICT], this.algorithm.get_name())) {\n                let coords = this.iterator_matrix_train.get_coord_current();\n                let notes_last = this.matrix_focus[coords[0] - 1][coords[1]].get_notes();\n                this.clip_user_input.set_notes(\n                    notes_last\n                );\n            } else {\n                return\n            }\n        }\n\n        private set_loop() {\n            let interval = this.segment_current.get_endpoints_loop();\n\n            this.clip_user_input.set_endpoints_loop(\n                interval[0],\n                interval[1]\n            )\n        }\n\n        public resume() {\n            this.algorithm.post_init()\n        }\n\n        public pause() {\n            let logger = new Logger('max');\n            logger.log(JSON.stringify(this.song));\n            this.algorithm.pre_terminate(this.song, this.clip_user_input)\n        }\n\n        public terminate() {\n            this.algorithm.pre_terminate(this.song, this.clip_user_input)\n        }\n\n        public init(virtual?: boolean) {\n            if (this.algorithm.b_targeted()) {\n                this.advance_subtarget();\n            } else {\n                this.advance_segment();\n            }\n            if (!virtual) {\n                this.algorithm.post_init(this.song, this.clip_user_input)\n\n            }\n        }\n\n        private advance_segment() {\n\n            let obj_next_coord = this.iterator_matrix_train.next();\n\n            if (obj_next_coord.done) {\n                switch(this.algorithm.get_name()) {\n                    case PARSE: {\n\n                        // make connections with segments\n                        for (let i_segment in this.segments) {\n                            let segment = this.segments[Number(i_segment)];\n                            this.struct_parse.add(\n                                [segment.get_note()],\n                                [0, Number(i_segment)],\n                                this.algorithm\n                            );\n                        }\n\n                        // make conncetions with root\n                        this.struct_parse.add(\n                            [Note.from_note_renderable(this.struct_parse.get_root())],\n                            [-1],\n                            this.algorithm\n                        );\n                        break;\n                    }\n                    case DERIVE: {\n                        break;\n                    }\n                    default: {\n                        throw 'error advancing segment'\n                    }\n                }\n\n                this.algorithm.pre_terminate(this.song, this.clip_user_input);\n\n                return\n            }\n\n            let coord = obj_next_coord.value;\n\n            this.segment_current = this.segments[coord[1]];\n        }\n\n        private advance_subtarget() {\n\n            let have_not_begun: boolean = (!this.iterator_matrix_train.b_started);\n\n            if (have_not_begun) {\n                this.iterator_matrix_train.next();\n\n                this.iterator_target_current = this.matrix_focus[0][0];\n\n                this.iterator_target_current.next();\n\n                this.target_current = this.iterator_target_current.current();\n\n                this.iterator_subtarget_current = this.target_current.iterator_subtarget;\n\n                this.iterator_subtarget_current.next();\n\n                this.subtarget_current = this.iterator_subtarget_current.current();\n\n                this.segment_current = this.segments[this.iterator_matrix_train.get_coord_current()[1]];\n\n                return\n            }\n\n            let target_at_time: Target[] = this.iterator_target_current.targets;\n\n            let coord_at_time: number[] = this.iterator_matrix_train.get_coord_current();\n\n            let obj_next_subtarget = this.iterator_subtarget_current.next();\n\n            if (obj_next_subtarget.done) {\n\n                let obj_next_target = this.iterator_target_current.next();\n\n                if (obj_next_target.done) {\n\n                    let obj_next_coord = this.iterator_matrix_train.next();\n\n                    this.history_user_input.add(\n                        target_at_time,\n                        coord_at_time\n                    );\n\n                    if (obj_next_coord.done) {\n                        this.history_user_input.add(\n                            target_at_time,\n                            coord_at_time\n                        );\n\n                        this.algorithm.pre_terminate();\n\n                        return\n                    }\n\n                    let coord_next = obj_next_coord.value;\n\n                    this.iterator_target_current = this.matrix_focus[coord_next[0]][coord_next[1]];\n\n                    this.segment_current = this.segments[coord_next[1]];\n\n                    let obj_next_target_twice_nested = this.iterator_target_current.next();\n\n                    this.target_current = obj_next_target_twice_nested.value;\n\n                    let obj_next_subtarget_twice_nested = this.target_current.iterator_subtarget.next();\n\n                    this.subtarget_current = obj_next_subtarget_twice_nested.value;\n\n                    this.iterator_subtarget_current = this.target_current.iterator_subtarget;\n\n                    return\n                }\n\n                this.target_current = obj_next_target.value;\n\n                let obj_next_subtarget_once_nested = this.target_current.iterator_subtarget.next();\n\n                this.subtarget_current = obj_next_subtarget_once_nested.value;\n\n                this.iterator_subtarget_current = this.target_current.iterator_subtarget;\n\n                return\n            }\n\n            this.subtarget_current = obj_next_subtarget.value;\n\n            this.segment_current = this.segments[this.iterator_matrix_train.get_coord_current()[1]];\n        }\n\n        accept_input(notes_input_user: TreeModel.Node<n.Note>[]) {\n\n            this.counter_user_input++;\n\n            if (this.counter_user_input >= this.limit_user_input) {\n                this.limit_input_reached = true\n            }\n\n            if (this.limit_input_reached) {\n                // completely ignore\n                return\n            }\n\n            // parse/derive logic\n            if (!this.algorithm.b_targeted()) {\n\n                this.history_user_input.add(\n                    notes_input_user,\n                    this.iterator_matrix_train.get_coord_current()\n                );\n\n                this.window.add_notes_to_clip(\n                    notes_input_user,\n                    this.iterator_matrix_train.get_coord_current()\n                );\n\n                // TODO: implement\n                this.struct_parse.add(\n                    notes_input_user,\n                    this.iterator_matrix_train.get_coord_current(),\n                    this.algorithm\n                );\n\n                this.advance_segment();\n\n                this.render_window();\n\n                return\n            }\n\n            // detect/predict logic\n            if (notes_input_user[0].model.note.pitch === this.subtarget_current.note.model.note.pitch) {\n\n                this.window.add_notes_to_clip(\n                    [this.subtarget_current.note],\n                    this.iterator_matrix_train.get_coord_current()\n                );\n\n                if (this.algorithm.b_targeted()) {\n                    // set the targets and shit\n                }\n\n                this.advance_subtarget();\n\n                this.set_loop();\n\n                this.render_window();\n            }\n        }\n    }\n}"]}