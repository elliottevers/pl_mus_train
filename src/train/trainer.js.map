{"version":3,"file":"trainer.js","sourceRoot":"","sources":["trainer.ts"],"names":[],"mappings":"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","sourcesContent":["import {note as n} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {parse_matrix, pwindow} from \"../scripts/parse_tree\";\nimport {algorithm, train} from \"./algorithm\";\nimport {history} from \"../history/history\";\nimport {target} from \"../target/target\";\n\nexport namespace trainer {\n\n    import Targetable = train.algorithm.Targetable;\n    import HistoryUserInput = history.HistoryUserInput;\n    import TargetType = target.TargetType;\n    import TargetIterator = target.TargetIterator;\n\n    export class Trainer {\n\n        private window;\n        private algorithm;\n        private clip_user_input;\n        private clip_target;\n        private song;\n        private segments;\n        private messenger;\n\n        private struct;\n        private history_user_input;\n\n        private counter_user_input;\n        private limit_user_input;\n        private limit_input_reached;\n\n        private segment_current;\n        private target_current;\n        private subtarget_current;\n\n        // private segment_iterator;\n        private target_iterator;\n        private subtarget_iterator;\n\n        // window is either tree or list\n        // mode is either harmonic or melodic\n        // algorithm is either detect, predict, parse, or derive\n        // history\n        constructor(window, user_input_handler, algorithm, clip_user_input, clip_target, song, segments, messenger) {\n            this.window = window;\n            this.algorithm = algorithm;\n            this.clip_user_input = clip_user_input;\n            this.clip_target = clip_target;\n            this.song = song;\n            this.segments = segments;\n            this.messenger = messenger;\n\n            this.struct = new StructFactory.get_struct(user_input_handler.mode);\n            this.history_user_input = new HistoryUserInput(user_input_handler.mode);\n\n            if (this.algorithm.b_targetable()) {\n                this.create_targets()\n            }\n        }\n\n        // now we can assume we have a list instead of a matrix\n        private create_targets() {\n\n            this.clip_target.load_notes_within_markers();\n\n            // let segment_targetable: SegmentTargetable;\n\n            let list_segments_targetable: TargetIterator[] = [];\n\n            for (let segment of this.segments) {\n                // need SegmentTargetable -> TargetIterator\n                list_segments_targetable.push(\n                    this.algorithm.determine_targets(\n                        this.clip_target.get_notes(\n                            segment.beat_start,\n                            0,\n                            segment.beat_end,\n                            128\n                        )\n                    )\n                )\n            }\n\n            this.target_iterator\n            // this.segment_iterator\n            this.subtarget_iterator\n        }\n\n        public clear_window() {\n            this.window.clear()\n        }\n\n        public render_window() {\n            this.window.render()\n        }\n\n        public reset_user_input() {\n            if ([algorithms.DETECT, algorithms.PREDICT].includes(this.algorithm.name)) {\n                this.clip_user_input.set_notes(\n                    this.struct.get_notes(\n                        // TODO: pass requisite information\n                    )\n                );\n            } else {\n                return\n            }\n        }\n\n        private set_loop() {\n            let interval = this.segment_current.get_endpoints_loop();\n\n            this.clip_user_input.set_endpoints_loop(\n                interval[0],\n                interval[1]\n            )\n        }\n\n        public resume() {\n            // set segment current\n            // set target current\n            // set subtarget current\n            this.algorithm.post_init()\n        }\n\n        public pause() {\n            this.algorithm.pre_terminate()\n        }\n\n        // calls next() under the hood, emits intervals to the UserInputHandler, renders the region of interest to cue user\n        public init() {\n            this.advance_segment();\n            this.algorithm.post_init()\n        }\n\n        advance_segment() {\n            this.segment_current = this.segment_iterator.next();\n            this.target_current = this.target_iterator.next();\n            this.subtarget_current = this.subtarget_current.next();\n\n            if (done) {\n                this.algorithm.pre_terminate()\n            }\n        }\n\n        advance_target() {\n            this.target_current = this.target_iterator.next()\n        }\n\n        advance_subtarget() {\n            let val = this.subtarget_iterator.next();\n            if (val.done) {\n                this.advance_target()\n            } else {\n                this.subtarget_current = val.value\n            }\n        }\n\n        accept_input(input_user) {\n\n            this.counter_user_input++;\n\n            if (this.counter_user_input >= this.limit_user_input) {\n                this.limit_input_reached = true\n            }\n\n            if (this.limit_input_reached) {\n                // completely ignore\n                return\n            }\n\n            let targetable = true; // this.algorithm instanceof Targetable;\n\n            if (!targetable) {\n                this.advance_segment();\n            }\n\n            if (input_user === this.subtarget_current) {\n                this.history_user_input.add_subtarget(input_user);\n                this.advance_subtarget();\n                this.set_loop();\n                // TODO: make sure for detection/prediction we're making \"input_user\" exactly the same as the \"target note\", if we're restoring sessions from user input\n                // this.window.add(input_user);\n                this.struct.add(input_user);\n                this.window.render(\n                    this.struct\n                )\n            }\n        }\n    }\n}"]}