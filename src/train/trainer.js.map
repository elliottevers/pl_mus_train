{"version":3,"file":"trainer.js","sourceRoot":"","sources":["trainer.ts"],"names":[],"mappings":"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","sourcesContent":["import {note as n} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {parse_matrix, pwindow} from \"../scripts/parse_tree\";\nimport {algorithm, train} from \"./algorithm\";\nimport {history} from \"../history/history\";\n\nexport namespace trainer {\n\n    import Targetable = train.algorithm.Targetable;\n    import HistoryUserInput = history.HistoryUserInput;\n\n    export class Trainer {\n\n        private history_user_input;\n        private algorithm; // TODO: annotation\n\n        // window is either tree or list\n        // mode is either harmonic or melodic\n        // algorithm is either detect, predict, parse, or derive\n        // history\n        constructor(window, mode, algorithm, clip_user_input) {\n            this.window = window;\n            if (mode === modes.HARMONY) {\n\n            }\n            this.algorithm = algorithm;\n            this.history_user_input = new HistoryUserInput(mode);\n            this.clip_user_input = clip_user_input\n        }\n\n        private set_loop() {\n            let interval = this.segment_current.get_endpoints_loop();\n\n            this.clip_user_input.set_endpoints_loop(\n                interval[0],\n                interval[1]\n            )\n        }\n\n        public resume() {\n            // set segment current\n            // set target current\n            // set subtarget current\n            this.algorithm.post_init()\n        }\n\n        public pause() {\n            this.algorithm.pre_terminate()\n        }\n\n        public init() {\n            this.advance_segment()\n            this.algorithm.post_init()\n        }\n\n        advance_segment() {\n            this.segment_current = this.segment_iterator.next();\n            this.target_current = this.target_iterator.next();\n            this.subtarget_current = this.subtarget_current.next();\n\n            if (done) {\n                this.algorithm.pre_terminate()\n            }\n        }\n\n        advance_target() {\n            this.target_current = this.target_iterator.next()\n        }\n\n        advance_subtarget() {\n            let val = this.subtarget_iterator.next();\n            if (val.done) {\n                this.advance_target()\n            } else {\n                this.subtarget_current = val.value\n            }\n        }\n\n        accept_input(input_user) {\n\n            this.counter_user_input++;\n\n            if (this.counter_user_input >= this.limit_user_input) {\n                this.limit_input_reached = true\n            }\n\n            if (this.limit_input_reached) {\n                // completely ignore\n            }\n\n            let targetable = this.algorithm instanceof Targetable;\n\n            if (!targetable) {\n                this.advance_segment();\n                // return this.segment_iterator.next()\n            }\n\n            if (input_user === this.subtarget_current) {\n                this.advance_subtarget();\n            }\n        }\n\n        public accept(notes: TreeModel.Node<n.Note>[]) {\n            // elaborate, summarize, detect, predict\n\n            this.window.insert(\n                notes\n            );\n\n            parse_matrix.set_notes(\n                tree_depth_iterator.get_index_current(),\n                segment_iterator.get_index_current(),\n                notes\n            );\n\n            this.window.render();\n\n            if (segment_next.done) {\n\n                this.stop();\n\n                return\n            }\n\n            this.segment_current = val_segment_next;\n\n            let interval = this.segment_current.get_endpoints_loop();\n\n            this.clip_user_input.set_endpoints_loop(\n                interval[0],\n                interval[1]\n            );\n        }\n\n        public render() {\n            // this.window\n            // get messages regions\n            // get messages\n        }\n\n        public clear_render() {\n            // this.window.clear()\n        }\n\n        public init() {\n            // this.iterator.next()\n            // this.clip_user_input.fire()\n        }\n\n        private stop() {\n\n        }\n    }\n}\n\n\n\n\n\nnotes_segments = [note1, note2];\n\ntrainer.set_segments(notes_segments);\n\ntrainer.init(\n\n); // calls next() under the hood, emits intervals to the UserInputHandler, renders the region of interest to cue user\n\ntrainer.accept(\n    note_1\n);\n\ntrainer.accept(\n    note_2\n);\n\ntrainer.accept(\n    note_3\n);\n\ntrainer.clear_render(\n\n);\n\nlet freezer = new TrainFreezer(\n    'node'\n);\n\nfreezer.freeze(\n    trainer,\n    '/path/to/file'\n);\n\nlet thawer = new TrainThawer(\n    'node'\n);\n\nlet train_thawed = thawer.thaw(\n    '/path/to/file'\n);\n\ntrain_thawed.render(\n\n);"]}