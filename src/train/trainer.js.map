{"version":3,"file":"trainer.js","sourceRoot":"","sources":["trainer.ts"],"names":[],"mappings":"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","sourcesContent":["import {note as n} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {parse_matrix, pwindow} from \"../scripts/parse_tree\";\nimport {algorithm, train} from \"./algorithm\";\nimport {history} from \"../history/history\";\nimport {target} from \"../target/target\";\n\nexport namespace trainer {\n\n    import Targetable = train.algorithm.Targetable;\n    import HistoryUserInput = history.HistoryUserInput;\n    import TargetType = target.TargetType;\n    import TargetIterator = target.TargetIterator;\n\n    export class Trainer {\n\n        private window;\n        private algorithm;\n        private clip_user_input;\n        private clip_target;\n        private song;\n        private segments;\n        private messenger;\n\n        // maybe,\n        private struct;\n        private history_user_input;\n\n        private counter_user_input;\n        private limit_user_input;\n        private limit_input_reached;\n\n        private segment_current;\n        private target_current;\n        private subtarget_current;\n\n        // private segment_iterator;\n        private target_iterator;\n        private subtarget_iterator;\n\n        // window is either tree or list\n        // mode is either harmonic or melodic\n        // algorithm is either detect, predict, parse, or derive\n        // history\n        constructor(window, user_input_handler, algorithm, clip_user_input, clip_target, song, segments, messenger) {\n            this.window = window;\n            this.algorithm = algorithm;\n            this.clip_user_input = clip_user_input;\n            this.clip_target = clip_target;\n            this.song = song;\n            this.segments = segments;\n            this.messenger = messenger;\n\n            this.struct = new StructFactory.get_struct(user_input_handler.mode);\n            this.history_user_input = new HistoryUserInput(user_input_handler.mode);\n\n            if (this.algorithm.b_targetable()) {\n                this.create_targets()\n            }\n        }\n\n        // now we can assume we have a list instead of a matrix\n        private create_targets() {\n\n            this.clip_target.load_notes_within_markers();\n\n            // let segment_targetable: SegmentTargetable;\n\n            let target_iterators: TargetIterator[] = [];\n\n            for (let segment of this.segments) {\n                // need SegmentTargetable -> TargetIterator\n                target_iterators.push(\n                    this.algorithm.determine_targets(\n                        this.clip_target.get_notes(\n                            segment.beat_start,\n                            0,\n                            segment.beat_end,\n                            128\n                        )\n                    )\n                )\n            }\n\n            this.target_iterators = target_iterators;\n        }\n\n        public clear_window() {\n            this.window.clear()\n        }\n\n        public render_window() {\n            this.window.render()\n        }\n\n        public reset_user_input() {\n            if ([algorithms.DETECT, algorithms.PREDICT].includes(this.algorithm.name)) {\n                this.clip_user_input.set_notes(\n                    this.struct.get_notes(\n                        // TODO: pass requisite information\n                    )\n                );\n            } else {\n                return\n            }\n        }\n\n        private set_loop() {\n            let interval = this.segment_current.get_endpoints_loop();\n\n            this.clip_user_input.set_endpoints_loop(\n                interval[0],\n                interval[1]\n            )\n        }\n\n        public resume() {\n            // set segment current\n            // set target current\n            // set subtarget current\n            this.algorithm.post_init()\n        }\n\n        public pause() {\n            this.algorithm.pre_terminate()\n        }\n\n        // calls next() under the hood, emits intervals to the UserInputHandler, renders the region of interest to cue user\n        public init() {\n            this.advance();\n            this.algorithm.post_init()\n        }\n\n        private advance_segment() {\n\n        }\n\n        private advance() {\n            // this.segment_current = this.segment_iterator.next();\n            // this.target_current = this.target_iterator.next();\n            // this.subtarget_current = this.subtarget_current.next();\n            [i_height, i_width] = this.iterator.next();\n\n            if (this.algorithm.b_targeted()) {\n                // set the targets and shit\n            }\n\n            // set the context in ableton\n            this.set_loop();\n\n            if (done) {\n                this.algorithm.pre_terminate()\n            }\n        }\n\n        // advance_target() {\n        //     this.target_current = this.target_iterator.next()\n        // }\n        //\n        // advance_subtarget() {\n        //     let val = this.subtarget_iterator.next();\n        //     if (val.done) {\n        //         this.advance_target()\n        //     } else {\n        //         this.subtarget_current = val.value\n        //     }\n        // }\n\n        accept_input(input_user) {\n\n            this.counter_user_input++;\n\n            if (this.counter_user_input >= this.limit_user_input) {\n                this.limit_input_reached = true\n            }\n\n            if (this.limit_input_reached) {\n                // completely ignore\n                return\n            }\n\n            if (!this.algorithm.b_targeted()) {\n                this.advance_segment();\n            }\n\n            if (input_user.note.pitch === this.subtarget_current.note.pitch) {\n\n                // NB: we actually add the note that the user was trying to guess, not the note played\n                this.history_user_input.add_subtarget(\n                    this.target_iterator.current().subtarget_iterator.current()\n                );\n\n                this.advance();\n\n                // TODO: make sure for detection/prediction we're making \"input_user\" exactly the same as the \"target note\", if we're restoring sessions from user input\n                // this.window.add(input_user);\n                this.struct.add(input_user);\n                this.window.render(\n                    // this.struct\n                )\n            }\n        }\n    }\n}"]}