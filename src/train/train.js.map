{"version":3,"file":"train.js","sourceRoot":"","sources":["train.ts"],"names":[],"mappings":";;AAEA,oDAA4D;AAG5D,IAAiB,KAAK,CAmGrB;AAnGD,WAAiB,KAAK;IAIlB;QAEI,iBAAY,MAAM,EAAE,IAAI;YACpB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;YACrB,IAAI,IAAI,KAAK,KAAK,CAAC,OAAO,EAAE;aAE3B;QACL,CAAC;QAED,iCAAe,GAAf;YACI,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,CAAA;QACvD,CAAC;QAED,gCAAc,GAAd;YACI,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,CAAA;QACrD,CAAC;QAED,mCAAiB,GAAjB;YACI,IAAI,GAAG,GAAG,IAAI,CAAC,kBAAkB,CAAC,IAAI,EAAE,CAAA;YACxC,IAAI,GAAG,CAAC,IAAI,EAAE;gBACV,IAAI,CAAC,cAAc,EAAE,CAAA;aACxB;iBAAM;gBACH,IAAI,CAAC,iBAAiB,GAAG,GAAG,CAAC,KAAK,CAAA;aACrC;QACL,CAAC;QAED,8BAAY,GAAZ,UAAc,UAAU;YAEpB,IAAI,IAAI,CAAC,mBAAmB,EAAE;gBAC1B,oBAAoB;aACvB;YAED,IAAI,UAAU,GAAG,IAAI,CAAC,SAAS,YAAY,UAAU,CAAC;YAEtD,IAAI,CAAC,UAAU,EAAE;gBACb,IAAI,CAAC,eAAe,EAAE,CAAC;gBACvB,sCAAsC;aACzC;YAED,IAAI,UAAU,KAAK,IAAI,CAAC,iBAAiB,EAAE;gBACvC,IAAI,CAAC,iBAAiB,EAAE,CAAC;aAC5B;QACL,CAAC;QAEM,wBAAM,GAAb,UAAc,KAA+B;YACzC,wCAAwC;YAExC,IAAI,CAAC,MAAM,CAAC,MAAM,CACd,KAAK,CACR,CAAC;YAEF,yBAAY,CAAC,SAAS,CAClB,mBAAmB,CAAC,iBAAiB,EAAE,EACvC,gBAAgB,CAAC,iBAAiB,EAAE,EACpC,KAAK,CACR,CAAC;YAEF,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;YAErB,IAAI,YAAY,CAAC,IAAI,EAAE;gBAEnB,IAAI,CAAC,IAAI,EAAE,CAAC;gBAEZ,OAAM;aACT;YAED,IAAI,CAAC,eAAe,GAAG,gBAAgB,CAAC;YAExC,IAAI,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,EAAE,CAAC;YAEzD,IAAI,CAAC,eAAe,CAAC,kBAAkB,CACnC,QAAQ,CAAC,CAAC,CAAC,EACX,QAAQ,CAAC,CAAC,CAAC,CACd,CAAC;QACN,CAAC;QAEM,wBAAM,GAAb;YACI,cAAc;YACd,uBAAuB;YACvB,eAAe;QACnB,CAAC;QAEM,8BAAY,GAAnB;YACI,sBAAsB;QAC1B,CAAC;QAEM,sBAAI,GAAX;YACI,uBAAuB;YACvB,8BAA8B;QAClC,CAAC;QAEO,sBAAI,GAAZ;QAEA,CAAC;QACL,cAAC;IAAD,CAAC,AA9FD,IA8FC;IA9FY,aAAO,UA8FnB,CAAA;AACL,CAAC,EAnGgB,KAAK,GAAL,aAAK,KAAL,aAAK,QAmGrB;AAMD,cAAc,GAAG,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;AAEhC,OAAO,CAAC,YAAY,CAAC,cAAc,CAAC,CAAC;AAErC,OAAO,CAAC,IAAI,EAEX,CAAC,CAAC,mHAAmH;AAEtH,OAAO,CAAC,MAAM,CACV,MAAM,CACT,CAAC;AAEF,OAAO,CAAC,MAAM,CACV,MAAM,CACT,CAAC;AAEF,OAAO,CAAC,MAAM,CACV,MAAM,CACT,CAAC;AAEF,OAAO,CAAC,YAAY,EAEnB,CAAC;AAEF,IAAI,OAAO,GAAG,IAAI,YAAY,CAC1B,MAAM,CACT,CAAC;AAEF,OAAO,CAAC,MAAM,CACV,OAAO,EACP,eAAe,CAClB,CAAC;AAEF,IAAI,MAAM,GAAG,IAAI,WAAW,CACxB,MAAM,CACT,CAAC;AAEF,IAAI,YAAY,GAAG,MAAM,CAAC,IAAI,CAC1B,eAAe,CAClB,CAAC;AAEF,YAAY,CAAC,MAAM,EAElB,CAAC","sourcesContent":["import {note as n} from \"../note/note\";\nimport TreeModel = require(\"tree-model\");\nimport {parse_matrix, pwindow} from \"../scripts/parse_tree\";\nimport {train} from \"./algorithm\";\n\nexport namespace train {\n\n    import Targetable = train.algorithm.Targetable;\n\n    export class Trainer {\n\n        constructor(window, mode) {\n            this.window = window;\n            if (mode === modes.HARMONY) {\n\n            }\n        }\n\n        advance_segment() {\n            this.segment_current = this.segment_iterator.next()\n        }\n\n        advance_target() {\n            this.target_current = this.target_iterator.next()\n        }\n\n        advance_subtarget() {\n            let val = this.subtarget_iterator.next()\n            if (val.done) {\n                this.advance_target()\n            } else {\n                this.subtarget_current = val.value\n            }\n        }\n\n        accept_input (input_user) {\n\n            if (this.limit_input_reached) {\n                // completely ignore\n            }\n\n            let targetable = this.algorithm instanceof Targetable;\n\n            if (!targetable) {\n                this.advance_segment();\n                // return this.segment_iterator.next()\n            }\n\n            if (input_user === this.subtarget_current) {\n                this.advance_subtarget();\n            }\n        }\n\n        public accept(notes: TreeModel.Node<n.Note>[]) {\n            // elaborate, summarize, detect, predict\n\n            this.window.insert(\n                notes\n            );\n\n            parse_matrix.set_notes(\n                tree_depth_iterator.get_index_current(),\n                segment_iterator.get_index_current(),\n                notes\n            );\n\n            this.window.render();\n\n            if (segment_next.done) {\n\n                this.stop();\n\n                return\n            }\n\n            this.segment_current = val_segment_next;\n\n            let interval = this.segment_current.get_endpoints_loop();\n\n            this.clip_user_input.set_endpoints_loop(\n                interval[0],\n                interval[1]\n            );\n        }\n\n        public render() {\n            // this.window\n            // get messages regions\n            // get messages\n        }\n\n        public clear_render() {\n            // this.window.clear()\n        }\n\n        public init() {\n            // this.iterator.next()\n            // this.clip_user_input.fire()\n        }\n\n        private stop() {\n\n        }\n    }\n}\n\n\n\n\n\nnotes_segments = [note1, note2];\n\ntrainer.set_segments(notes_segments);\n\ntrainer.init(\n\n); // calls next() under the hood, emits intervals to the UserInputHandler, renders the region of interest to cue user\n\ntrainer.accept(\n    note_1\n);\n\ntrainer.accept(\n    note_2\n);\n\ntrainer.accept(\n    note_3\n);\n\ntrainer.clear_render(\n\n);\n\nlet freezer = new TrainFreezer(\n    'node'\n);\n\nfreezer.freeze(\n    trainer,\n    '/path/to/file'\n);\n\nlet thawer = new TrainThawer(\n    'node'\n);\n\nlet train_thawed = thawer.thaw(\n    '/path/to/file'\n);\n\ntrain_thawed.render(\n\n);"]}